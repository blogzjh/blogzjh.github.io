<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>张家豪的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="张家豪的博客">
<meta property="og:url" content="https://blogzjh.github.io/page/4/index.html">
<meta property="og:site_name" content="张家豪的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="张家豪">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="张家豪的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">张家豪的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blogzjh.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-疫情港口挂靠数ARIMA时序分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/17/%E7%96%AB%E6%83%85%E6%B8%AF%E5%8F%A3%E6%8C%82%E9%9D%A0%E6%95%B0ARIMA%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2022-07-17T03:21:13.000Z" itemprop="datePublished">2022-07-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/17/%E7%96%AB%E6%83%85%E6%B8%AF%E5%8F%A3%E6%8C%82%E9%9D%A0%E6%95%B0ARIMA%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/">疫情港口挂靠数ARIMA时序分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="摘-要"><a href="#摘-要" class="headerlink" title="摘  要"></a>摘  要</h1><ul>
<li> 新冠肺炎疫情自 2020 年年初爆发以来，传播速度快、传染范围广，截止至 2021 年 3 月底已经造成了 1 亿 2 千多万人感染。对全球各行各业都带来了无法忽视的影响，同时无疑是给世界贸易经济一击重创。而海上运输作为全世界货物流通的最主要运输方式，新冠疫情对航运业的影响是非常明显的。</li>
<li> 全文研究的是新冠肺炎疫情对集装箱运输市场的影响。首先简述了新冠病毒在全球的扩散范围，简单讲述了 ARIMA 模型建模方法，再分析可能疫情对集装箱市场的影响因素，利用一阶差分得到平稳数据，白噪声检验验证是否是随机序列，利用 ACF 和 PACF 检验在置信区间中选择出合适的 p、 q 值，配合一阶差分的参数 1 进行建模， 建模之后使用 AIC 准则评估模型，残差检验白噪声，用模型预测测试集，最终分析，总结。 </li>
<li>*关键词**：新冠肺炎疫情；集装箱供需变化；ARIMA； </li>
</ul>
<ol>
<li>绪论……………………………………………………………………………………………………………………………………. 4</li>
<li>1 选题背景………………………………………………………………………………………………………………………… 4</li>
<li>2 国内外研究现状 …………………………………………………………………………………………………………….. 4</li>
<li>疫情对国际集装箱运输的影响波动………………………………………………………………………………. 5</li>
<li>ARIMA 模型概述………………………………………………………………………………………………………………. 6</li>
<li>建立 ARIMA 模型的步骤…………………………………………………………………………………………………. 7</li>
<li>1 时间序列的获取 …………………………………………………………………………………………………………….. 7</li>
<li>2 时间序列的预处理…………………………………………………………………………………………………………. 7</li>
<li>2.1 预处理………………………………………………………………………………………………………………………. 7</li>
<li>2.2 差分得到平稳数据………………………………………………………………………………………………….. 8</li>
<li>2.3 验证是否随机序列………………………………………………………………………………………………….. 8</li>
<li>3ACF 和 PACF 检验…………………………………………………………………………………………………………… 8</li>
<li>4AIC 准则 …………………………………………………………………………………………………………………………… 9</li>
<li>5 模型评估………………………………………………………………………………………………………………………..10</li>
<li>6 残差检验………………………………………………………………………………………………………………………..11</li>
<li>7 模型预测………………………………………………………………………………………………………………………..12</li>
<li>8 结果可视化…………………………………………………………………………………………………………………….13</li>
<li>9 结果分析………………………………………………………………………………………………………………………..13</li>
<li>结论与展望………………………………………………………………………………………………………………………15</li>
<li>参考文献…………………………………………………………………………………………………………………………..16</li>
</ol>
<h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h1><p>2020 年新年伊始，新冠疫情爆发，在这次冲击下,航运市场整体处于低迷状态，燃油价格、集装箱船队每周平均闲置运力受到明显影响，同时还加剧了集装箱港口的拥堵程度。一项由 11 条分航线指数组成，这些全球重要航线的集装箱运价指数组成了代表国际集装箱运输市场价格走势的重要指标之一——中国出口集装箱运价指数(Chinese Container FreightIndex,CCFI)，能够客观地反映集装箱市场状况。本文通过收集了 2020 年 1 月至 2021 年 3 月<br>的中国集装箱出口运价指数来研究疫情期间集装箱挂靠数的变化情况以及影响因素在航运企业角度，提出规避风险的有效措施。</p>
<h2 id="1-1选题背景"><a href="#1-1选题背景" class="headerlink" title="1.1选题背景"></a>1.1选题背景</h2><ul>
<li>航运是全球贸易的大动脉，是世界经济的“晴雨表”，具有成本低、覆盖面广、量大等优势。当中国航运能够在世界舞台上脱颖而出，影响着、并改变着世界。航运需求作为一种派生需求，它是随着全球贸易的发展和货物的海上流通应运而生的，为国际的贸易提供运输服务，因此航运业的发展与全球经济贸易的发展息息相关。集装箱市场作为国际航运市场的重要组成部分，由于货物种类繁多，同时还受到经济发展程度不同、世界政治环境、经济环境和产业结构等等众多因素的影响。</li>
<li>集装箱运输船的供给是缺乏弹性的。中国出口集装箱运价指数能够直接衡量运力需求和集装箱船供给之间的关系，当运力需求上升时，航运企业此时就会选择采购建造新船，而造船耗时长，成本高，若船造好后赶上运力需求下降，则造好的船只能搁置，一条船的搁置成本很高，然而航运公司并不能通过短期搁置部分船只来暂时减少运力来紧密跟踪市场需求。基于以上原因，在航运业中，当运输能力的供求达到平衡状态时，即使需求有一个细微的正<br>边际增长，也会迅速推高货运指数;相反，一个微小的负边际增量会导致这些指数的暴跌。供给端收缩促进了当前集运行业的复苏，复苏的力度取决于需求，如果需求保持稳定，复苏将是相对温和的；如果需求增长超出预期，将带来强劲的复苏。其中，中国的出口是影响海洋运输需求的重要因素，而中国的进口是影响干散货需求的重要因素。 2020 年底，中国进出口数据超过预期。如果这一趋势能够保持下去，将为航运业的复苏形成强有力的支撑。</li>
</ul>
<h2 id="1-2国内外研究现状"><a href="#1-2国内外研究现状" class="headerlink" title="1.2国内外研究现状"></a>1.2国内外研究现状</h2><ul>
<li>新冠疫情爆发以来，国内外集装箱运输市场纷纷展现出集装箱空箱运输困难、难以周转、多数船舶停航延期、港口拥堵严重、人员调度困难以及运费持续上涨等负面因素，导致全球航运供应链滞塞。通过分析新冠疫情在全球的扩散范围内对集装箱市场的供需两方面影响因素，能够得出燃油价格、集装箱船队每周平均闲置运力和集装箱港口拥堵程度对中国出口集装箱运价指数影响明显，而随着疫情得到有效控制，出口集装箱运价指数在 2020 年底激增并持续较长时间。</li>
<li>航运作为全球贸易流通的命脉，不少专业机构和专家对疫情下的航运变化展开过研究：2020 年底，海事咨询机构——Sea Intelligence，公布了全球海运运输量的相关数据并加以分析，得出结论，在 2020 年上半年，由于疫情影响，全球海运两总体下降了 25%， 2020 年全年整体下降 10%。截止至 2020 年 9 月底，全球主要挂靠港的集装箱运转量多数显示负增长，但是，在中国，以宁波舟山港为主的集装箱吞吐量却保持不同程度的增长，反映出了中国国内市场的经济恢复较好。</li>
<li>2020 年交通运输部科学研究院刘宏甲院士、周健院士于交通统计信息与经济运行分析技术实验室发表了《新冠肺炎疫情对水路运价的影响研究及展望》，报告中将此次疫情和SARS 病毒对比，发现新冠比 SARS 对我国航运业产生的影响更严重，表现在了全国居家隔离，小型企业停产甚至倒闭，使的原材料和产品贸易量减少；与此同时，人员返岗困难，导致港口操作人员紧缺。船舶的停泊时间增加。中远海运散货运输有限公司的王婧妍发表了《浅析新冠疫情的世界性爆发对航运业的影响》，该文章指出疫情带来的影响主要展现在了船舶进出港口、航运企业业务运营以及人力资源方面，航运企业还需要在未来的日子里研究初疫情影响运价的机制，采取有力措施来规避运价大幅度波动的影响。</li>
<li>目前相关数据研究表明， 2020 年中国各港口吞吐量在 1 至 3 月份明显下滑，由于 4 月起国内疫情得到较好的控制，直到 2020 年末，疫情在国外爆发，而中国得到了很好的控制，我国开始大量的出口医疗设施设备，国外船舶选择中国中转，从而促使了中国的出口市场发展向好。</li>
</ul>
<h1 id="2-疫情对国际集装箱运输影响波动"><a href="#2-疫情对国际集装箱运输影响波动" class="headerlink" title="2.疫情对国际集装箱运输影响波动"></a>2.疫情对国际集装箱运输影响波动</h1><ul>
<li>中国出口集装箱数主要收到直接间接两个方面因素的影响，直接影响因素有：供需变化、运输成本变化以及国家调控。而间接影响因素主要有：市场结构、全球经济、国际政治变化以及自然灾害等突发之间因素。而 2020 年突发的新型冠状肺炎疫情正是属于突发自然灾害因素，同时，也在不同程度上波及到了除此之外的其他因素。</li>
<li>需求首先下降，然后上升，而价格迅速上涨。到 2020 年，全球集装箱运输市场的需求量将先减少后增加。</li>
</ul>
<ul>
<li><p>中国出口集装箱运输市场在第一季度呈下降趋势，在第二季度末稳步反弹，并在第三和第四季度加速上升趋势。自 6 月以来，对集装箱运输的需求迅速恢复，船舶和集装箱在某些路线上开始紧缺，市场逐渐接近卖方市场。即使在第四季度，西方国家对运输的需求仍然很高，国外的流行病导致港口拥挤，收集和交付系统不足，这降低了船舶的运营效率，使返回空集装箱的工作变得困难。 2020 年我国出口集装箱运输指数平均水平为 984.42 点，比上年增长 19.5％。</p>
</li>
<li><p>由于疫情爆发时许多国家施加的限制和严格控制，国际贸易下降，对国际运输的需求也下降。因此，在冠状肺炎的全球大规模流行的情况下，航运企业将需要对当前环境进行透彻的分析，积极应对并向前迈进。疫情直接导致韩滚需求先降后升，而整个物流供应链的成本增加了，伴随着增加了额外的运输和劳动力成本，加上由于大量集装箱船舶长期闲置搁浅，短期内国内外集装箱船舶的运力过剩，还是给航运企业经营带来较大困难。</p>
</li>
<li><p>供应链的成本增加了。由于新冠疫情，集装箱运输链上的压力越来越大，面临着提供门到门运输的多式联运和综合物流服务提供商。运价成本费用的增加主要反映在以下因素上：其中之一是货运量的增加。其次，由于路线的缩短，运输承运人的成本将增加。此外，根据国际海事组织的有关规定，今年船运公司将开始平均每个集装箱低硫燃料附加费 100-200 美元。第三是预防传染病的材料成本。第四，由于集装箱运输不畅造成的滞期成本。 第五，人工成本增加。第六，集装箱储存成本集装箱航线正在缓慢恢复。自疫情爆发以来，春节期间的贸易量有所下降，航运公司也计划停航。受疫情影响，取消航班较去年同期明显增加。目前，国内沿江航线运力已陆续恢复，与往年相比，春节淡季捉襟见肘，迟迟未能恢复出货。虽然航道正在恢复，但船舶的装货率已经下降。大量集装箱船长期搁浅。这一传染病增加了额外的运输和劳动力成本。短期内，国内外集装箱船舶运力过剩，给航运企业经营带来较大困难。</p>
</li>
<li><p>第一季度，中国出口集装箱运输市场行情总体呈下行态势，第二季度末企稳回升，第三、四季度加速上行。自 6 月份开始，集装箱运输需求快速恢复，部分航线开始出现缺船缺箱局面，市场逐渐转向卖方市场。进入第四季度，多数航线现货市场运价进入直线上升阶段。新冠肺炎影响的知识中国经济发展的节奏，中国经济具有实力大、动力足、强力强，发展空间大的特征。疫情发生以来，中国人的消费方式加快了转变，而居家办公也突破了传统的办公方式，客观地来讲，疫情推动航运企业数字化转型，加快了数字化创新的进程。在国际贸易中货物贸易的占比比起服务贸易明显高出许多，此次疫情市场上的生产要素向高端服务转移，大力发展服务贸易的契机。</p>
</li>
</ul>
<h1 id="3-ARIMA模型概述"><a href="#3-ARIMA模型概述" class="headerlink" title="3.ARIMA模型概述"></a>3.ARIMA模型概述</h1><ul>
<li><p>ARIMA 模型（英语： Autoregressive Integrated Moving Average model），差分整合移动平均自回归模型，又称整合移动平均自回归模型（移动也可称作滑动），是时间序列预测分析方法之一。 ARIMA(p， d， q)中， AR 是“自回归”， p 为自回归项数； MA 为“滑动平均”，q 为滑动平均项数， d 为使之成为平稳序列所做的差分次数（阶数）。 “差分”一词虽未出现在ARIMA 的英文名称中，却是关键步骤。</p>
</li>
<li><p>对时间序列数据进行分析和预测比较完善和精确的算法是博克思-詹金斯<br>(Box-Jenkins)方法，其常用模型包括：自回归模型（AR 模型）、滑动平均模型（MA 模型）、（自回归-滑动平均混合模型） ARMA 模型、（差分整合移动平均自回归模型） ARIMA 模型。ARIMA(p， d， q)模型是 ARMA(p， q)模型的扩展。 ARIMA(p， d， q)模型可以表示为：<img src="https://img-blog.csdnimg.cn/e2059db4feae44d3bf1328329751966a.png"></p>
</li>
</ul>
<h1 id="4-建立ARIMA模型的步骤"><a href="#4-建立ARIMA模型的步骤" class="headerlink" title="4.建立ARIMA模型的步骤"></a>4.建立ARIMA模型的步骤</h1><h2 id="4-1时间序列的预处理"><a href="#4-1时间序列的预处理" class="headerlink" title="4.1时间序列的预处理"></a>4.1时间序列的预处理</h2><ul>
<li>时间序列的预处理包括两个方面的检验，平稳性检验和白噪声检验。能够适用 ARMA 模型进行分析预测的时间序列必须满足的条件是<strong>平稳非白噪声序列</strong>。</li>
<li>差分的次数就是模型 ARIMA(p,d,q)的阶数，理论上说，差分的次数越多，对时序信息的非平稳确定性信息的提取越充分，但是从理论上说，差分的次数并非越多越好，<strong>每一次差分运算，都会造成信息的损失</strong>，所以应当避免过分的差分，一般在应用中，差分的阶数不超过 2</li>
</ul>
<h3 id="4-1-1预处理"><a href="#4-1-1预处理" class="headerlink" title="4.1.1预处理"></a>4.1.1预处理</h3><pre><code>#导入 python 相关模块
import warnings warnings.filterwarnings(&quot;ignore&quot;)
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.api as sm
import statsmodels.tsa.stattools as ts from statsmodels.graphics.api
import qqplot from sklearn
import preprocessing from sklearn.metrics
import mean_squared_error

#使用 read_csv 方法读取数据集中，列名为‘value’的数据序列
train=pd.read_csv(&#39;C:/Users/user/Desktop/ 港 口 靠 挂 数 .csv&#39;, header=0,
parse_dates=[0], index_col=0, squeeze=True)
#做 adf 单位根检验
result = ts.adfuller(train)
print(result)
</code></pre>
<p>(-1.6084751426812451, 0.47933490167167303, 18, 426, {‘1%’: -3.4457939940402107,’5%’: -2.8683485906158963, ‘10%’: -2.570396746236417}, 3355.7564277245247)</p>
<p><strong>结果分析</strong>： adf 单位根检验结果可知， t 统计量不显著大于 1%， 5%， 10%，且 p_value 值显著大于 0.05，因此此时间序列不是平稳序列，需要做一阶差分处理。</p>
<h3 id="4-1-2差分得到平稳数据"><a href="#4-1-2差分得到平稳数据" class="headerlink" title="4.1.2差分得到平稳数据"></a>4.1.2差分得到平稳数据</h3><pre><code>#因为原数据不平稳，因此做一阶差分
train_diff1=train.diff(1).dropna()
result = ts.adfuller(train_diff1)
print(result) #得出一阶差分后，发现平稳
</code></pre>
<p>(-10.251689978153886, 4.468421753473792e-18, 15, 427, {‘1%’: -<br>3.445757604526768, ‘5%’: -2.8683325885102855, ‘10%’: -2.5703882165206853},3361.719726005615)</p>
<p><strong>结果分析</strong>：数据经过一阶差分之后，再经过 adf 单位根检验结果可知， t 统计量显著小于 1%，5%， 10%，且 p_value 值显著小于 0.05，因此差分后的数据是平稳的，即可进行下一步操作。</p>
<h3 id="4-1-3验证是否随机序列"><a href="#4-1-3验证是否随机序列" class="headerlink" title="4.1.3验证是否随机序列"></a>4.1.3验证是否随机序列</h3><pre><code>#白噪声检验 lb_pavlue 和 bp_pvalue 值显著小于 0.05，说明不是纯随机序列
from statsmodels.stats.diagnostic import acorr_ljungbox
acorr_ljungbox(train_diff1, lags=1,boxpierce=True)
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/18cd0ab2e9004651a2e4cf1480be700e.png"><br><strong>结果分析</strong>：由白噪声检验可知， p_value 和 lb_value 值显著小于 0.05，因此此序列<strong>不是纯随机序列，因此此序列有研究的意义</strong>，可进行下一步操作。</p>
<h2 id="4-2ACF检验和PACF检验"><a href="#4-2ACF检验和PACF检验" class="headerlink" title="4.2ACF检验和PACF检验"></a>4.2ACF检验和PACF检验</h2><ul>
<li>ACF 是一个完整的自相关函数，可为我们提供具有滞后值的任何序列的自相关值。简单来说，它描述了该序列的当前值与其过去的值之间的相关程度。时间序列可以包含趋势，季节性，周期性和残差等成分。 ACF 在寻找相关性时会考虑所有这些成分。<br>直观上来说， ACF 描述了一个观测值和另一个观测值之间的自相关，包括直接和间接的相关性信息</li>
<li>PACF 是部分自相关函数或者偏自相关函数。基本上，它不是找到像 ACF 这样的滞后与当前的相关性，而是找到残差（在去除了之前的滞后已经解释的影响之后仍然存在）与下一个滞后值的相关性。因此，如果残差中有任何可以由下一个滞后建模的隐藏信息，我们可能会获得良好的相关性，并且在建模时我们会将下一个滞后作为特征。请记住，在建模时，我们不想保留太多相互关联的特征，因为这会产生多重共线性问题。因此，我们只需要保留相关功能。</li>
</ul>
<p>⚫ 采用自相关函数（ACF）、偏自相关函数（PACF） 来判别 ARMA(p,q)模型的系数和阶数。<br>⚫ 自相关函数(ACF)描述时间序列观测值与其过去的观测值之间的线性相关性。<br>⚫ 偏自相关函数(PACF)描述在给定中间观测值的条件下时间序列观测值与其过去的观测值之间的线性相关性</p>
<pre><code>#adf 检验,看图得出移动平均模型阶数 q 值为 2 或 3
fig = plt.figure(figsize=(12, 8))
ax1 = fig.add_subplot(211)
fig = sm.graphics.tsa.plot_acf(train_diff1, lags=16, ax=ax1)
ax1.xaxis.set_ticks_position(&#39;bottom&#39;)
fig.tight_layout()
#pacf 检验，看图得出自回归模型阶数 p 值为 5 或 6
ax2 = fig.add_subplot(212)
fig = sm.graphics.tsa.plot_pacf(train_diff1, lags=16, ax=ax2)
ax2.xaxis.set_ticks_position(&#39;bottom&#39;) fig.tight_layout() plt.show()
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/6cb324c779504719bfd0cc94748381ba.png"><br><img src="https://img-blog.csdnimg.cn/d2759f31845d4d2ba70248ad6cf498ba.png"><br><strong>结果分析</strong>：由 pacf 图像可知， p 值为 5 或 6， acf 图像可知 q 值为 2 或 3，因此 arima 模型的备选参数有四组，分别是（5， 1， 2）、（5， 1， 3）、（6， 1， 2）、（6， 1， 3）四组，接下来使用模型评估方法，选取最下 mse 值得参数进行建模。</p>
<h2 id="4-3AIC准则"><a href="#4-3AIC准则" class="headerlink" title="4.3AIC准则"></a>4.3AIC准则</h2><p>AIC 信息准则即 Akaike information criterion， 是<strong>衡量统计模型拟合优良性</strong>(Goodness oft)的一种标准，由于它为日本统计学家杰池弘欢创立和发展的，因此又称赤池信息量准则。它建立在熵的概念基础上，可以权衡所估计模型的复杂度和此模型拟合数据的优良性。</p>
<pre><code>    #定义 evaluate_arima_model（），输入 X 为历史数据， arima_order 为备选的（p， q）对
    def evaluate_arima_model(X, arima_order):
# 选取数据的前 2/3 作为训练集，后 1/3 作为测试集
train_size = int(len(X) * 0.66)
train, test = X[0:train_size], X[train_size:]
history = [x for x in train]
#通过训练集输出 prediction
predictions = list()
for t in range(len(test)):
model = sm.tsa.arima.ARIMA(history, order=arima_order)
model_fit = model.fit()
yhat = model_fit.forecast()
predictions.append(yhat)
history.append(test[t])
# 将测试集与 prediction 做误差分析，输出误差值
error = mean_squared_error(test, predictions)
return error
</code></pre>
<p>输出结果： 用 AIC 方法得到最优的 p 值是 8,q 值是 8</p>
<h2 id="4-4模型评估"><a href="#4-4模型评估" class="headerlink" title="4.4模型评估"></a>4.4模型评估</h2><pre><code>#将输入数据标准化，便于模型检验
X=preprocessing.scale(train_diff1)
#对三个（p， 1， q）做模型评估，输出误差值 mse，选最小 mse 的参数
mse = evaluate_arima_model(X,(5,1,2))
print(&quot;p=5,d=1,q=2 mse= %.3f&quot; %mse)
mse = evaluate_arima_model(X,(6,1,2))
print(&quot;p=6,d=1,q=2 mse= %.3f&quot; %mse)
mse = evaluate_arima_model(X,(5,1,3))
print(&quot;p=5,d=1,q=3 mse= %.3f&quot; %mse)
mse = evaluate_arima_model(X,(6,1,3))
print(&quot;p=6,d=1,q=3 mse= %.3f&quot; %mse)
mse = evaluate_arima_model(X,(8,1,8))
print(&quot;p=8,d=1,q=8 mse= %.3f&quot; %mse)
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/1f584fac2aa74af9988d48fe747d2955.png"><br>结果分析：通过模型评估得到的五组参数选定值，计算出的 mse，选取得到最小 mse=0.533得（8， 1， 8）参数，选定为 arima 模型得 order 值。</p>
<h2 id="4-5残差检验"><a href="#4-5残差检验" class="headerlink" title="4.5残差检验"></a>4.5残差检验</h2><p>建立模型后，需要对残差序列进行检验。若残差序列为白噪声序列，则说明时间序列中的有用信息已经被提取完毕，剩下的全是随机扰动，是无法预测和使用的，即建模成功，可以进行下一步的预测。</p>
<pre><code>model=sm.tsa.arima.ARIMA(history,order=(8,1,8)).fit()
#产生残差
resid=model.resid
#自相关图
sm.graphics.tsa.plot_acf(resid,lags=15).show()
#偏自相关图
sm.graphics.tsa.plot_pacf(resid,lags=15).show()
#qq 图
qqplot(resid, line=&#39;q&#39;, fit=True).show()
#LB 检验，说明残差序列是白噪声
print(&#39;残差序列的白噪声检验结果为：
&#39;,acorr_ljungbox(resid,lags=1,boxpierce=True))
</code></pre>
<p>残差序列的白噪声检验结果为： lb_stat lb_pvalue bp_stat bp_pvalue<br>1 0.062923 0.801934 0.062499 0.802589</p>
<p><img src="https://img-blog.csdnimg.cn/680b3f6021cd46e9a346ea3e58e14407.png"><br><img src="https://img-blog.csdnimg.cn/019adfcce47e4f549469841c9b906588.png"><br><img src="https://img-blog.csdnimg.cn/cf8c1c5dff3b41ee9664b87099ed462e.png"><br>结果分析：通过残差序列的残差检验可知， p_value 和 lb_value 值都显著大于 0.05，因此表明，残差序列是纯随机序列，即残差序列没有其余信息可以提取，且残差序列符合线性正态分布，因此认为 arima 模型建模预测成功。</p>
<h2 id="4-6模型预测"><a href="#4-6模型预测" class="headerlink" title="4.6模型预测"></a>4.6模型预测</h2><pre><code>#标准化 train_use
X = train_diff1.values
X=preprocessing.scale(X)
train1, test1 = X[0:50], X[51:101]
history = [x for x in train1]
predictions = list()
#使用 ARIMA（8,1,8）进行模型预测
for t in range(len(test1)):
model = sm.tsa.arima.ARIMA(history, order=(8, 1, 8))
model_fit = model.fit()
output = model_fit.forecast()
yhat = output[0]
predictions.append(yhat)
obs = test1[t]
history.append(obs)
#打印 test 和 prediction 的误差
error = mean_squared_error(test, predictions)
print(&#39;Test MSE: %.3f&#39; % error)
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2884f522eca04d32a3c016a8d5ca77f2.png"></p>
<h2 id="4-7数据可视化"><a href="#4-7数据可视化" class="headerlink" title="4.7数据可视化"></a>4.7数据可视化</h2><pre><code># 画图查看结果
from matplotlib import pyplot
pyplot.figure(figsize=(12,6))
pyplot.plot(test,color=&#39;blue&#39;,label=&quot;实际值&quot;)
pyplot.plot(predictions, color=&#39;red&#39;,label=&quot;预测值&quot;)
pyplot.xlabel(&#39;time&#39;)
pyplot.ylabel(&#39;靠港数&#39;)
pyplot.legend()
pyplot.show()
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/c3289c4856f84523bb56e13c4639ef04.png"></p>
<h1 id="5-结论与展望"><a href="#5-结论与展望" class="headerlink" title="5.结论与展望"></a>5.结论与展望</h1><p>在 2020 年初，新型冠状动脉肺炎大规模爆发。仅在 2020 年 3 月底，新冠肺炎就横扫了213 个国家和地区，在全世界造成 223 万人感染，超过 10 万人死亡。许多国家已经宣布“紧急状态”。由于疫情爆发时许多国家施加的限制和严格控制，国际贸易下降，对国际运输的需求也下降。因此，在冠状肺炎的全球大规模流行的情况下，航运企业将需要对当前环境进行透彻的分析，积极应对并向前迈进。疫情直接导致需求先降后升，而整个物流供应链的成本增加了，伴随着增加了额外的运输和劳动力成本，加上由于大量集装箱船舶长期闲置搁浅，短期内国内外集装箱船舶的运力过剩，还是给航运企业经营带来较大困难。<br>中国出口集装箱运价指数的变动因素可以给疫情下的各大航运企业提供又一条应对思路。通过透彻分析各个港口拥堵程度，燃油价格以及运力指数对集装箱运价之间的关系，航运企业与当地政府之间相互配合下，一定能共渡难关。尽管我国的新冠状肺炎流行已得到基本控制，但要实现有效的全球控制尚需时日。因此，航运企业还应积极解决锁定问题，提高防疫意识，及时了解疫情的演变，并采取多种措施，确保职工在疫情中的稳定性和安全性，克服困难并做出快速响应。</p>
<h1 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6.参考文献"></a>6.参考文献</h1><p>[1]王婧妍.浅析新冠疫情的世界性爆发对航运业的影响[J].珠江水运， 2020， 05:82-83.<br>[2].刘娜.大连外贸集装箱运价指数编制研究[D].大连:大连海事大学,2007.<br>[3].王辉.交通运输应对新冠肺炎疫情之策[J].交通运输研究， 2020， 6(01):1.<br>[4].周国光.新冠肺炎疫情防控对交通运输行业的影响及其对策研究[J].交通财会,2020,3:4-7.161616</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/07/17/%E7%96%AB%E6%83%85%E6%B8%AF%E5%8F%A3%E6%8C%82%E9%9D%A0%E6%95%B0ARIMA%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/" data-id="cl8wvrz9t002tkktaewwn6xvz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-OGNL表达式改造以使用索引" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/15/OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%B9%E9%80%A0%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/" class="article-date">
  <time datetime="2022-07-15T14:27:54.000Z" itemprop="datePublished">2022-07-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/15/OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%B9%E9%80%A0%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/">OGNL表达式改造以使用索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一般在Mybatis中用#{}来防止sql注入，但是这种预编译的模式会导致无法调用java的方法，因此在<strong>系统安全性较高的情况下，或绑定的类型不是String</strong>时可以尝试使用${}来调用java方法进行数据处理</p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>一个表中关于时间有两个字段</p>
<ul>
<li><p>create_date是datetime类型<br>create_time是时间戳类型，但时间戳是13位的long型，这里是11位的int类型(int最大十进制长度)</p>
</li>
<li><p>前者没有索引，后者有索引（优势：字段短，索引更快，int比long占内存更小）</p>
</li>
<li><p>前者是给DBA看的，后者用于查询</p>
</li>
</ul>
<h1 id="使用OGNL表达式"><a href="#使用OGNL表达式" class="headerlink" title="使用OGNL表达式"></a>使用OGNL表达式</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/huayu815/article/details/7446141">OGNL表达式参考</a></p>
<pre><code>  &lt;select id=&quot;mapper方法名&quot; resultType=&quot;Res对象&quot;&gt;
    SELECT source, SUM(IF(type = 0, -amount, amount))
    FROM 表
    WHERE create_time &lt;![CDATA[ &lt;  ]]&gt; $&#123;endDateTime.toInstant(@java.time.ZoneOffset@of(&quot;+8&quot;)).toEpochMilli()/1000&#125;
      AND create_time &lt;![CDATA[ &gt;= ]]&gt; $&#123;startDateTime.toInstant(@java.time.ZoneOffset@of(&quot;+8&quot;)).toEpochMilli()/1000&#125;
    GROUP BY source

  &lt;/select&gt;
</code></pre>
<p>注：调静态方法时，类和方法都要加@；<br> /1000是为了让本身为long型的13位时间戳变成11位的int以便SELECT，<strong>且本身不是函数，不会导致索引失效</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/07/15/OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%B9%E9%80%A0%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/" data-id="cl8wvrz8z000ukktafe7r1l79" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mvcc+按天缓存统计两个收益" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/15/mvcc+%E6%8C%89%E5%A4%A9%E7%BC%93%E5%AD%98%E7%BB%9F%E8%AE%A1%E4%B8%A4%E4%B8%AA%E6%94%B6%E7%9B%8A/" class="article-date">
  <time datetime="2022-07-15T13:35:25.000Z" itemprop="datePublished">2022-07-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/15/mvcc+%E6%8C%89%E5%A4%A9%E7%BC%93%E5%AD%98%E7%BB%9F%E8%AE%A1%E4%B8%A4%E4%B8%AA%E6%94%B6%E7%9B%8A/">mvcc+按天缓存统计两个收益</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是上一段电商实习时做的一个需求，也是我第一次实习时思考最多的一个需求，场景如下：</p>
<h1 id="1-场景"><a href="#1-场景" class="headerlink" title="1.场景"></a>1.场景</h1><p>用户实时收益表：存在虚拟收益、现金收益的<strong>当前值</strong><br>用户收益记录表：存在虚拟收益、现金收益的<strong>记录值</strong></p>
<p>要求：统计截止某天00:00时，用户的虚拟收益和现金收益</p>
<p>很显然，可以直接用 实时表的数据 减去 记录表的数据的总和</p>
<p>但是电商业务数据量很大，每次请求简单的都去查两次库然后相减合适吗？不合适。</p>
<h1 id="2-幂等方案设计——缓存"><a href="#2-幂等方案设计——缓存" class="headerlink" title="2.幂等方案设计——缓存"></a>2.幂等方案设计——缓存</h1><p>既然这个需求是“截止某天”，今天的“截止2号”和明天的“截止2号”查询的结果应该是幂等的，因此可以考虑在这个功能上添加缓存</p>
<p>但是这个缓存如何去加？直接加到xx天对应的数据存一个map？？很显然不合适，比如今天是7月15号，我连续查了7月1号~~7月14号的数据，<code>发现每次请求都花了我十几秒的时间</code>，<strong>因为这时候没有缓存，我查一下都会从完整的库中进行<code>SUM()</code></strong>,而在数据量大的情况下，SUM函数是特别耗费时间的，因此需要修改方案</p>
<h1 id="3-按天加缓存"><a href="#3-按天加缓存" class="headerlink" title="3.按天加缓存"></a>3.按天加缓存</h1><p>既然我们有两张表：实时、记录<br>那我们可以使用“记录表”，来统计<strong>7月1号00:00 到24:00的统计数据</strong><br>举个例子：</p>
<ul>
<li>我要查询“截止7月3号00:00的统计情况”</li>
<li>实时表：查询当前7月15号21:53:000的收益</li>
<li>记录表：<strong>依次通过SUM函数统计</strong> </br><br>7月3号00:00到7月3号24:00的收益统计</br><br>7月4号00:00到7月4号24:00的收益统计</br><br>7月5号00:00到7月5号24:00的收益统计</br><br>…..</br><br>7月14号00:00到7月14号24:00的收益统计</br></li>
<li><em><code>并加添加缓存</code>，这时的缓存是幂等的、连续的</em>*</li>
<li>然后用当前的收益 <code>连续地减去</code> 这12天的，<code>12条缓存数据</code>，再减去用SUM函数统计的今天的那部分数据（<code>今天还没过完，所以不能加缓存</code>）</li>
</ul>
<p>然后我再想查询“截止7月2号00:00的统计情况” “截止7月1号00:00的统计情况” ，我们就只有一两天的数据走MySQL，其他的所有统计数据都走的缓存，这一次我们调用接口花费了不到1秒种</p>
<h1 id="4-按天缓存解决的问题"><a href="#4-按天缓存解决的问题" class="headerlink" title="4.按天缓存解决的问题"></a>4.按天缓存解决的问题</h1><p>大大减少连续了<strong>查询紧挨着的</strong>几天所耗费的时间，也减少了对MySQL的性能消耗</p>
<p>但也出现的新的问题，我们不能简单的使用“当前收益”去<code>连续减去</code>“多天多条的缓存收益数据”。因为可能出现：获取“当前收益后”，此时<code>对于今天的记录数据变了</code>，今天的那部分走MySQL查询的记录数据变了，即使是过往的缓存正确，此时的数据也不正确了</p>
<h1 id="5-“今天数据”的一致性问题"><a href="#5-“今天数据”的一致性问题" class="headerlink" title="5.“今天数据”的一致性问题"></a>5.“今天数据”的一致性问题</h1><p>以前那些天数的缓存肯定是没问题的，是幂等的。问题就是出在“如何保证在不加锁的情况下实现<code>今天这部分数据的</code>一致性”</p>
<h2 id="5-1时间戳方案（pass）"><a href="#5-1时间戳方案（pass）" class="headerlink" title="5.1时间戳方案（pass）"></a>5.1时间戳方案（pass）</h2><ul>
<li>查询“实时表”后马上获取一个时间戳，带着这个时间戳去“记录表”查这之前的</li>
<li>Java的时间戳和MySQL时间戳不一致，因此时间戳需要从MySQL中查询</li>
</ul>
<p>不过这种方案虽然减少了不一致性的发生，但是也没有完全避免，并且两次查MySQL永远比只查一次更慢</p>
<h2 id="5-2利用UNION依托mvcc实现一致性"><a href="#5-2利用UNION依托mvcc实现一致性" class="headerlink" title="5.2利用UNION依托mvcc实现一致性"></a>5.2利用UNION依托mvcc实现一致性</h2><pre><code>SELECT
SUM( profit_balance ) AS 今天的现金收益总和,
SUM( profit_fictitious_balance ) AS 今天的虚拟收益总和 ,
0 AS 今天的待减现金收益,
0 AS 今天的待减虚拟收益
FROM
实时收益表


UNION ALL


SELECT 
0 AS 今天的现金收益总和,
0 AS 今天的虚拟收益总和,
SUM(IF(type=1,profit_balance,-profit_balance)) AS 今天的待减现金收益,
SUM(IF(type=1,amount,-amount)) AS 今天的待减虚拟收益
FROM
收益记录表
</code></pre>
<p>然后这样就可以用一个Dto来装数据，这条SQL语句一共会产生两行，大概长这样</p>
<table>
<thead>
<tr>
<th>今天的现金收益总和</th>
<th>今天的虚拟收益总和</th>
<th>今天的待减现金收益</th>
<th>今天的待减虚拟收益</th>
</tr>
</thead>
<tbody><tr>
<td>9000</td>
<td>8000</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1000</td>
<td>2000</td>
</tr>
</tbody></table>
<p>Mybatis对应会生成size=2的一个List，处理一下就得到了今天的数据了</p>
<h3 id="5-2-1不加锁一致性的实现机制"><a href="#5-2-1不加锁一致性的实现机制" class="headerlink" title="5.2.1不加锁一致性的实现机制"></a>5.2.1不加锁一致性的实现机制</h3><ul>
<li>因为是用UNION，所以这个数据一定是一致的</li>
<li>因为是RC（read comitted）级别，RC级别下是有MVCC（多版本并发控制）机制的，所以在SELECT的时候不会加锁，也不会受到当前其他现成读写操作的影响</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/07/15/mvcc+%E6%8C%89%E5%A4%A9%E7%BC%93%E5%AD%98%E7%BB%9F%E8%AE%A1%E4%B8%A4%E4%B8%AA%E6%94%B6%E7%9B%8A/" data-id="cl8wvrz9e001ikktah79t9d5r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-压缩打包但不归档，利用response" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/15/%E5%8E%8B%E7%BC%A9%E6%89%93%E5%8C%85%E4%BD%86%E4%B8%8D%E5%BD%92%E6%A1%A3%EF%BC%8C%E5%88%A9%E7%94%A8response/" class="article-date">
  <time datetime="2022-07-15T13:26:51.000Z" itemprop="datePublished">2022-07-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/15/%E5%8E%8B%E7%BC%A9%E6%89%93%E5%8C%85%E4%BD%86%E4%B8%8D%E5%BD%92%E6%A1%A3%EF%BC%8C%E5%88%A9%E7%94%A8response/">压缩打包但不归档，利用response</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>把图片按自定义的层级关系及名称压缩打包，但不放入服务器<br>我的其他文章里有关于这个问题解决方案的小demo</p>
<h1 id="1-场景"><a href="#1-场景" class="headerlink" title="1.场景"></a>1.场景</h1><p>业务场景：学生提交作品中有很多图片，需要分层级按：活动名》班级》姓名》作品名》作品图片集合  压缩打包，并且<strong>因为这个作品是时常变化的，所以不能把压缩包放到服务器上</strong></p>
<p>要求：请求接口之后把压缩包发来，不准存服务器然后发url</p>
<h1 id="2-最终解决方案"><a href="#2-最终解决方案" class="headerlink" title="2.最终解决方案"></a>2.最终解决方案</h1><ul>
<li>把最终的zip流输出到response.getOutPutStream()中</li>
<li>在输出之前，先要设置请求头 <code>response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + URLEncoder.encode(activityName) + &quot;.zip&quot;)</code>; ————<strong>用于指定最终输出的zip压缩包的名字</strong>，这个<code>URLEncoder.encode()</code>十分重要，否则中文会乱码</li>
<li>公司内部框架直接获取图片的byte[] ，遍历写入<code>》》</code>缓冲流write() <code>《《</code> 压缩流<code> 《《</code> response.getOutPutStream()</li>
<li>SQL查询出来年级、班级、姓名、作品名字、图片url ， 然后putZipEntry(new Entry(<code>用//来分层级</code>))</li>
<li><strong>业务方面：有的学校的班级是中文，因此必须CONCAT拼接。而为了保证最终文件可排序，因此不用”一年级“ 而用 ”1年级“</strong>  形如：new ZipEntry(“活动测试//1年级1班//张三-开心假期”)</li>
</ul>
<br/>

<h1 id="3-浏览器适配问题"><a href="#3-浏览器适配问题" class="headerlink" title="3.浏览器适配问题"></a>3.浏览器适配问题</h1><br/>

<ul>
<li>该方案设置请求头.setHeader(“Content-Disposition”, “attachment; filename=” +）直接<strong>强制在文件的末尾加上zip，可以防止因为不同浏览器无法解析ContentType导致的文件格式错误</strong>（google可以不指定）</li>
<li>尝试给edge浏览器做适配，发现除了上面的方法，没有其他方法可以设置文件格式</li>
<li>测试后，无论什么浏览器，压缩包末尾强制 .zip 文件接收后可以直接打开<br><img src="https://img-blog.csdnimg.cn/0e2118dc06b945bca75963d954a89489.png"></li>
</ul>
<h1 id="4-可优化的点"><a href="#4-可优化的点" class="headerlink" title="4.可优化的点"></a>4.可优化的点</h1><p>时间紧来不及学NIO，计划等最近的业务忙完了学学NIO，做一个demo，然后把这个业务优化一下 T_T</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/07/15/%E5%8E%8B%E7%BC%A9%E6%89%93%E5%8C%85%E4%BD%86%E4%B8%8D%E5%BD%92%E6%A1%A3%EF%BC%8C%E5%88%A9%E7%94%A8response/" data-id="cl8wvrz9l0025kktaf4p48m9s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-业务中delete_flag字段容易踩的坑" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/15/%E4%B8%9A%E5%8A%A1%E4%B8%ADdelete_flag%E5%AD%97%E6%AE%B5%E5%AE%B9%E6%98%93%E8%B8%A9%E7%9A%84%E5%9D%91/" class="article-date">
  <time datetime="2022-07-15T13:19:19.000Z" itemprop="datePublished">2022-07-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/15/%E4%B8%9A%E5%8A%A1%E4%B8%ADdelete_flag%E5%AD%97%E6%AE%B5%E5%AE%B9%E6%98%93%E8%B8%A9%E7%9A%84%E5%9D%91/">业务中delete_flag字段容易踩的坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是我实习期间改的最有意思的一个bug，所以记录一下，产生bug的原因如下三点，我按顺序写</p>
<ol>
<li>因为SQL缺少了很多个<code>delete_flag = 1</code>条件导致统计值膨胀，我<strong>利用IDEA的搜索可以计数</strong> 与 <strong>delete_flag字段与where、join on条件的数量关系</strong>进行了修改、核对</li>
<li>修改完之后测试说还有2个地方有问题。通过分析提交记录定位到了<code>LEFT JOIN</code>可能出了问题，然后<strong>发现了Mysql执行引擎的外联表on条件对驱动表筛选无效</strong>的问题</li>
<li>以上两个bug修改了之后，第二天测发现数据叕巨量膨胀了(比上次还多..)，<strong>联想到晚上在食堂吃饭听到leader打电话说有人在做压测</strong>，然后一查果然是凭空多了几万条数据，删掉之后一切正常</li>
</ol>
<h1 id="0-先说总结"><a href="#0-先说总结" class="headerlink" title="0.先说总结"></a>0.先说总结</h1><h2 id="0-1SQL规范"><a href="#0-1SQL规范" class="headerlink" title="0.1SQL规范"></a>0.1SQL规范</h2><ul>
<li>delete_flag字段属于是表设计的规范，无论做没做删除功能都要在SQL中加上，但是加错了地方会出问题</li>
<li>对于<strong>驱动表</strong>，<code>delete_flag=1</code>应该放在最后面的<code>where</code>之后，防止外联<code>on</code>条件筛选时失效</li>
<li>每联一张表（<strong>非驱动表</strong>）都需要在紧跟着的<code>on</code>后面添加<code>该表的.delete_flag=1</code>，而不能放在最后的<code>where</code>后（能生效但不规范）</li>
</ul>
<h2 id="0-2数量关系"><a href="#0-2数量关系" class="headerlink" title="0.2数量关系"></a>0.2数量关系</h2><ul>
<li><code>delete_flag=1</code> 与 <code>where</code> 、 <code>on</code>之间存在如下数量关系，这也是我进行核对数量时用的技巧：<code>delete_flag  =  where + join</code></li>
<li>（<strong>至于为什么是join而不是on，是因为如果以前的代码只join了而没有on，按这个公式核对数量就会出错</strong>）</li>
</ul>
<h2 id="0-3一个规范的示例"><a href="#0-3一个规范的示例" class="headerlink" title="0.3一个规范的示例"></a>0.3一个规范的示例</h2><pre><code>SELECT
    xxx,yyy,zzz
FROM
    A
     LEFT JOIN B ON B.delete_falg = 1 #紧跟在ON后面
    RIGHT JOIN C ON C.delete_fale = 1
          JOIN D ON D.delete_flag = 1 
WHERE
    A.delete_falge = 1 # WHERE只筛选驱动表
</code></pre>
<h1 id="1-缺失的delete-flag字段"><a href="#1-缺失的delete-flag字段" class="headerlink" title="1.缺失的delete_flag字段"></a>1.缺失的delete_flag字段</h1><h2 id="1-1场景"><a href="#1-1场景" class="headerlink" title="1.1场景"></a>1.1场景</h2><ul>
<li>一共两个mapper有一百多条sql，<code>delete_flag=1</code>的条件有的加了有的没加，<strong>有的加在where后面有的加在on后面</strong>，导致查询出来的结果会产生笛卡尔积，也很去定位</li>
<li>由于最开始的业务没有做“删除”功能，导致这么长时间数据一直没有出错也没测出问题。。</li>
</ul>
<h2 id="1-2解决方法"><a href="#1-2解决方法" class="headerlink" title="1.2解决方法"></a>1.2解决方法</h2><p>先思考再动手，理清楚SELECT FROM JOIN WHERE之间的数量关系</p>
<ul>
<li><p>每次JOIN<strong>关联表</strong>必须带delete_flag = 1，WHERE中本应只写一个<strong>原表</strong>的delete_flag = 1 <img src="https://img-blog.csdnimg.cn/1776a41b5ada4e9a90c798096be771cd.png"></p>
</li>
<li><p>先<code>ctrl + F 高亮</code>，<code>alt + J 框选</code>，<strong>让JOIN更明显</strong>，挨个在JOIN之后加delete_flag = 1</p>
</li>
<li><p><strong>加完之后一定存在冗余</strong>，搜索每个WHERE条件，所以在WHERE条件下，<strong>一旦找到两个</strong>delete_flag = 1 <strong>那么一定有多余的</strong><img src="https://img-blog.csdnimg.cn/593eb16d4fc94b859e835bcb42caa367.png"></p>
</li>
<li><p>最后核对数量  ctrl + F 搜索数量  <code>JOIN + WHERE = delete_flag</code> </br><br>54 + 16 = 70 另一个个mapper的解决方法同理</p>
</li>
</ul>
<h1 id="2-外联表导致的on失效"><a href="#2-外联表导致的on失效" class="headerlink" title="2.外联表导致的on失效"></a>2.外联表导致的on失效</h1><h2 id="2-1场景"><a href="#2-1场景" class="headerlink" title="2.1场景"></a>2.1场景</h2><ul>
<li>当我改完了上述delete_flag，也核对数量之后我以为没问题了，没想到测试说还有两个还是有问题，我根据接口定位到了这两条SQL，发现他们在联表时都用了<code>LEFT JOIN...ON</code></li>
<li>然后我看提交记录，这两条<code>LEFT JOIN</code>的时间在其他提交记录之后好几个月，我就想问题应该就是这里了</li>
<li>而刚好在这个<code>LEFT JOIN ... ON</code>之后对<strong>驱动表的delete_flag</strong>字段进行了筛选</li>
</ul>
<h2 id="2-2解决方法"><a href="#2-2解决方法" class="headerlink" title="2.2解决方法"></a>2.2解决方法</h2><ul>
<li>一开始确实没有思路，直到我把<code>LEFT JOIN ON</code>后面的驱动表筛选delete_flag放到了<code>WHERE</code>之后，尝试了一下就好了</li>
<li>盲猜这两条左连接查询<strong>提交日期不同</strong>可能就是因为这里</li>
<li>然后我去吃饭了，碰巧在食堂听到leader打电话说关于压测的问题也帮我解决了最终的bug。。。</li>
</ul>
<h2 id="2-3查阅资料小结"><a href="#2-3查阅资料小结" class="headerlink" title="2.3查阅资料小结"></a>2.3查阅资料小结</h2><p>Mysql的执行引擎对于：</p>
<ul>
<li>内连接JOIN：<code>SELECT xx FROM A JOIN B ON...WHERE</code>可以在ON后<strong>对驱动表A进行筛选</strong></li>
<li>而外连接LEFT RIGHT JOIN：对驱动表A筛选无效</li>
</ul>
<h1 id="3-压测导致的脏数据"><a href="#3-压测导致的脏数据" class="headerlink" title="3.压测导致的脏数据"></a>3.压测导致的脏数据</h1><h2 id="3-1场景"><a href="#3-1场景" class="headerlink" title="3.1场景"></a>3.1场景</h2><ul>
<li>第二天测试告诉我<strong>整个小模块数据全出问题了</strong>，但是我一想昨天改完了就剩下两个，其他都是好的啊，为啥今天突然其他的数据也突然多出来这么多，按理说我改的地方没问题。</li>
</ul>
<h2 id="3-1解决方法"><a href="#3-1解决方法" class="headerlink" title="3.1解决方法"></a>3.1解决方法</h2><ul>
<li>我直接在测试库写SQL，看了下日期是7月15号下午5点，联想到当时吃饭时听到leader打电话说了个谁谁谁在压测。</li>
<li>最后删掉了这6W多条数据，一切正常。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/07/15/%E4%B8%9A%E5%8A%A1%E4%B8%ADdelete_flag%E5%AD%97%E6%AE%B5%E5%AE%B9%E6%98%93%E8%B8%A9%E7%9A%84%E5%9D%91/" data-id="cl8wvrz9g001qkktahejy3agd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-非时序排序下的瀑布流分页" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/15/%E9%9D%9E%E6%97%B6%E5%BA%8F%E6%8E%92%E5%BA%8F%E4%B8%8B%E7%9A%84%E7%80%91%E5%B8%83%E6%B5%81%E5%88%86%E9%A1%B5/" class="article-date">
  <time datetime="2022-07-15T13:15:15.000Z" itemprop="datePublished">2022-07-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/15/%E9%9D%9E%E6%97%B6%E5%BA%8F%E6%8E%92%E5%BA%8F%E4%B8%8B%E7%9A%84%E7%80%91%E5%B8%83%E6%B5%81%E5%88%86%E9%A1%B5/">非时序排序下的瀑布流分页</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>设计非时序相关的排序功能。这个需求是对原有接口进行改造，在写思路的时候证明了原来逻辑有严重漏洞</p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><p>分页查询很常见，在web网页端的分页，和移动端手机下滑的分页逻辑一般都不同</p>
<ul>
<li>web端是常规的是<strong>指定页码数</strong>使用`limit #{start} , #{end}</li>
<li>移动端一般不会指定页码数，而是<strong>根据上一次的最后一个id作为fromId（主键）</strong>，先WHERE xxxid &gt; fromId 然后limit #{size} <strong>这样既符合手机下滑业务场景，也避免了页码过大查询速度降低的问题</strong></li>
</ul>
<h1 id="2-移动端可能存在的问题"><a href="#2-移动端可能存在的问题" class="headerlink" title="2.移动端可能存在的问题"></a>2.移动端可能存在的问题</h1><ul>
<li>如果我们是按时间排序，那么这套逻辑毫无问题！但是如果我们按班级排序（非时序）：</li>
<li>如果按班级<strong>升序</strong>每次我们查3条数据（<strong>limit 3</strong> ），在<strong>如下表的作品<code>提交</code>顺序</strong>，可能出现的情况是:</li>
</ul>
<table>
<thead>
<tr>
<th>班级</th>
<th>作品id（fromId）（主键）</th>
</tr>
</thead>
<tbody><tr>
<td>1班</td>
<td>4 5 7 ， 8 9 10</td>
</tr>
<tr>
<td>2班</td>
<td>1号作品 2号  3号 ，6 12 13</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>第n次下拉手机屏幕</th>
<th>作品id（fromId）（主键）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>7 （取出1班的4 5 7号作品）</td>
</tr>
<tr>
<td>2</td>
<td>10 （取出1班的8 9 10号作品）</td>
</tr>
<tr>
<td>3</td>
<td>12 13（<code>因为fromId &gt; 10，所以前面1 2 3 6数据丢失了</code>）</td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdnimg.cn/7fd67321bb1b4fe4aaa3002ee92d00c9.png"></p>
<p>我造的这个数据，无论是升序  还是降序，都会导致数据丢失，因此可以得出结论:</p>
<h1 id="3-结论"><a href="#3-结论" class="headerlink" title="3.结论"></a>3.结论</h1><p>像班级  年级   等等等 所有的 <strong><code>自增主键和排序依据不是时间线性相关</code>的，都不能使用fromId作为排序依据</strong></p>
<h1 id="4-补充：：其他业务上的问题"><a href="#4-补充：：其他业务上的问题" class="headerlink" title="4.补充：：其他业务上的问题"></a>4.补充：：其他业务上的问题</h1><h2 id="4-1可能出现的中文排序"><a href="#4-1可能出现的中文排序" class="headerlink" title="4.1可能出现的中文排序"></a>4.1可能出现的中文排序</h2><p>班级字段是VARCHAR，有的学校的班级是中文，因此需要用 <code>正则 + CONCAT拼接</code></p>
<pre><code>   ORDER BY cg.`grade_no` DESC ,  --grade_no是INTEGER类型
    CASE                         --class_no是VARCHAR类型，需要用正则匹配
    WHEN cc.`class_no` REGEXP &#39;^[0-9]+$&#39; THEN CONVERT(cc.`class_no`,UNSIGNED INTEGER)
    ELSE cc.`class_no` END
    ASC;
</code></pre>
<h2 id="4-2pass掉的fromId拼接排序方案"><a href="#4-2pass掉的fromId拼接排序方案" class="headerlink" title="4.2pass掉的fromId拼接排序方案"></a>4.2pass掉的fromId拼接排序方案</h2><p><code>SELECT CONCAT(grade_no , class_no , 作品id) ..........ORDER BY CONCAT(grade_no , class_no , 作品id) </code>这个作品id就是fromId，如果把这个fromId拼在后面，理论上可以实现无遗漏排序，但是</p>
<ul>
<li>考虑到grade_no 和 class_no被拼接为字符串后比较 ， 2&gt;11 导致乱序，必须扩充补0；</li>
<li>考虑到有的班级是中文，更不容易确定这个补0到底补几个</li>
<li>无法预知未来是否会对按班级排序加索引</li>
</ul>
<h2 id="4-3pass掉的rownum方案"><a href="#4-3pass掉的rownum方案" class="headerlink" title="4.3pass掉的rownum方案"></a>4.3pass掉的rownum方案</h2><p>以上的“拼接方案”被pass了，那么是否可以自己实现一个Oracle的<code>rownum</code>来保存当前的行号呢？<br>可行，但是涉及子查询 、存储变量 ，很麻烦，效率低，大概长这样</p>
<pre><code>set @rownum=0;

SELECT

    @rownum:=@rownum+1 AS rownum
</code></pre>
<h2 id="4-4耦合业务"><a href="#4-4耦合业务" class="headerlink" title="4.4耦合业务"></a>4.4耦合业务</h2><ul>
<li>这个service层经过很多次的改动，有些改动后没有改注释，有的地方没注释，包括了管理员鉴权、班主任鉴权、创建者鉴权等等耦合业务，还包括了另一个模块的按投票排序功能</li>
<li>个人认为既然逻辑不同，就应该把web端和移动端的业务完全隔离，互不影响，投票排序也可以单拎出去，没有必要为了复用而复用，为了减少代码量而减少代码量。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/6c92d5451c724003acb19ec5b1cd8bab.png"></p>
<h1 id="5-最终解决方案（更改字段含义）"><a href="#5-最终解决方案（更改字段含义）" class="headerlink" title="5.最终解决方案（更改字段含义）"></a>5.最终解决方案（更改字段含义）</h1><ul>
<li>移动端利用原有的type区分到“按班级排序”时，将fromId字段含义改为“xx页”————页码数</li>
<li>这样不影响其他的业务，也能够正确的查询出数据，只是在极端情况下页码数过大时会稍慢（几乎不考虑）</li>
<li>修改fromId的含义，只需要详细的在前后端代码的注释中体现即可</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/07/15/%E9%9D%9E%E6%97%B6%E5%BA%8F%E6%8E%92%E5%BA%8F%E4%B8%8B%E7%9A%84%E7%80%91%E5%B8%83%E6%B5%81%E5%88%86%E9%A1%B5/" data-id="cl8wvrz9v002zkkta81dm9w9r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-行程编码压缩图片" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/25/%E8%A1%8C%E7%A8%8B%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/" class="article-date">
  <time datetime="2022-06-24T17:35:20.000Z" itemprop="datePublished">2022-06-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/">数据结构算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/25/%E8%A1%8C%E7%A8%8B%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/">行程编码压缩图片</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因为图片的连续像素点灰度值与色值一般都有很长的相同，例如这是一张图的部分byte[]<img src="https://img-blog.csdnimg.cn/f16b3f6b259245899a054f0cbd7096b5.png"></p>
<p>因此可以将byte[] 压缩为 <code>值1*行程长度1#值2*行程长度2#</code>的格式，这种压缩算法在证件照、白底画等有大面积连续颜色区域的时候效果很好；而在每个相邻像素点都不同颜色or灰度值的情况下压缩后反而更大</p>
<h1 id="1-压缩rleEncoder"><a href="#1-压缩rleEncoder" class="headerlink" title="1.压缩rleEncoder"></a>1.压缩rleEncoder</h1><pre><code>public static String rleEncoder(byte[] src)&#123;
    //初始化，存入第一个元素
    StringBuffer stringBuffer = new StringBuffer(src[0] + &quot;*&quot;);
    //遍历 从第二个元素开始
    int count = 1;
    for(int i = 1 ; i &lt; src.length ; i++)&#123;
        //如果跟上一个元素相同
        if(src[i] != src[i-1]) &#123;
            stringBuffer.append(count);
            stringBuffer.append(&quot;#&quot;);//结束标志
            stringBuffer.append(src[i]);
            stringBuffer.append(&quot;*&quot;);
            count = 1;//计数器归位
        &#125;else&#123;
            //相同元素计数器+1
            count++;
        &#125;
    &#125;
    stringBuffer.append(count);
    stringBuffer.append(&quot;#&quot;);
    return stringBuffer.toString();
&#125;
</code></pre>
<h1 id="2-解压rleDecoder"><a href="#2-解压rleDecoder" class="headerlink" title="2.解压rleDecoder"></a>2.解压rleDecoder</h1><pre><code>    public static byte[] rleDecoder(String src)&#123;
//此时的src是形如0*2#11*1#2*1#3*1#4*1#55*5#的字符串
        String s = src.replaceAll(&quot;\\#&quot;, &quot;*&quot;);//方便分割
        String[] split = s.split(&quot;\\*&quot;);
        ArrayList&lt;Byte&gt; list = new ArrayList&lt;Byte&gt;();
        Byte tempValue = 0;
        int tempNumber = 0;
        //偶数索引是值  奇数索引是数量
        for(int i = 0 ; i &lt; split.length ; i++)&#123;
            //偶数是值
            if((i&amp;1) == 0)&#123;
                tempValue = Byte.parseByte(split[i]);
            //奇数是数量
            &#125;else&#123;
                tempNumber = Integer.parseInt(split[i]);
                //确定值和数量之后for循环
                for(int j = 0 ; j &lt; tempNumber ; j++)&#123;
                    list.add(tempValue);
                &#125;
            &#125;
        &#125;
        byte[] bytes = new byte[list.size()];
        for(int i = 0 ; i &lt; list.size() ; i++)&#123;
            bytes[i] = list.get(i);
        &#125;
        return bytes;
    &#125;
</code></pre>
<h1 id="3-演示"><a href="#3-演示" class="headerlink" title="3.演示"></a>3.演示</h1><pre><code>   String dest = rleEncoder(new byte[]&#123;0,0,0,0,0,0,0,0,0,0,0,0,0,
            6,6,6,6,6,6,6,6,6,6,6,6,8,
            8,8,8,8,8,8,8,8,8,8,8,8,8,8&#125;);
    byte[] bytes = rleDecoder(dest);
    System.out.println(new String(bytes));
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/c934270a7b81429581c175c5af1f701f.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/06/25/%E8%A1%8C%E7%A8%8B%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/" data-id="cl8wvrz9t002vkkta98c019xt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Filter的常见用法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/21/Filter%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/" class="article-date">
  <time datetime="2022-04-21T01:51:40.000Z" itemprop="datePublished">2022-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/21/Filter%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/">Filter的常见用法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Filter 是 JavaEE 中 Servlet 规范的一个组件，位于包javax.servlet 中，它可以在 HTTP 请求到达 Servlet 之前，被一个或多个Filter处理。<br><img src="https://img-blog.csdnimg.cn/493d90f7f4ef457f85942c455a2c75fa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAempoYmxvZw==,size_19,color_FFFFFF,t_70,g_se,x_16"></p>
<h1 id="1-案例结构"><a href="#1-案例结构" class="headerlink" title="1.案例结构"></a>1.案例结构</h1><h2 id="1-1first拦截器"><a href="#1-1first拦截器" class="headerlink" title="1.1first拦截器"></a>1.1first拦截器</h2><pre><code>@WebFilter(filterName = &quot;first&quot; , urlPatterns = &quot;/*&quot;)
@Order(1)
public class FirstFilter implements Filter &#123;


  @Override
  public void init(FilterConfig filterConfig) throws ServletException &#123;
    Filter.super.init(filterConfig);
    System.out.println(&quot;first拦截器初始化&quot;);
  &#125;

  @Override
  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;

    HttpServletRequest req = (HttpServletRequest) servletRequest;
    System.out.println(&quot;first拦截器获取Attribute&quot;+req.getAttribute(&quot;name&quot;));//无

    req.setAttribute(&quot;name&quot;,&quot;第一次设置的name&quot;);//作用范围为：一次请求域，即下次Filter也能取的到

    HttpServletResponse res = (HttpServletResponse) servletResponse;
    res.setHeader(&quot;firstHeader&quot;,&quot;firstHeader&quot;);//设置请求头，会一直层层传递到控制层的响应头

    filterChain.doFilter(req,res);//按Order优先顺序调用下一个Filter，直到Controller层

    System.out.println(&quot;firstFilterEnd&quot;);//doFilter内部执行完毕之后，才回来执行这个，类似二叉树的前序遍历

  &#125;

  @Override
  public void destroy() &#123;
    Filter.super.destroy();
    System.out.println(&quot;first拦截器销毁&quot;);
  &#125;
&#125;
</code></pre>
<h2 id="1-2second拦截器"><a href="#1-2second拦截器" class="headerlink" title="1.2second拦截器"></a>1.2second拦截器</h2><pre><code>@WebFilter(urlPatterns = &quot;/*&quot;)
@Order(2)
public class SecondFilter implements Filter &#123;


  @Override
  public void init(FilterConfig filterConfig) throws ServletException &#123;
    Filter.super.init(filterConfig);
    System.out.println(&quot;second拦截器初始化&quot;);
  &#125;

  @Override
  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;

    HttpServletRequest req = (HttpServletRequest) servletRequest;
    System.out.println(&quot;second拦截器获取Attribute&quot;+req.getAttribute(&quot;name&quot;));//第一次设置的name

    req.setAttribute(&quot;name&quot;,&quot;第二次设置的name&quot;);
    HttpServletResponse res = (HttpServletResponse) servletResponse;
    res.setHeader(&quot;secondHeader&quot;,&quot;secondeHeader&quot;);

    filterChain.doFilter(req,res);//后续没有Filter，调用Controller

    System.out.println(&quot;secondFilterEnd&quot;);

  &#125;

  @Override
  public void destroy() &#123;
    Filter.super.destroy();
    System.out.println(&quot;second拦截器销毁&quot;);
  &#125;
&#125;
</code></pre>
<h2 id="1-3控制层"><a href="#1-3控制层" class="headerlink" title="1.3控制层"></a>1.3控制层</h2><pre><code>  @PostMapping(&quot;/web&quot;)
  public DtoRes webTest(HttpServletRequest request  ,  HttpServletResponse response ,@RequestParam(&quot;userName&quot;) String userName) throws IOException &#123;

    System.out.println(&quot;controller&quot;);


    return null;

  &#125;
</code></pre>
<h2 id="拦截器执行流程"><a href="#拦截器执行流程" class="headerlink" title="拦截器执行流程"></a>拦截器执行流程</h2><h3 id="启动SpringBoot"><a href="#启动SpringBoot" class="headerlink" title="启动SpringBoot"></a>启动SpringBoot</h3><p>firstFilter的@Order更小，优先加载</p>
<p><img src="https://img-blog.csdnimg.cn/a1f68fc2f98a420488766d3bd609c1e0.png"></p>
<h3 id="请求接口"><a href="#请求接口" class="headerlink" title="请求接口"></a>请求接口</h3><p><img src="https://img-blog.csdnimg.cn/3d03c1015b4b4878ade729d8ed0bd51c.png"></p>
<h3 id="关闭SpringBoot"><a href="#关闭SpringBoot" class="headerlink" title="关闭SpringBoot"></a>关闭SpringBoot</h3><p><img src="https://img-blog.csdnimg.cn/844c3a4fc3e5407b877336fa9dd917a8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAempoYmxvZw==,size_15,color_FFFFFF,t_70,g_se,x_16"></p>
<h1 id="2-主要注解"><a href="#2-主要注解" class="headerlink" title="2.主要注解"></a>2.主要注解</h1><h2 id="WebFilter"><a href="#WebFilter" class="headerlink" title="@WebFilter"></a>@WebFilter</h2><ul>
<li>无需在web.xml 中注册一个 Filter 来对某个 Servlet 程序进行拦截处理</li>
<li>@WebFilter 用于<strong>将一个类声明为过滤器</strong>，该注解将会在部署时被容器处理，容器将根据具体的属性配置将相应的类部署为过滤器。该注解具有下表给出的一些常用属性 ( 以下所有属性均为可选属性，但是 value、urlPatterns、servletNames 三者必需至少包含一个，且 value 和 urlPatterns 不能共存，如果同时指定，通常忽略 value 的取值 )</li>
<li>最重要的就是urlPatterns拦截规则，支持正则，指明需要拦截的路径，多层拦截没有特殊情况</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/517a302755de489bbde1593d1e642557.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAempoYmxvZw==,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h2 id="Order"><a href="#Order" class="headerlink" title="@Order()"></a>@Order()</h2><p>@Order(1)的拦截器优先于@Order(2)，默认值为@Order(2147483647)</p>
<h2 id="ServletComponentScan"><a href="#ServletComponentScan" class="headerlink" title="@ServletComponentScan"></a>@ServletComponentScan</h2><ul>
<li>在SpringBootApplication(启动类)上使用</li>
<li>@ServletComponentScan注解后，Servlet、Filter(过滤器)、Listener(监听器)可以直接通过@WebServlet、@WebFilter、@WebListener注解自动注册，无需其他代码！</li>
</ul>
<h1 id="3-Filter的方法"><a href="#3-Filter的方法" class="headerlink" title="3.Filter的方法"></a>3.Filter的方法</h1><h2 id="初始化init"><a href="#初始化init" class="headerlink" title="初始化init"></a>初始化init</h2><ul>
<li><p>伴随Springboot启动而初始化，只初始化一次</p>
</li>
<li><p>会传递一个包含 Filter 的配置和运行环境信息的 FilterConfig 对象。</p>
</li>
<li><p>如果初始化代码要使用到 FilterConfig 对象，这些代码只能在 init 方法中编写，而不能在构造方法中编写（尚未调用 init 方法，即并没有创建 FilterConfig 对象，要使用它则必然出错）。</p>
<pre><code>@Override
public void init(FilterConfig filterConfig) throws ServletException &#123;
  Filter.super.init(filterConfig);
&#125;
</code></pre>
</li>
</ul>
<h2 id="进入下一Filter-直至Controller层"><a href="#进入下一Filter-直至Controller层" class="headerlink" title="进入下一Filter(直至Controller层)"></a>进入下一Filter(直至Controller层)</h2><pre><code>@Override
  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) 
  throws IOException, ServletException &#123;

    
    filterChain.doFilter(req,res);


  &#125;
</code></pre>
<h2 id="销毁destroy"><a href="#销毁destroy" class="headerlink" title="销毁destroy"></a>销毁destroy</h2><p>结束SpringBoot程序时才销毁（不是结束请求）</p>
<pre><code>  @Override
  public void destroy() &#123;
    Filter.super.destroy();
  &#125;
</code></pre>
<h1 id="4-FilterChain拦截器链"><a href="#4-FilterChain拦截器链" class="headerlink" title="4.FilterChain拦截器链"></a>4.FilterChain拦截器链</h1><ul>
<li>最后一个<code>filterChain.doFilter(req,res)</code>;方法中调用的 FilterChain.doFilter 方法将激活目标 Servlet的service 方法。</li>
<li>只要 Filter 链中任意一个 Filter 没有调用 <code>filterChain.doFilter()</code> 方法，则目标 Servlet 的 service 方法都不会被执行。</li>
<li><code>filterChain.doFilter(req,res)</code>;会自动把FilterChain对象传给下一个<code>Filter.doFilter</code>()</li>
</ul>
<h1 id="5-FilterConfig拦截器配置接口"><a href="#5-FilterConfig拦截器配置接口" class="headerlink" title="5.FilterConfig拦截器配置接口"></a>5.FilterConfig拦截器配置接口</h1><ul>
<li>实现Filter接口后init()方法的形参就是FilterConfig<br><img src="https://img-blog.csdnimg.cn/f7c4668904274f73a0612516a23c2321.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAempoYmxvZw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="摘自菜鸟"></li>
</ul>
<h1 id="6-FilterRegistrationBean和-WebFilter区别"><a href="#6-FilterRegistrationBean和-WebFilter区别" class="headerlink" title="6.FilterRegistrationBean和@WebFilter区别"></a>6.FilterRegistrationBean和@WebFilter区别</h1><p>有2种方式可以实现过滤器</p>
<p>1：通过FilterRegistrationBean实例注册</p>
<p>2：通过@WebFilter注解生效</p>
<p>这里选择第一种，因为第二种不能设置过滤器之间的优先级</p>
<p>转载自灰信：<br><a target="_blank" rel="noopener" href="https://www.freesion.com/article/9482868580/">区别</a></p>
<h1 id="7-OncePerRequestFilter"><a href="#7-OncePerRequestFilter" class="headerlink" title="7.OncePerRequestFilter"></a>7.OncePerRequestFilter</h1><ul>
<li>OncePerRequestFilter仍然是需要注入到Spring中，仍然通常采用@WebFilter</li>
<li>对目标拦截路径的资源仍然正常拦截</li>
<li>OncePerRequestFilter存在于spring-web模块中org.springframework.web.filter ; 而Filter则在Servlet模块中 javax.servlet</li>
<li>OncePerRequestFilter是对Filter的扩展，他内部已重写了init() doFilter() destory()，并且还有自己的抽象方法<code>doFilterInternal</code>需要实现类去重写</li>
<li>内部跳转只拦截一次（一次外部请求只过滤一次）</li>
<li>在SpringMVC中对于Filter的扩展都是继承了OncePerRequestFilter。其中都是实现了doFilterInternal()的方法扩展。</li>
</ul>
<h2 id="重写的doFilter"><a href="#重写的doFilter" class="headerlink" title="重写的doFilter"></a>重写的doFilter</h2><p>源码中的链路调用，调用了抽象方法doFilterInternal，因此需要自己重写才能完成doFilter()的完整逻辑<br><img src="https://img-blog.csdnimg.cn/9f9badeb6ab349e18362cf9d2fa11474.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAempoYmxvZw==,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h2 id="doFilterInternal抽象方法"><a href="#doFilterInternal抽象方法" class="headerlink" title="doFilterInternal抽象方法"></a>doFilterInternal抽象方法</h2><p>用法其实和普通的Filter差不多，但是在接口内部跳转（不加@ResponseBody返回String的接口）时，不会再进行第二次的拦截</p>
<pre><code>@WebFilter(urlPatterns = &quot;/*&quot;)
@Order(-1)
public class OnceFilter extends OncePerRequestFilter &#123;

  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
      throws ServletException, IOException &#123;


    System.out.println(&quot;开始&quot;);

    filterChain.doFilter(request,response);

    System.out.println(&quot;结束&quot;);

  &#125;
&#125;
</code></pre>
<h2 id="OncePerRequestFilter执行顺序"><a href="#OncePerRequestFilter执行顺序" class="headerlink" title="OncePerRequestFilter执行顺序"></a>OncePerRequestFilter执行顺序</h2><ul>
<li>当定义了多个Filter时，<strong>OncePerRequestFilter总是在第一个Filter之后执行</strong></li>
<li>多个OncePerRequestFilter之间也可以有@Order指定顺序</li>
<li><strong>所有OncePerRequestFilter按顺序执行完毕之后，才执行第二个Filter</strong></li>
<li>OncePerRequestFilter也满足Filter队列的出队顺序</li>
</ul>
<p>其他参考：<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/166411087">添加链接描述</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/filter-filterchain-filterconfig-intro.html">菜鸟</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/04/21/Filter%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/" data-id="cl8wvrz8f0003kktaelfj3lbs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Lambda表达式和方法引用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/21/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/" class="article-date">
  <time datetime="2022-04-21T01:50:42.000Z" itemprop="datePublished">2022-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/21/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/">Lambda表达式和方法引用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ioriogami/article/details/12782141?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164946395516780255216553%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164946395516780255216553&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-12782141.142%5Ev7%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1018.2226.3001.4187">1</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kb411W75N?p=674&spm_id_from=pageDriver">2</a></p>
<h1 id="什么是lambda表达式"><a href="#什么是lambda表达式" class="headerlink" title="什么是lambda表达式"></a>什么是lambda表达式</h1><ul>
<li><p>lambda意为λ，表示是一个函数，而一个函数只有唯一的输入输出映射，因此引出lambda表达式的定义</p>
</li>
<li><p><strong>Lambda是一个<code>唯一匿名方法</code></strong></p>
</li>
<li><p>一个接口，如果<strong>只有一个显式声明的抽象方法，那么它就是一个函数式接口</strong>。一般用@FunctionalInterface标注出来（也可以不标）</p>
</li>
<li><p>因为该接口有一个抽象方法，在new的时候需要@Override这个抽象方法    </p>
</li>
</ul>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p><img src="https://img-blog.csdnimg.cn/9eb2a21974c0441b9de4e42cd32db7a2.png"></p>
<h2 id="什么可以省略？"><a href="#什么可以省略？" class="headerlink" title="什么可以省略？"></a>什么可以省略？</h2><p><strong><code>可推断的都可省略，因此尽可能使用泛型</code></strong></p>
<p>方框中都可以省略</p>
<p><img src="https://img-blog.csdnimg.cn/09cef4588f1e4cb68009d2eb80211ee3.png" alt="方框中都可以省略">因为在调用这个方法的时候，public int add(int int ) return 都是<strong>唯一且确定且必须存在的</strong>，因此可以被唯一推断出来，所以可以省略，省略后为</p>
<p><code>(x,y) -&gt; x+y;</code><br>因为只有一行语句，所以代码块{}可省，return可省</p>
<h1 id="1-预定义的函数式接口"><a href="#1-预定义的函数式接口" class="headerlink" title="1.预定义的函数式接口"></a>1.预定义的函数式接口</h1><p>在JDK中定义了很多的函数式接口，例如BiFunction接口，就可以传入两个参数，返回一个参数，无需自定义；当然三个传参还是需要自定义的<br><img src="https://img-blog.csdnimg.cn/1fb4162e9e3743de8c6c874e83c16ec7.png"></p>
<h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><h3 id="函数型接口"><a href="#函数型接口" class="headerlink" title="函数型接口"></a>函数型接口</h3><p>1.JDK预定义了很多函数式接口以避免用户重复定义。最典型的是<code>Function</code>：</p>
<pre><code>@FunctionalInterface
public interface Function&lt;T, R&gt; &#123; 
    R apply(T t);
&#125;
</code></pre>
<p>这个接口代表一个函数，接受一个T类型的参数，并返回一个R类型的返回值。   </p>
<h3 id="消费型接口"><a href="#消费型接口" class="headerlink" title="消费型接口"></a>消费型接口</h3><p>2.另一个预定义函数式接口叫做<code>Consumer</code>，跟Function的唯一不同是它没有返回值。</p>
<pre><code>@FunctionalInterface
public interface Consumer&lt;T&gt; &#123; 
    void accept(T t);
&#125;
</code></pre>
<h3 id="供给型接口"><a href="#供给型接口" class="headerlink" title="供给型接口"></a>供给型接口</h3><p>3.<code>Supplier</code> 有一个get(）方法</p>
<pre><code>@FunctionnallInterface
public interface Supplier&lt;T&gt;&#123;
    T get();
&#125;
</code></pre>
<h3 id="断定型接口"><a href="#断定型接口" class="headerlink" title="断定型接口"></a>断定型接口</h3><p>4.还有一个<code>Predicate</code>断定，用来判断某项条件是否满足。经常用来进行筛滤操作：</p>
<pre><code>@FunctionalInterface
public interface Predicate&lt;T&gt; &#123; 
    boolean test(T t);
&#125;
</code></pre>
<h2 id="1-2函数式接口的测试"><a href="#1-2函数式接口的测试" class="headerlink" title="1.2函数式接口的测试"></a>1.2函数式接口的测试</h2><pre><code>public class LambdaTest &#123;


    public static void main(String[] args) &#123;

//1.Runnale接口测试————run()
        Runnable r = () -&gt; System.out.println(&quot;测试&quot;);
        r.run();


//2.Function接口测试————— T apply(X x)
        Function&lt;Integer, Integer&gt; fun = (age) -&gt; &#123;
            System.out.println(&quot;年龄为：&quot; + age);//年龄为：21
            return age + 1;
        &#125;;
        System.out.println(&quot;下次过生日的年龄：&quot; + fun.apply(21));//下次过生日的年龄：22

//3.Consumer接口测试————accept(T t)
        //3.1加泛型，推断s为String类型
        Consumer&lt;String&gt; con = (s) -&gt; System.out.println(s + &quot;666666&quot;);//双击关注666666
        con.accept(&quot;双击关注&quot;);
        //3.2不加泛型需要指定，默认为Object
        Consumer con2 = (s) -&gt; System.out.println(s + &quot;777777&quot;);//养猪厂子777777
        con2.accept(&quot;养猪厂子&quot;);

//4.Supplier接口测试
        //4.1不加泛型，则不推断
        Supplier sup = () -&gt; &#123;
            return new Integer(1);
        &#125;;
        //4.2加泛型，则可推断返回值为Integer
        Supplier&lt;Integer&gt; sup2 = () -&gt; 1;

//5.Predicate接口测试
        Predicate&lt;Integer&gt; pred = (i) -&gt; i &gt; 10;
        System.out.println(pred.test(11));//ture
        System.out.println(pred.test(9));//false
    &#125;
    &#125;
</code></pre>
<h1 id="2-自定义函数式接口"><a href="#2-自定义函数式接口" class="headerlink" title="2.自定义函数式接口"></a>2.自定义函数式接口</h1><p>定义函数式接口，接收多个参数</p>
<pre><code>@FunctionalInterface
public interface MyFunction&lt;X,Y,Z,T&gt; &#123;
    T fun(X x,Y y ,Z z);
&#125;
</code></pre>
<p>使用</p>
<pre><code>//6.自定义MyFunction接口
        MyFunction&lt;Integer,Integer,Integer,String&gt; myFun =
                (age,weight,higth) -&gt; &quot;年龄为：&quot; + age
                                    + &quot;体重为：&quot; + weight
                                    + &quot;身高为：&quot; + higth;

        String myInfo = myFun.fun(21, 145, 181);
        System.out.println(myInfo);//年龄为：21体重为：145身高为：181
</code></pre>
<h1 id="3-方法引用"><a href="#3-方法引用" class="headerlink" title="3.方法引用"></a>3.方法引用</h1><ul>
<li>当实现@FunctionalInterface的函数式接口使用lambda表达式时，<br>如果方法体直接调用 某个类or对象 的 静态or非静态方法，<br>且返回值和形参都高度相同or完全相同，那么就可以使用方法引用</li>
<li><code>编译看左</code>：类型的推断需要左边函数类的泛型来指定<h2 id="3-1对象-非静态方法"><a href="#3-1对象-非静态方法" class="headerlink" title="3.1对象::非静态方法"></a>3.1对象::非静态方法</h2><code>Function fun = p :: myHight;即把fun中的唯一抽象函数apply() 和 myHight()方法绑定，调用fun.apply(1)相当于调用p.myHight(1)</code></li>
</ul>
<pre><code>public class LambdaTest2 &#123;
    public static void main(String[] args) &#123;

        //0. People的非静态方法myHight()的形参 和 Function类的apply()方法的形参对应
        //                            的返回值 和                      的返回值对应

        People p = new People(21,&quot;张家豪&quot;);
        //1.用 对象p :: 非静态方法
        Function&lt;Integer,String&gt; fun = p :: myHight;
        //2.此时的fun对象中的apply()方法已经和 p对象中的myHight()方法绑定
        System.out.println(fun.apply(181));


    &#125;
&#125;



class People&#123;
    int age;
    String name;

    public  String myHight(Integer hight)&#123;
        return &quot;my hight is &quot; + hight;
    &#125;&#125;
</code></pre>
<h2 id="3-2类-静态方法"><a href="#3-2类-静态方法" class="headerlink" title="3.2类 :: 静态方法"></a>3.2类 :: 静态方法</h2><pre><code>。。。。。。。。
    //编译看左：左边需要指定泛型，才能推断出右边的参数类型
        Consumer&lt;Integer&gt; con = People::describe;
        con.accept(2);
    &#125;
&#125;


class People &#123;
    int age;
    String name;

    public static void describe2(Integer i) &#123;
        System.out.println(&quot;People类有&quot; + i + &quot;个属性参数&quot;);
        System.out.println(&quot;一个是name，一个是age&quot;);
    &#125;
</code></pre>
<h2 id="3-3类-实例方法"><a href="#3-3类-实例方法" class="headerlink" title="3.3类 :: 实例方法"></a>3.3类 :: 实例方法</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lkforce/article/details/99682885?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164947501216780264034763%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164947501216780264034763&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-99682885.142%5Ev7%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8&spm=1018.2226.3001.4187">参考</a></p>
<h1 id="4-构造器引用"><a href="#4-构造器引用" class="headerlink" title="4.构造器引用"></a>4.构造器引用</h1><p>和方法引用类似<br>构造器的形参 = 函数式接口的抽象方法</p>
<pre><code>        Function&lt;String,People&gt; fun1 = s -&gt; new People(s);
        People p1 = fun1.apply(&quot;张豪猪&quot;);
        
        Function&lt;String,People&gt; fun2 = People::new;
        People p2 = fun2.apply(&quot;豪猪张&quot;);

        BiFunction&lt;Integer,String,People&gt; bifun1 = People::new;
        People p3 = bifun1.apply(21, &quot;豪张猪&quot;);


    &#125;
&#125;

@AllConstructor
class People &#123;
    int age;
    String name;

    
</code></pre>
<h1 id="5-数组引用"><a href="#5-数组引用" class="headerlink" title="5.数组引用"></a>5.数组引用</h1><p>数组引用算是构造器引用的一种，可以引用一个数组的构造</p>
<pre><code>    Function&lt;Integer,People[]&gt; fun1 = p -&gt; new People[p];
    People[] arr1 = fun1.apply(10);//创建一个长度为10的People数组
    
    Function&lt;Integer,People[]&gt; fun2 = People[]::new;
    fun2.apply(20);

&#125;
&#125;


class People &#123;
int age;
String name;
</code></pre>
<h1 id="区别与总结"><a href="#区别与总结" class="headerlink" title="区别与总结"></a>区别与总结</h1><h2 id="1-类型推断"><a href="#1-类型推断" class="headerlink" title="1.类型推断"></a>1.类型推断</h2><h3 id="编译看左"><a href="#编译看左" class="headerlink" title="编译看左"></a>编译看左</h3><p>有一个People的静态方法 public static void describe(Integer count) {。。}<br>则必须通过<code> Consumer &lt;Integer&gt; con = People::describe;</code><br>而不能 Consumer con = People::describe;<br>因为后者不能推断出con.accept()需要什么类型的参数</p>
<h3 id="泛型顺序对应形参顺序"><a href="#泛型顺序对应形参顺序" class="headerlink" title="泛型顺序对应形参顺序"></a>泛型顺序对应形参顺序</h3><p><strong>Function&lt;x,y&gt; fun = 是如何确定谁是形参谁是返回值的呢？</strong></p>
<ul>
<li>第一个是形参，第二个是返回值</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/9e28c69a2a504aab9f42270ab7060d65.png"></p>
<p>而此时因为一一对应，Function&lt;Integer,String&gt;一定是Integer为形参，String为返回值</p>
<ul>
<li>》》》当BiFunction&lt;T, U, R&gt; bifun= 时，R是返回值类型，T和U的顺序也已经固定<img src="https://img-blog.csdnimg.cn/25b2e7cf019843209f7785facc863f84.png"></li>
</ul>
<h2 id="2-能省则省"><a href="#2-能省则省" class="headerlink" title="2.能省则省"></a>2.能省则省</h2><p>凡是能唯一确定推断的都能省略</p>
<ul>
<li><code>(s) -&gt;&#123;return 一个语句&#125; </code>可写为<code> s -&gt; 一个语句</code></li>
</ul>
<h2 id="3-代码绑定"><a href="#3-代码绑定" class="headerlink" title="3.代码绑定"></a>3.代码绑定</h2><p>例如：</p>
<ul>
<li>Function&lt;Integer,String&gt; fun = p :: myHight<strong>就是把myHight()方法绑定给了fun.apply()</strong></li>
<li>Supplier<Integer> sup = () -&gt; {…..return i } ; <strong>则是把{…..return i }代码块绑定给sup.get()</strong></li>
</ul>
<h2 id="4-方法引用和lambda的联系"><a href="#4-方法引用和lambda的联系" class="headerlink" title="4.方法引用和lambda的联系"></a>4.方法引用和lambda的联系</h2><p>方法引用本质就是lambda表达式，只是在上一个例子中<code>Supplier&lt;Integer&gt; sup = () -&gt; &#123;.....return i &#125; ;</code>里面的<code>&#123;.....return i &#125; </code>如果是被封装到了某一个特定的方法，那么可以直接使用方法引用，而不需要把代码块的内容挨个写出来</p>
<h2 id="5-构造器引用和方法引用的联系"><a href="#5-构造器引用和方法引用的联系" class="headerlink" title="5.构造器引用和方法引用的联系"></a>5.构造器引用和方法引用的联系</h2><p>构造器引用本质是方法引用，<strong>方法体就是new 一个对象，并返回</strong>，因此形如：<img src="https://img-blog.csdnimg.cn/b26591439cf348949f684e757c2eb215.png"><br>但一定要有new</p>
<h2 id="6-数组引用和构造引用的联系"><a href="#6-数组引用和构造引用的联系" class="headerlink" title="6.数组引用和构造引用的联系"></a>6.数组引用和构造引用的联系</h2><p>之前的构造引用都是new一个对象，而数组引用是new一个数组，仅此而已，形如：<img src="https://img-blog.csdnimg.cn/7c49fdd38cdc4f15bf1fcc2fb2d6a460.png" alt="创建长度为20的People[] "></p>
<h1 id="forEach的lambda表达式"><a href="#forEach的lambda表达式" class="headerlink" title="forEach的lambda表达式"></a>forEach的lambda表达式</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/shaoyangdd/article/details/78992497?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164946767416780271931413%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164946767416780271931413&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-78992497.142%5Ev7%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=foreach%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1018.2226.3001.4187">参考</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/04/21/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/" data-id="cl8wvrz8t000jkkta5qwsgxw6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mybatis中xml中调java方法OGNL表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/21/Mybatis%E4%B8%ADxml%E4%B8%AD%E8%B0%83java%E6%96%B9%E6%B3%95OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time datetime="2022-04-21T01:47:36.000Z" itemprop="datePublished">2022-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/21/Mybatis%E4%B8%ADxml%E4%B8%AD%E8%B0%83java%E6%96%B9%E6%B3%95OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F/">Mybatis中xml中调java方法OGNL表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一般在Mybatis中用#{}来防止sql注入，但是这种预编译的模式会导致无法调用java的方法，因此在系统安全性较高的情况下可以尝试使用${}来调用java方法进行数据处理</p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><ul>
<li><p>create_date是datetime类型<br>create_time是时间戳类型，但时间戳是13位的long型，这里是11位的int类型(int最大十进制长度)</p>
</li>
<li><p>前者没有索引，后者有索引（优势：字段短，索引更快，int比long占内存更小）</p>
</li>
<li><p>前者给DBA看，后者用于条件查询</p>
</li>
</ul>
<h1 id="使用OGNL表达式"><a href="#使用OGNL表达式" class="headerlink" title="使用OGNL表达式"></a>使用OGNL表达式</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/huayu815/article/details/7446141">OGNL表达式参考</a></p>
<pre><code>  &lt;select id=&quot;mapper方法名&quot; resultType=&quot;Res对象&quot;&gt;
    SELECT source, SUM(IF(type = 0, -amount, amount))
    FROM 表
    WHERE create_time &lt;![CDATA[ &lt;  ]]&gt; $&#123;endDateTime.toInstant(@java.time.ZoneOffset@of(&quot;+8&quot;)).toEpochMilli()/1000&#125;
      AND create_time &lt;![CDATA[ &gt;= ]]&gt; $&#123;startDateTime.toInstant(@java.time.ZoneOffset@of(&quot;+8&quot;)).toEpochMilli()/1000&#125;
    GROUP BY source

  &lt;/select&gt;
</code></pre>
<p>注：调静态方法时，类和方法都要加@；<br> /1000是为了让本身为long型的13位时间戳变成11位的int以便SELECT，<strong>且本身不是函数，不会导致索引失效</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/04/21/Mybatis%E4%B8%ADxml%E4%B8%AD%E8%B0%83java%E6%96%B9%E6%B3%95OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="cl8wvrz8w000nkkta177v2nnx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/">数据结构算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/26/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%81%9A%E9%BB%91%E5%90%8D%E5%8D%95%E7%9A%84%E6%96%B9%E6%A1%88/">布隆过滤做黑名单的方案</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E6%9F%90%E8%9A%81%E9%87%91%E6%9C%8D%E7%A7%8B%E6%8B%9B9-15/">某蚁金服秋招9-15</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">三种情况的层序遍历</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E5%87%A0%E9%81%93%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98-dfs-%E5%89%AA%E6%9E%9D-%E5%9B%9E%E6%BA%AF/">几道岛屿问题:dfs+剪枝+回溯</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%E6%9B%BF%E6%8D%A2%E3%80%81%E5%B7%A6%E6%97%8B%E3%80%81%E7%BC%BA%E5%A4%B1/">字符串：替换、左旋、缺失</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 张家豪<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>