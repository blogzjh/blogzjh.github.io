<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>随机森林——泰坦尼克号获救预测</title>
      <link href="/zjh/2022/01/11/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E8%8E%B7%E6%95%91%E9%A2%84%E6%B5%8B/"/>
      <url>/zjh/2022/01/11/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E8%8E%B7%E6%95%91%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>定义问题——&gt;数据收集——&gt;数据清洗——&gt;分析——&gt;建模——&gt;验证——&gt;优化</p><p>该问题下前两步已经完成，本文从数据清洗开始</p><h1 id="数据集的特征解读"><a href="#数据集的特征解读" class="headerlink" title="数据集的特征解读"></a>数据集的特征解读</h1><table><thead><tr><th align="center">英</th><th align="center">中</th><th align="center">分析</th></tr></thead><tbody><tr><td align="center">PassengeID</td><td align="center">乘客ID</td><td align="center">乘客ID不影响Survive与否，但可标识身份</td></tr><tr><td align="center">Pclass</td><td align="center">船舱等级</td><td align="center">高等船舱靠近甲板，更容易Survive</td></tr><tr><td align="center">Name</td><td align="center">姓名</td><td align="center">标记</td></tr><tr><td align="center">Sex</td><td align="center">性别</td><td align="center">男女生理差别，对Survive有影响</td></tr><tr><td align="center">Age</td><td align="center">年龄</td><td align="center">同上</td></tr><tr><td align="center">SibSp</td><td align="center">兄弟配偶数</td><td align="center">有无同行兄弟or配偶，同行会影响决策</td></tr><tr><td align="center">Parch</td><td align="center">父母孩子数</td><td align="center">有无同行父母or孩子，从而影响Survive</td></tr><tr><td align="center">Ticket</td><td align="center">船票信息</td><td align="center">/</td></tr><tr><td align="center">Fare</td><td align="center">票价</td><td align="center">票价跟Pclass也是正相关</td></tr><tr><td align="center">Cabin</td><td align="center">船舱信息</td><td align="center">/</td></tr><tr><td align="center">Embarked</td><td align="center">港口</td><td align="center">/</td></tr><tr><td align="center">Survived</td><td align="center">存活与否</td><td align="center">/</td></tr></tbody></table><p>以上信息中</p><ul><li>有些特征对分析没什么意义，建模时可以不扔进算法</li><li>有些特征之间互相有关联，可以多特征线性合并</li><li>部分数据需要清洗</li><li>Train集中的Survived变量要放入模型训练</li><li>Test集中的Survived变量作为验证标准</li></ul><h1 id="库和数据导入，简单分析"><a href="#库和数据导入，简单分析" class="headerlink" title="库和数据导入，简单分析"></a>库和数据导入，简单分析</h1><pre><code>import pandas as pdimport numpy as npimport timeimport sklearnfrom sklearn import ensemble#集成学习，包括了随机森林，SVM等集成学习算法from sklearn import feature_selection#特征值选择，分类回归都需要的特征值如F和Pfrom sklearn import model_selection#模型选择，包括了交叉验证，网格搜索等from sklearn import metrics#包括了多个计算模型评估的算法from sklearn.preprocessing import LabelEncoder#将Label标准化，如：字符串——&gt;数字，以便代入模型##绘图import matplotlib as mplimport matplotlib.pyplot as pltimport seaborn as sns#一个封装好的matplotlib，底层是matplotlib，使用更方便#mpl.style_use(&quot;ggplot&quot;)#设置matplotlib的绘图风格，可有可无data_train = pd.read_csv(&quot;train.csv&quot;)data_test  = pd.read_csv(&quot;test.csv&quot;)#显示数据集信息print(data_train.info())print(data_test.head(10))</code></pre><h2 id="完整显示数据集统计信息（完整描述）set-option"><a href="#完整显示数据集统计信息（完整描述）set-option" class="headerlink" title="完整显示数据集统计信息（完整描述）set_option"></a>完整显示数据集统计信息（完整描述）set_option</h2><pre><code>pd.set_option(&#39;display.max_columns&#39;,11)#train集中有11列属性，设置最大列数为11print(data_train.describe())</code></pre><ul><li>同样的，pd.set_option(‘display.max_columns’,10)也可以让原本显示不全的head()显示全</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/5cef01f2bb72055365b892b39b01cdfb.png" alt="info和head输出结果"></p><pre><code>count:有效值个数（非空值）unique:特征值的种类数top：出现最多的特征freq: top出现的次数mean：均值std : 标准差min ：最小值25%：四分之一位50%：中位数75%：四分之三位max：最大值</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/aadde03b94c0c0ced9033806d8fa540f.png" alt="describe输出结果"></p><ul><li><strong>一共有891行数据，但Age、Cabin属性明显缺失，此案例下的缺失值暂时用中位数代替</strong></li></ul><h1 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h1><p>数据清洗是数据分析中耗时最长最麻烦的阶段</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><pre><code>#列名小写,方便后续data_test.columns = data_test.columns.str.lower()data_train.columns = data_train.columns.str.lower()data_train.info()#查看属性小写后的info#合并Train和Test以便统一数据清洗data_sum = [data_train , data_test]#但由于这个sum是一个list，会缺少很多原本train和test能用的属性or方法，如columns#注意：此处的合并不是直接合并数据集，而是创建一个list，实现一键操作#一定是先分别lower再合并成sum</code></pre><p>   <strong>要想调用方法，需要使用for循环</strong></p><h3 id="查看survived的统计直方图"><a href="#查看survived的统计直方图" class="headerlink" title="查看survived的统计直方图"></a>查看survived的统计直方图</h3><pre><code>#查看属性统计量seaborn下的countplot，绘制图像sns.countplot(x = data_train[&#39;survived&#39;] )#sns.coutplot(x = &quot;survived&quot; , data = data_train)#两种表达方式plt.show()#olt.show()是生成图的操作，必不可少</code></pre><h2 id="补全缺失值fillna"><a href="#补全缺失值fillna" class="headerlink" title="补全缺失值fillna"></a>补全缺失值fillna</h2><pre><code>#分别查看train和test集中为null值的汇总print(data_train.isnull().sum())print(&#39;\n&#39;)print(data_test.isnull().sum())</code></pre><ul><li><strong>age embarked的缺失值占比比较少，可以替换值</strong></li><li><strong>cabin的缺失值占比很高，建模时直接把cabin属性全扔掉</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/6608f6f8d8f17032998fd2e2801c213b.png" alt="左：null汇总  右：contplot直方图"></p><h3 id="利用for循环对样本集一键纠正"><a href="#利用for循环对样本集一键纠正" class="headerlink" title="利用for循环对样本集一键纠正"></a>利用for循环对样本集一键纠正</h3><pre><code>for dataset in data_sum:    dataset[&#39;age&#39;].fillna(dataset[&#39;age&#39;].median() , inplace=True)    dataset[&#39;fare&#39;].fillna(dataset[&#39;fare&#39;].median() , inplace=True)    ###因为age、fare都是数字类型，因此可以调用median中位数    ###而像属性值位字符串的特征则不能调用median    dataset[&#39;embarked&#39;].fillna(dataset[&#39;embarked&#39;].mode()[0] , inplace=True)    #mode返回的是 众数，因为即便是字符串，也可以调用</code></pre><ul><li><p>注意：mode和median的用法场景区别</p></li><li><p>注意fillna的使用格式</p></li><li><p>inplace=True表示更改原数据集，而不是返回一个新的数据集</p></li><li><p>mode是pandas下的一个方法，返回按索引号排序的众数，<strong>mode()[索引号]的索引号很重要，如果省略则不填充</strong></p><h2 id="删除无用字段-特征-drop"><a href="#删除无用字段-特征-drop" class="headerlink" title="删除无用字段(特征)drop"></a>删除无用字段(特征)drop</h2><p>  drop_columns = [‘cabin’,’passengerid’,’ticket’]#创建一个list<br>  #分析认为：cabin缺失值太多，需要删除<br>  #passengerid无关survive，删除<br>  #ticket都是编号，删除</p><p>  data_train.drop(drop_columns,axis=1,inplace=True)<br>  data_test.drop(drop_columns,axis=1,inplace=True)<br>  #drop参数的意义(行or列 , axis=0删行 axis=1删列 ， inplace=True直接更改调用者数据集本身)</p></li><li><p>注意：drop的参数含义</p></li><li><p>可以构建for循环 + drop_columns一次操作</p></li></ul><h2 id="纠正异常值"><a href="#纠正异常值" class="headerlink" title="纠正异常值"></a>纠正异常值</h2><h3 id="利用for循环的样本集一键纠正"><a href="#利用for循环的样本集一键纠正" class="headerlink" title="利用for循环的样本集一键纠正"></a>利用for循环的样本集一键纠正</h3><p>因为这个案例中信息来源准确，可以认为没有异常值，故在此案例中不做处理</p><h2 id="构建新特征"><a href="#构建新特征" class="headerlink" title="构建新特征"></a>构建新特征</h2><ul><li>连续值用cut或者qcut来划分</li><li>离散值直接划分，合并数量少的值<h3 id="同行规模"><a href="#同行规模" class="headerlink" title="同行规模"></a>同行规模</h3><pre><code>  #同行规模 = 配偶 + 兄弟姐妹 + 1(自己)  dataset[&#39;together_size&#39;] =  dataset[&#39;sibsp&#39;] + dataset[&#39;parch&#39;] + 1</code></pre></li></ul><h3 id="是否单身"><a href="#是否单身" class="headerlink" title="是否单身"></a>是否单身</h3><pre><code>    #是否单身：单身可以不顾别人，会影响survive    dataset[&#39;isSingle&#39;] = 0    dataset[&#39;isSingle&#39;].loc[dataset[&#39;together_size&#39;] &gt; 1] = 1</code></pre><h3 id="票价分段：cut"><a href="#票价分段：cut" class="headerlink" title="票价分段：cut"></a>票价分段：cut</h3><pre><code>    #票价分段fare_bin:票价的离散值太多，应该划分为几个集    #数据集中票价0~512，并且绝大多数都是便宜票，所以用cut等宽划分    dataset[&#39;fare_bin&#39;] = pd.cut(dataset[&#39;fare&#39;] , 4)</code></pre><h3 id="年龄分段：qcut"><a href="#年龄分段：qcut" class="headerlink" title="年龄分段：qcut"></a>年龄分段：qcut</h3><pre><code>    #年龄分段age_bin    dataset[&#39;age_bin&#39;] = pd.qcut(dataset[&#39;age&#39;] , 4)</code></pre><h3 id="身份分类：合少为1"><a href="#身份分类：合少为1" class="headerlink" title="身份分类：合少为1"></a>身份分类：合少为1</h3><pre><code>    #身份 status:因为英国人的名字会加入跟身份有关的职业，身份也会影响获救概率    dataset[&#39;status&#39;] = dataset[&#39;name&#39;].str.split(&#39;, &#39; , expand = True)[1].str.split(&#39;.&#39; , expand = True)[0]    ###参数含义：str是返回字符串，expand要为True值    ###按引号中的符号进行split拆分，[0]表示取前半段，[1]表示取后半段    print(dataset[&#39;status&#39;].value_counts())#查看统计</code></pre><p><img src="https://img-blog.csdnimg.cn/6a4e973ba6174e63a9514db8712abbc3.png" alt="可以把少的分为一类other"></p><pre><code>   #把少的分为一类other    othersSum = dataset[&#39;status&#39;].value_counts() &lt; 10    #other对象 = 小于10的    dataset[&#39;status&#39;] = dataset[&#39;status&#39;].apply(lambda x : &#39;ohter&#39; if othersSum[x] else x)    #更新后的status属性 = 之前的status.aooly(lambda x : &#39;新的名字&#39; if other对象[x] else x)    print(dataset[&#39;status&#39;].value_counts())</code></pre><p><img src="https://img-blog.csdnimg.cn/2629dc2066e64987b95896a87db5dd6c.png" alt="少的被分到了other组"></p><h2 id="新特征分析：评估新特征划分的好坏"><a href="#新特征分析：评估新特征划分的好坏" class="headerlink" title="新特征分析：评估新特征划分的好坏"></a>新特征分析：评估新特征划分的好坏</h2><p>以不同的特征分类计算各属性值的均值，以标签survived的均值为参考，不同特征值的标签均值差别越大越好</p><pre><code>#简单分析上述构建特征是否有效:groupby根据属性值分组print(data_train[&#39;survived&#39;].groupby(data_train[&#39;status&#39;]).mean())#查看按这样构建的特征status的不同值survived对应的均值print(data_train[&#39;survived&#39;].groupby(data_train[&#39;age_bin&#39;]).mean())print(data_train[&#39;survived&#39;].groupby(data_train[&#39;fare_bin&#39;]).mean())print(data_train[&#39;survived&#39;].groupby(data_train[&#39;isSingle&#39;]).mean())print(data_train[&#39;survived&#39;].groupby(data_train[&#39;together_size&#39;]).mean())</code></pre><p><img src="https://img-blog.csdnimg.cn/7fb4dcd3150d4be886223a0af1715d6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_19,color_FFFFFF,t_70,g_se,x_16" alt="新特征分析">于是对age_bin进行修改，最终尝试结果是qcut改cut，区分度提升最明显</p><h1 id="格式替换-构建新字段，"><a href="#格式替换-构建新字段，" class="headerlink" title="格式替换,构建新字段，"></a>格式替换,构建新字段，</h1><p>1，基于scikit-learn中的LabelEncoder()<br>把属性值为字符串的特征转化为“特征_code”，字符串——&gt;数字，以便放入模型中跑<br><strong>机器学习模型只能处理int和float的数据</strong></p><pre><code>#实例化label = LabelEncoder()#字符串——&gt;数字for dataset in data_sum:    # （1）新字段：sex_code    dataset[&#39;sex_code&#39;] = label.fit_transform(dataset[&#39;sex&#39;])    # （2）新字段：embarked_code    dataset[&#39;embarked_code&#39;] = label.fit_transform(dataset[&#39;embarked&#39;])    # （3）新字段：status_code    dataset[&#39;status_code&#39;] = label.fit_transform(dataset[&#39;status&#39;])    # （4）新字段：age_bin_code    dataset[&#39;age_bin_code&#39;] = label.fit_transform(dataset[&#39;age_bin&#39;])    # （5）新字段：fare_bin_code    dataset[&#39;fare_bin_code&#39;] = label.fit_transform(dataset[&#39;fare_bin&#39;])print(data_train.columns.to_list)    </code></pre><p><img src="https://img-blog.csdnimg.cn/e20dfbee4e5b4bb7992cfb15aaeae6ac.png" alt="新的列名"><br><img src="https://img-blog.csdnimg.cn/cda97a956c634886b678242a3a315ec8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br>2，通过Pandas中的get_dummies() 进行编码</p><h1 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h1><h2 id="标签、特征选择"><a href="#标签、特征选择" class="headerlink" title="标签、特征选择"></a>标签、特征选择</h2><h3 id="标签选择"><a href="#标签选择" class="headerlink" title="标签选择"></a>标签选择</h3><pre><code>target = [&#39;survived&#39;]    </code></pre><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><pre><code>data_feature_one = [&#39;sex&#39;, &#39;pclass&#39;, &#39;embarked&#39;, &#39;status&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;age&#39;, &#39;fare&#39;, &#39;together_size&#39;,                    &#39;isSingle&#39;]</code></pre><h3 id="通过Pandas中的get-dummies-进行编码"><a href="#通过Pandas中的get-dummies-进行编码" class="headerlink" title="通过Pandas中的get_dummies() 进行编码"></a>通过Pandas中的get_dummies() 进行编码</h3><p>这是一个暴力转码（字符串——&gt;数字代号）的方法，十分简单，且更好用</p><pre><code>data_one_dummy = pd.get_dummies(data_train[data_feature_one])#把data_feature_one中需要转码的如：status、embarked转为数字代号data_one_dummy_list = data_one_dummy.columns.tolist()#转list，以便放入网格搜索的形参中去跑</code></pre><h2 id="把train集拆分为训练集和测试"><a href="#把train集拆分为训练集和测试" class="headerlink" title="把train集拆分为训练集和测试"></a>把train集拆分为训练集和测试</h2><pre><code>X_train_one, X_test_one, y_train_one, y_test_one = model_selection.train_test_split(data_one_dummy[data_one_dummy_list],#转码后的list格式的train[feature]                                                                    data_train[target],#标签                                                                    random_state = 0)#随机种子print(X_train_one.shape)print(X_test_one.shape)#shape查看分割的大小，也可以通过size参数自己设置分割比例,数据量很大时通常使用2 8分，train_size=0.8print(y_train_one.shape)print(y_test_one.shape)#大X表示：特征  小y表示：标签</code></pre><p><img src="https://img-blog.csdnimg.cn/f70f693e524f4c75bfdb6ccfe37883b4.png" alt="左：数据量(行)  右：特征数(列)"></p><h2 id="网格搜索：寻找最优"><a href="#网格搜索：寻找最优" class="headerlink" title="网格搜索：寻找最优"></a>网格搜索：寻找最优</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><pre><code>from sklearn.model_selection import GridSearchCV   #网格搜索from sklearn.ensemble import RandomForestClassifier #随机森林分类器rfc = RandomForestClassifier(max_features=&#39;auto&#39; , random_state= 0 , n_jobs=-1 )#实例化一个RandomForestClassifier对象#简单选取所有特征 ， 随机种子=0  ， 利用所有线程#这里实例化RandomForestClassifier时可以不用写入太多参数，参数可以放进网格里面自己跑出最优的</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><pre><code>param_gird = &#123;#需要最优化的参数对象    &#39;criterion&#39; : [&#39;gini&#39;, &#39;entropy&#39;],#标准选择    &#39;min_samples_leaf&#39; : [ 1,3,5, 10],#最小子叶数    &#39;min_samples_split&#39; : [10, 12, 16,20,24],#最小样本数    &#39;n_estimators&#39; : [20,35,50,100]#决策树的个数选择&#125;gscv = GridSearchCV(#网格搜索交叉验证对象                estimator=rfc,#rf带入网格算                param_grid=param_gird,#需要最优化的参数带入                scoring= &#39;accuracy&#39;, #得分评判————准确度                cv=3,#交叉验证次数                n_jobs=-1)#-1 利用CPU所有线程gs = gscv.fit(X_train_one , y_train_one.values.ravel())#自动训练，两个参数都是train集#.values.ravel()是为了防止warning#自动训练的所有结果返回在gs中，这个print(gs.best_score_)#最高分数print(gs.best_params_)#最佳组合</code></pre><p><img src="https://img-blog.csdnimg.cn/7b7e4e2ba989488b8e4d553f025731fc.png"></p><h3 id="网格搜索调参"><a href="#网格搜索调参" class="headerlink" title="网格搜索调参"></a>网格搜索调参</h3><ul><li>如果某特征的最优值是在罗列的数的中间，那么认为比较优秀</li><li>如果在边上，就需要往那个方向调参重新跑</li><li>同时有多个参数需要调时，先调差距最大的</li><li>即使是位于中间的参数也可以细分调整</li><li>类似高中生物实验探究题《寻找最佳浓度》的思想</li></ul><h2 id="用最优参数训练随机森林"><a href="#用最优参数训练随机森林" class="headerlink" title="用最优参数训练随机森林"></a>用最优参数训练随机森林</h2><pre><code>#实例化RandomForestClassifier对象rfc2 = RandomForestClassifier(criterion=&#39;entropy&#39;,                             min_samples_leaf=5,                             min_samples_split=16,                             n_estimators=35,                             n_jobs=-1,                             random_state=1)#训练rfc2.fit(X_train_one, y_train_one.values.ravel())</code></pre><p>此时训练完成，等待后续用<strong>split分割出来的测试集test来测试</strong></p><h3 id="根据特征的重要性排序"><a href="#根据特征的重要性排序" class="headerlink" title="根据特征的重要性排序"></a>根据特征的重要性排序</h3><pre><code>print(pd.concat((pd.DataFrame(X_train_one.iloc[:, 1:].columns, columns=[&#39;Variable&#39;]),           pd.DataFrame(rfc2.feature_importances_, columns=[&#39;importance&#39;])),           axis=1).sort_values(by=&#39;importance&#39;, ascending=False))</code></pre><p><img src="https://img-blog.csdnimg.cn/1583b73b3f2845c2b203ded785146e72.png"></p><ul><li><strong>重要性</strong>：重要性是特征在模型中的决定能力，而不是越高就代表标签越接近1</li></ul><h2 id="在test上预测：是split分割出来的test"><a href="#在test上预测：是split分割出来的test" class="headerlink" title="在test上预测：是split分割出来的test"></a>在test上预测：是split分割出来的test</h2><pre><code>predict_test = rfc2.predict(X_test_one)#test集中的特征数据Xpred_df = pd.DataFrame(predict_test, columns=[&#39;survived&#39;])#预测结果表print(pred_df)#test集的验证结果print(&#39;随机森林 AUC...&#39;)fpr_test, tpr_test, th_test = metrics.roc_curve(predict_test, y_test_one)# 构造 roc 曲线print(&#39;AUC = %.4f&#39; %metrics.auc(fpr_test, tpr_test))#参考意义最大的就是AUCprint(&#39;随机森林精确度...&#39;)print(metrics.classification_report(predict_test, y_test_one))#精准度表格</code></pre><p><img src="https://img-blog.csdnimg.cn/04fabbe4baed47c68ad12214800bf1d0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_19,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="验证：不是split分割出来的test，而是test-csv"><a href="#验证：不是split分割出来的test，而是test-csv" class="headerlink" title="验证：不是split分割出来的test，而是test.csv"></a>验证：不是split分割出来的test，而是test.csv</h2><pre><code>data_val_dummy = pd.get_dummies(data_test[data_feature_one])#转码data_val_dummy_list = data_val_dummy.columns.tolist()print(data_val_dummy_list)#查看转码后的列名，拿着这些列名预测pred_val = rfc2.predict(data_val_dummy[[#根据上一条语句的结果，copy了列名                                        &#39;pclass&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;age&#39;,                                        &#39;fare&#39;, &#39;together_size&#39;, &#39;isSingle&#39;,                                        &#39;sex_female&#39;, &#39;sex_male&#39;, &#39;embarked_C&#39;,                                        &#39;embarked_Q&#39;, &#39;embarked_S&#39;, &#39;status_Master&#39;,                                        &#39;status_Miss&#39;, &#39;status_Mr&#39;, &#39;status_Mrs&#39;,                                        &#39;status_ohter&#39;]])pred_val_df = pd.DataFrame(pred_val, columns=[&#39;survived&#39;])print(pred_val_df.head(10))#展示前10个数据</code></pre><p><img src="https://img-blog.csdnimg.cn/348435ac3b974dfd827f256ee10998f0.png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/zjh/2022/01/03/Java%E9%9B%86%E5%90%88/"/>
      <url>/zjh/2022/01/03/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><blockquote><ul><li>集合框架被设计成要满足以下几个目标。<br></li><li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。<br></li><li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li><li>对一个集合的扩展和适应必须是简单的。</li></ul></blockquote><p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet 等,<strong>除此之外你也可以通过这些接口实现自己的集合。</strong></p><p><img src="https://img-blog.csdnimg.cn/202109060840461.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/20210906085157676.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/20210906085253299.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif"></p><p><strong>一般名为xxxxList  xxxxSet   xxxxMap的类都是集合，集合的子类非常多，本文介绍以下的集中常用集合类</strong><br>常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。</p><blockquote><p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p></blockquote><blockquote><p><strong>接口</strong>：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</p></blockquote><blockquote><p><strong>实现（类）</strong>：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</p></blockquote><blockquote><p><strong>算法</strong>：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。**(Collections类提供了排序，遍历等多种算法实现)**<br>Java 集合框架提供了一套性能优良，使用方便的接口和类，<strong>java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。</strong></p></blockquote><h1 id="线程安全和线程不安全的集合"><a href="#线程安全和线程不安全的集合" class="headerlink" title="线程安全和线程不安全的集合"></a>线程安全和线程不安全的集合</h1><p>Vector、HashTable、Properties是线程安全的；</p><p>ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap等都是线程不安全的。</p><h1 id="Collection根接口：单列集合"><a href="#Collection根接口：单列集合" class="headerlink" title="Collection根接口：单列集合"></a>Collection根接口：单列集合</h1><p>Collection下定义了很多方法：<strong>add  addAll  clear  contains  containsAll  equals  hashCode  isEmpty  iterator  parallelStream  remove  removeAll  removeIf  retainAll  size  spliterator  stream  toArray</strong>等</p><h2 id="List子接口：有序可重复"><a href="#List子接口：有序可重复" class="headerlink" title="List子接口：有序可重复"></a>List子接口：有序可重复</h2><p>有序：List的有序源于它的元素有地址值<br>List接口下的ArrayList，LinkedList都线程不安全，多线程访问时需显式同步。</p><h3 id="ArrayList实现类："><a href="#ArrayList实现类：" class="headerlink" title="ArrayList实现类："></a>ArrayList实现类：</h3><p>List接口的主要实现类<br>底层是Object[] elementData(<strong>动态可修改的数组，封装好的数组，存储地址连续</strong>)</p><ul><li>增删操作低效(底层是数组)</li><li>查找、修改效率高(有索引)</li><li>执行效率高，但线程不安全。多线程访问时需显式同步。</li></ul><h4 id="ArrayList底层分析"><a href="#ArrayList底层分析" class="headerlink" title="ArrayList底层分析"></a>ArrayList底层分析</h4><ul><li><strong>参数int capacity:</strong> 空参默认底层创建长度为10的数组，<br>JDK7之前是“饿汉”，JDK8之后是“懒汉”————JDK8后延迟底层数组创建，<em>new时底层不创建数组，当且仅当add元素后创建底层数组</em>，节约了内存</li><li><strong>扩容:</strong> 当前底层数组长度不够用时，扩容为原来的<strong>1.5倍</strong></li><li>开发中尽量带参构造，防止内存浪费</li></ul><h3 id="LinkedList实现类："><a href="#LinkedList实现类：" class="headerlink" title="LinkedList实现类："></a>LinkedList实现类：</h3><p>底层是<strong>双向链表</strong></p><ul><li>增删效率高(改变链表的next和prev地址即可，涉及的操作元素很少)</li><li>查找、修改效率低(没有索引)</li><li>执行效率高，但线程不安全。多线程访问时需显式同步。<blockquote><p>LinkedList 继承了 AbstractSequentialList 类。<br><br>LinkedList 实现了 Queue 接口，可作为队列使用。<br><br>LinkedList 实现了 List 接口，可进行列表的相关操作。<br><br>LinkedList 实现了 Deque 接口，可作为队列使用。<br><br>LinkedList 实现了 Cloneable 接口，可实现克隆。<br><br>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。</p></blockquote></li></ul><h2 id="Set子接口：无序不可重复"><a href="#Set子接口：无序不可重复" class="headerlink" title="Set子接口：无序不可重复"></a>Set子接口：无序不可重复</h2><p>因为无序，所以不能重复，类似于高中所学的“集合”<br><br>开发中Set接口用的不太多，一般用List和Map更多</p><ul><li>Set没有额外定义方法，所有方法和Collection根接口定义的相同</li><li><strong>无序性</strong>：不是随机，而是add时由数据的哈希值决定存储位置，对外“相对无序”<br></li><li><strong>不可重复性</strong>：add时先调用hashcode方法算哈希值，不相等则直接add；若有相同的哈希值，则进行equals方法比对细节，若还相等，则add方法返回false，添加失败</li></ul><h3 id="HashSet实现类"><a href="#HashSet实现类" class="headerlink" title="HashSet实现类"></a>HashSet实现类</h3><p>底层是<strong>哈希表</strong>(元素为链表的数组)</p><ul><li>效率高，但线程不安全。多线程访问时需显式同步。</li><li>可以存储一个null值并分配空间</li><li>遍历无序，每次遍历输出的顺序都可能不同</li></ul><h4 id="LinkedHashSet实现类"><a href="#LinkedHashSet实现类" class="headerlink" title="LinkedHashSet实现类"></a>LinkedHashSet实现类</h4><ul><li>LinkedHashSet是HashSet的一个子类<br>底层是<strong>哈希表+链表</strong>(链表可以保证元素的顺序透明)</li><li>遍历时会<strong>按照添加进来的顺序进行遍历</strong><blockquote><p>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p></blockquote></li><li><em>LinkedHashSet在迭代访问（遍历）Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</em>*<br><br><br>在开发中由需求决定具体使用哪个</li></ul><blockquote><ul><li>补充：去除List中重复元素的方法：把List对象扔给LinkedHashSet的构造器形参</li></ul></blockquote><h3 id="TreeSet实现类（用的少）"><a href="#TreeSet实现类（用的少）" class="headerlink" title="TreeSet实现类（用的少）"></a>TreeSet实现类（用的少）</h3><p>SortedSet接口的唯一实现类，<strong>自排序</strong>的集合<br><br>底层是<strong>红黑树</strong>(自平衡的二叉树)</p><ul><li><strong>自排序</strong>：存储元素的类必须实现Comparable接口或Comparator接口<br><br>  并且为了保证可以排序，<strong>后续add的所有元素必须跟第一个add的元素类型相同</strong>，否则报错ClassCastException</li><li><strong>包装类的自排序</strong>：由于包装类都实现了Comparable自然排序，所以包装类元素可以直接扔进TreeSet</li><li>自定义类需先实现排序接口才能扔进TreeSet</li></ul><h1 id="Map根接口"><a href="#Map根接口" class="headerlink" title="Map根接口"></a>Map根接口</h1><p>双列数据，存储键值对，类似高中函数y=f(x)<br>key:无序、不可重复——&gt;Set储存<br>value:无序、可重复——&gt;Collection储存</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><a href="https://zhuanlan.zhihu.com/p/78079598">链接：HashMap底层原理</a></p><p>散列表</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="/zjh/2022/01/02/Java%E6%B3%9B%E5%9E%8B/"/>
      <url>/zjh/2022/01/02/Java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Java 泛型（generic）是 JDK 5 中引入的一个新特性, 泛型提供了<strong>编译时</strong>类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>泛型设计背景：集合容器类在设计/声明的时候不能确定到底是存储什么类型的元素，但对元素如何存储，如何使用都是清楚的，唯一不确定的是元素的类型，因此在JDK1.5的时候引入了泛型来解决这个问题；把元素的类型设置为一个参数，这个参数就叫泛型：Collection<E>  List<E>  Map<E>这个E就是类型参数，即泛型；</p><p>什么时候使用：设计时只设计用法不考虑类型，使用时必须确定类型</p><p>正如ArrayList<String>表示的含义即为：只能存储String类型元素的ArrayList集合</p><h1 id="1-0泛型使用特点"><a href="#1-0泛型使用特点" class="headerlink" title="1.0泛型使用特点"></a>1.0泛型使用特点</h1><p>在<strong>编译之后程序会采取<u>去泛型化</u>的措施</strong>。也就是说Java中的泛型，<u>只在编译阶段有效</u>。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出（<strong>类型擦除</strong>），并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><h2 id="1-1符号"><a href="#1-1符号" class="headerlink" title="1.1符号"></a>1.1符号</h2><p>常用的通配符有T,E,K,V分别表示类型、元素、键、值，当然这并不是硬性规定，而是大家形成的一种通识。</p><h2 id="1-2规范"><a href="#1-2规范" class="headerlink" title="1.2规范"></a>1.2规范</h2><p>泛型只能是类，不能是基本数据类型：int(×) Integer(√)</p><p>定义了泛型之后，在编译期也要受泛型的约束，从而在某些情况可以避免强转操作</p><p>方法中不是出现<E>就一定是泛型方法，详见</p><p>类上声明的泛型<T>和类中又声明的泛型<E>是两回事</p><h1 id="2-0泛型的声明与指定"><a href="#2-0泛型的声明与指定" class="headerlink" title="2.0泛型的声明与指定"></a>2.0泛型的声明与指定</h1><p><a href="https://www.cnblogs.com/GGYC/p/10951794.html?ivk_sa=1024320u">链接：泛型的使用场景</a></p><h2 id="2-1类上声明"><a href="#2-1类上声明" class="headerlink" title="2.1类上声明"></a>2.1类上声明</h2><p>声明在类上时，写在类名后边；作为参数或者返回值时，如果在类上没有声明，必须在访问修饰符和返回值之间</p><pre><code>/** * 声明在类上时，写在类名后边 * @param &lt;E&gt; */class Animal &lt;E&gt; &#123;    /**     * 作为属性声明时，必须在类上声明泛型     */    E pet;     /**     * 作为参数或者返回值时，如果在类上没有声明，必须在访问修饰符和返回值之间     * @param pet     */    public  void setPet(E pet)&#123;        this.pet = pet;    &#125;     public E getPet()&#123;        return pet;    &#125;//这里的T在泛型类中没有声明，所以要在泛型方法中&lt;T&gt;声明为泛型方法    public &lt;T&gt; void call(T t)&#123;        System.out.println( t.toString() );     &#125; &#125;</code></pre><h2 id="2-2接口声明、子类声明和指定"><a href="#2-2接口声明、子类声明和指定" class="headerlink" title="2.2接口声明、子类声明和指定"></a>2.2接口声明、子类声明和指定</h2><p>使用泛型实现时，实现类必须使用对应的泛型类。<br>实现类声明泛型跟接口指定泛型可以同时使用。（“声明”“指定”互不影响）</p><pre><code>/** * 作用在接口上，如果实现该接口时指定实现类型 * @param &lt;T&gt; */public interface Animals&lt;T&gt;&#123;    double PI = 3.1415926535;//等价于public static final double PI = 3.1415926535;    void call(T t);//等价于public abstract void call(T t);&#125;/** * 拉布拉多犬 */ /** * 使用泛型实现时，实现类必须使用对应的泛型类。 * 实现类声明泛型跟接口指定泛型可以同时使用。 *如下代码： */ class LaBuLaDuo&lt;T&gt; implements Animals&lt;String&gt; &#123;//&lt;T&gt;是声明新泛型  &lt;String&gt;是指定旧泛型     public void call(String s) &#123;        System.out.println( s );    &#125; &#125;</code></pre><h2 id="2-3泛型通配符？-上限与下限"><a href="#2-3泛型通配符？-上限与下限" class="headerlink" title="2.3泛型通配符？ 上限与下限"></a>2.3泛型通配符？ 上限与下限</h2><p>泛型占位符  ?  的使用<br>如何设置泛型的上限下限</p><p>上限：泛型为E或者E的子类：&lt;? extends E&gt;</p><p>下限：泛型为E或者E的父类：&lt;? super E&gt;</p><p>单独使用：泛型为Object及其子类：&lt;?&gt;</p><pre><code>/** * 小狗狗 */ class Dog extends  Animal &#123;    public String name;    public Integer age; &#125;  /** * 泛型占位符  ?  的使用 * 泛型的上限 &lt; ? extends E&gt;  即传入参数必须为E 的子类 * 泛型的下限 &lt; ? super E&gt; */public class ErHa &lt;E&gt;  &#123;     //当参数传递时可以设置上下限 比如下面的是  传入类型必须是 Dog 的子类，上限为Dog    public  void call(Animal&lt; ? extends E&gt; s)&#123;        System.out.println(s.pet);    &#125;     //传入类型必须是 Dog 的父类，下限为Dog    public  void jump(Animal&lt; ? super E&gt; s)&#123;        System.out.println(s.pet);    &#125;     // ? 占位符单独使用时，相当于 &lt; ? extends Object &gt;    public  void smile(Animal&lt;?&gt; s)&#123;        System.out.println(s.pet);    &#125;      public static void main(String[] args) &#123;        new ErHa&lt;Dog&gt;().call(new Dog());    &#125;&#125;</code></pre><h2 id="2-4上下边界的测试和get-set限制及解释"><a href="#2-4上下边界的测试和get-set限制及解释" class="headerlink" title="2.4上下边界的测试和get set限制及解释"></a>2.4上下边界的测试和get set限制及解释</h2><pre><code>class plate&lt;T&gt;&#123;    private T t;    public plate(T t)&#123;        this.t = t;    &#125;    public  void set(T t)&#123;//测试1        this.t = t;    &#125;    public T get()&#123;        return t;    &#125;&#125;  class Food&#123;&#125;class Furit extends Food&#123;&#125;class Apple extends Furit&#123;&#125;class Banana extends Furit&#123;&#125;   /*************下面测试上下边界通配符***************/         //1.0 extends 通配符上界        plate&lt;? extends Furit&gt; p10 = new plate&lt;Furit&gt;(new Apple());        plate&lt;? extends Furit&gt; p11 = new plate&lt;Banana&gt;(new Banana());        p10 = p11;        p11 = p10;        //上述例子中，&lt;? extends Furit&gt;表示“该盘子可以装Furit包括Furit的所有子类”        //2.0 super 通配符下界(注意第二个&lt;&gt;中的细微差别)        plate&lt;? super Furit&gt; p12 = new plate&lt;Furit&gt;(new Apple());        plate&lt;? super Furit&gt; p13 = new plate&lt;Furit&gt;(new Banana());//        p13.set(new Food());        p13.set(new Furit());        plate&lt;? super Furit&gt; p14 = new plate&lt;Food&gt;(new Food());        plate&lt;? super Furit&gt; p15 = new plate&lt;Furit&gt;(new Furit());        p12 = p13;        p13 = p14;        p14 = p15;        //上述例子中，&lt;? super Furit&gt;表示“该盘子可以装Fuirt包括Fuirt的所有父类”        //并且可知：当指定了泛型时，可以装入泛型的实例化子类          /************通配符？有get和set的限制规则**************/        //p10 p11是extends通配符上界，p12~p15是super通配符上界 //        p10.set(new Apple());即便是同类型也报错//        p15.get(0);  不能获取，报错        p10.get();        p15.set(new Furit());//? extends xxx只能调用get不能调用set//? super xxx只能调用set不能调用get        /*********问：为什么有这样的限制呢*************/        /**答：         * 首先明确一点，创建的plate对象具体存储什么由左右两边共同决定，set和get方法都会受二者的影响         * 具体就是左边的&lt;&gt;限制右边的&lt;&gt;,而右边的&lt;&gt;决定最终存储的类型         *  1，plate&lt;? extends Furit&gt; p10 = new plate&lt;Apple&gt;(new Apple());确定了通配符？,该plate能存储Apple及其子类的实例         *  ~1.1，不能使用set()的原因：         *  从结构出发，左边部分plate&lt;? extends Furit&gt; p10：决定了p10只能接受Furit及其子类Apple或Banana         *  编译看左：&lt;? extends Furit&gt;         *  假设set()可以使用，编译器只能识别set(形参)中是否为“new了一个Furit及其子类的形参”         *  运行看右：&lt;Apple&gt;         *  而右边部分new plate&lt;Apple&gt;(new Apple())一开始就确定了p10只能放Apple         *  倘若可以使用set(new Banana())，由于Banana也是Furit子类，编译器无法判断错误，但运行则会出错         *  因此编译器直接取消了上边界extends中的set方法         *         *  ~1.2而对于get()方法，则没有限制，因为返回值一定是由右边new plate&lt;Apple&gt;(new Apple())所决定的Apple类型,         *      即使是依据左边来盛放返回值，Furit getback = p.get();也是一定可以的         *         * 2，plate&lt;? super Furit&gt; p12 = new plate&lt;Food&gt;(new Apple());右边的&lt;&gt;中必须填Furit或者Food         *  ~2.1不能使用get()的原因：         *  从结构出发，左边部分plate&lt;? super Furit&gt; p12：决定了p12只能接受Furit及其父类Food         *  编译看左，运行看右：         *  假设get()方法可以使用，那么get的返回值用什么接收呢？         *  Furit getback = p12.get();运行时不一定正确         *  Food getback = p12.get();运行时也不一定正确         *  只有超类Object getback = p12.get();才能一定不报错         *  因此继续假设get返回值用Object存储         *  但是这样就使用不了除Object以外的任何方法，并且本身还很容易出错         *  因此编译器直接取消了下边界super中的get方法         *  ~2.2         *  而对于set()方法，则没有限制，因为形参中只要满足右边的&lt;&gt;即可         *         *         */</code></pre><h1 id="3-0自定义结构的泛型"><a href="#3-0自定义结构的泛型" class="headerlink" title="3.0自定义结构的泛型"></a>3.0自定义结构的泛型</h1><p>（结构包括：类、接口、方法）</p><h2 id="3-1自定义类、接口的泛型"><a href="#3-1自定义类、接口的泛型" class="headerlink" title="3.1自定义类、接口的泛型"></a>3.1自定义类、接口的泛型</h2><pre><code>plate p1 = new plate(new Apple());        plate p2 = new plate(new Banana());        p1 = p2;        /*1.0因为省略了泛型，默认泛型T为Object，        该plate盘子可以装所有Object及其子类，所以p1可以转化为p2*/         plate&lt;Food&gt; p3 = new plate&lt;&gt;(new Apple());        plate&lt;Food&gt; p4 = new plate&lt;&gt;(new Banana());        p3 = p4;        p4 = p3;        /*2.0表示该盘子plate可以装Food及其子类，因此可以相互转化*/         plate&lt;Furit&gt; p5 = new plate&lt;&gt;(new Apple());        plate&lt;Furit&gt; p6 = new plate&lt;&gt;(new Banana());        p5 = p6;        p6 = p5;        /*3.0表示盘子可以装Furit及其子类，因此也能相互转化*/         plate&lt;Apple&gt; p7 = new plate&lt;&gt;(new Apple());        /*4.0表示p7盘子只能装Apple及其子类，只有Apple及其子类的盘子可以相互转化*///        plate&lt;Apple&gt; p8 = new plate&lt;&gt;(new Banana());泛型确定为Apple，所以不能赋值Banana        plate&lt;Banana&gt; p8 = new plate&lt;&gt;(new Banana());//        p7 = p8;泛型不同不能相互转化        /*4.1表示p8盘子只能装Banana及其子类，只有Banana及其子类的盘子可以相互转化*/</code></pre><h2 id="自定义方法的泛型"><a href="#自定义方法的泛型" class="headerlink" title="自定义方法的泛型"></a>自定义方法的泛型</h2><pre><code>泛型方法与所处类是否泛型无关只有在public之后跟上&lt;&gt;的才是泛型方法，使用时    public &lt;T&gt; ArrayList&lt;T&gt; arrayToList(T... arr) &#123;        //泛型方法与所处类是否泛型无关        //只有在public之后跟上&lt;&gt;的才是泛型方法，使用时如下        ArrayList&lt;T&gt; DestArr = new ArrayList&lt;&gt;();       for(T t:arr)&#123;           DestArr.add(t);       &#125;//foreach循环中每个t都代表对应的arr[i]        return DestArr;    &#125;</code></pre><h1 id="继承与泛型"><a href="#继承与泛型" class="headerlink" title="继承与泛型"></a>继承与泛型</h1><p>类A&lt;父类&gt;和 类A&lt;子类&gt;是不能相互转化的<br>        //要想实现这种转化，必须使用通配符? 利用上下边界通配符解决</p><pre><code>       plate p1 = new plate(new Apple());        plate p2 = new plate(new Banana());        p1 = p2;        /*1.0因为省略了泛型，默认泛型T为Object，        该plate盘子可以装所有Object及其子类，所以p1可以转化为p2*/         plate&lt;Food&gt; p3 = new plate&lt;&gt;(new Apple());        plate&lt;Food&gt; p4 = new plate&lt;&gt;(new Banana());        p3 = p4;        p4 = p3;        /*2.0表示该盘子plate可以装Food及其子类，因此可以相互转化*/         plate&lt;Furit&gt; p5 = new plate&lt;&gt;(new Apple());        plate&lt;Furit&gt; p6 = new plate&lt;&gt;(new Banana());        p5 = p6;        p6 = p5;        /*3.0表示盘子可以装Furit及其子类，因此也能相互转化*/         plate&lt;Apple&gt; p7 = new plate&lt;&gt;(new Apple());        /*4.0表示p7盘子只能装Apple及其子类，只有Apple及其子类的盘子可以相互转化*///        plate&lt;Apple&gt; p8 = new plate&lt;&gt;(new Banana());泛型确定为Apple，所以不能赋值Banana        plate&lt;Banana&gt; p8 = new plate&lt;&gt;(new Banana());//        p7 = p8;泛型不同不能相互转化        /*4.1表示p8盘子只能装Banana及其子类，只有Banana及其子类的盘子可以相互转化*/         /*************下面测试继承关系***********///        p3 = p5;//        p5 = p3;//        p5 = p7;//以上这种看似继承却不能转化，因为编译器不认同泛型有继承多态性        //即：类A&lt;父类&gt;和 类A&lt;子类&gt;是不能相互转化的        //要想实现这种转化，必须使用通配符? 利用上下边界通配符解决</code></pre><h1 id="实例化规律"><a href="#实例化规律" class="headerlink" title="实例化规律"></a>实例化规律</h1><pre><code>plate&lt;前面的泛型&gt; p = new plate&lt;后面的泛型&gt;(new 泛型对象);对于这样一个实例化语句，一般只有如下两种情况plate&lt;甲&gt; p = new plate&lt;甲&gt;(new 甲或甲的子类);plate&lt;甲&gt; p = new plate&lt;  &gt;(new 甲或甲的子类);//后面的泛型可以省略plate&lt;? extends 甲&gt; = new plate&lt;甲或甲的子类：记作乙&gt;(new 乙或乙的子类);//但如果使用了通配符？，那么后面的泛型必须先指定，不能省略</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>决策树/随机森林——用户流失预测的案例</title>
      <link href="/zjh/2022/01/01/%E5%86%B3%E7%AD%96%E6%A0%91-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E6%B5%81%E5%A4%B1%E9%A2%84%E6%B5%8B%E7%9A%84%E6%A1%88%E4%BE%8B/"/>
      <url>/zjh/2022/01/01/%E5%86%B3%E7%AD%96%E6%A0%91-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E6%B5%81%E5%A4%B1%E9%A2%84%E6%B5%8B%E7%9A%84%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p><strong>摘要</strong>：<br><br>从决策树的定义，优缺点等宏观角度入题，逐步从数学原理过渡到代码实现，最后总结</p><p><strong>关键词</strong>:<br><br>决策树、信息熵、基尼系数、ID3、CART</p><h2 id="决策树是什么"><a href="#决策树是什么" class="headerlink" title="决策树是什么"></a>决策树是什么</h2><blockquote><p>一个根节点，若干个内部节点和叶节点<br><br> 非参数学习算法<br><br> 天然的分类器<br></p></blockquote><h2 id="决策树的目标"><a href="#决策树的目标" class="headerlink" title="决策树的目标"></a>决策树的目标</h2><p>解决<strong>分类</strong>和<strong>回归</strong>问题</p><h2 id="决策树的优点"><a href="#决策树的优点" class="headerlink" title="决策树的优点"></a>决策树的优点</h2><blockquote><ul><li>决策树易于理解和实现，人们在在学习过程中不需要使用者了解很多的背景知识，这同时是它的能够直接体现数据的特点，只要通过解释后都有能力去理解决策树所表达的意义。</li><li>对于决策树，数据的准备往往是简单或者是不必要的，而且能够同时处理数据型和常规型属性，在相对短的时间内能够对大型数据源做出可行且效果良好的结果。</li><li>准确性高: 挖掘出来的分类规则准确性高, 便于理解, 决策树可以清晰的显示哪些字段比较重要, 即可以生成可以理解的规则.</li><li>适合处理有缺失属性的样本，对缺失值不敏感</li></ul></blockquote><h2 id="决策树的缺点"><a href="#决策树的缺点" class="headerlink" title="决策树的缺点"></a>决策树的缺点</h2><blockquote><ul><li>容易发生过拟合（剪枝 随机森林）</li><li>分类过程中每一步都依据单一特征，忽视了特征之间的关联性，在处理特征关联性强的数据时表现不好</li><li>对于样本不均衡的数据集表现不好，欠拟合。在特征选择时ID3算法偏好于选取可取值数目较多的属性,C4.5算法偏向选取可取值数目较少的属性（实际中是在算法中采用启发式原则，先从候选属性中选出信息增益高于平均水平的属性，再从中选择增益率最高的属性）</li></ul></blockquote><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>根据<strong>信息熵</strong>(entropy) or <strong>基尼系数</strong>(gini)的大小决定下一个节点怎么分枝，最后生成决策树，而<strong>随机森林</strong>就是多个决策树的组合</p><h2 id="信息熵entropy"><a href="#信息熵entropy" class="headerlink" title="信息熵entropy"></a>信息熵entropy</h2><p><a href="https://www.zhihu.com/search?q=yjango%E4%BF%A1%E6%81%AF%E7%86%B5&utm_content=search_suggestion&type=content">超链接：Yjango:什么是信息熵？</a></p><p><em>熵在信息论中代表随机变量的不确定性的度量</em></p><p>熵越小，数据不确定性越低<br>熵越大，数据不确定性越高</p><p>信息熵<br>H=$-\displaystyle \sum^{k}_{i = 1}{Pi}$${log_2{(Pi)}}$</p><h2 id="基尼系数"><a href="#基尼系数" class="headerlink" title="基尼系数"></a>基尼系数</h2><ul><li>基尼值<br>G = 1 $-\displaystyle \sum^{k}_{i = 1}{Pi^2}$</li></ul><p>以基尼指数为指标时，应该选择Gini指数最<strong>小</strong>的</p><p>CART决策树使用“基尼指数”来选择划分属性</p><ul><li>  基尼指数<br>G_index = $-\displaystyle \sum^{V}_{v = 1}{\frac{|D^v|}{|D|}Gini(D^v)}$</li></ul><p><strong>基尼指数到0时，即到叶节点，不能再往下划分</strong></p><h2 id="AUC-ROC-tpr-fpr"><a href="#AUC-ROC-tpr-fpr" class="headerlink" title="AUC ROC tpr fpr"></a>AUC ROC tpr fpr</h2><ul><li>tpr：Recall，召回率，即当前被分到正样本类别中，真实的正样本占所有正样本的比例，即召回率（召回了多少正样本比例）</li><li>fpr：Precision，正例率，即当前划分到正样本类别中，被正确分类的比例（即正式正样本所占比例），就是我们一般理解意义上所关心的正样本的分类准确率；</li><li>ROC：tpr和fpr决定的曲线</li><li>AUC：ROC曲线下包围的面积，最大值为1，越大拟合性能越好</li></ul><h2 id="过拟合的原因及如何防止"><a href="#过拟合的原因及如何防止" class="headerlink" title="过拟合的原因及如何防止"></a>过拟合的原因及如何防止</h2><p>对于过拟合现象产生的原因，有以下几个方面，</p><blockquote><ul><li>第一：在决策树构建的过程中，对决策树的生长没有进行合理的限制（<strong>剪枝</strong>）；</li><li>第二：在建模过程中使用了<strong>较多的输出变量</strong>，变量较多也容易产生过拟合；</li><li>第三：样本中有一些<strong>噪声数据</strong>，噪声数据对决策树的构建的干扰很多，没有对噪声数据进行有效的剔除。</li></ul></blockquote><p>对于过拟合现象的预防措施，有以下一些方法，</p><blockquote><ul><li>第一：选择合理的参数进行<strong>剪枝</strong>，可以分为预剪枝后剪枝，我们一般用后剪枝的方法来做；</li><li>第二：<strong>K-folds交叉验证</strong>，将训练集分为K份，然后进行K次的交叉验证，每次使用K-1份作为训练样本数据集，另外的一份作为测试集合（作者说反了，应该是份作为测试集，其余k-1份作为训练集）；</li><li>第三：减少特征，计算每一个特征和相应变量的<strong>相关性</strong>，常见的为皮尔逊相关系数，将相关性较小的变量剔除，当然还有一些其他的方法来进行特征筛选，比如基于决策树的特征筛选，通过正则化的方式来进行特征选取等。</li></ul></blockquote><h2 id="预剪枝：生成决策树的过程中剪枝"><a href="#预剪枝：生成决策树的过程中剪枝" class="headerlink" title="预剪枝：生成决策树的过程中剪枝"></a>预剪枝：生成决策树的过程中剪枝</h2><pre><code>基于“贪心”本质，能剪则剪。</code></pre><p>如果某个分支的存在并没有提高准确率，or降低了准确率，则剪掉</p><blockquote><p>降低了过拟合风险；<br><br>显著减少了决策树训练时间；<br><br>但带来了欠拟合的风险</p></blockquote><h2 id="后剪枝：生成决策树之后剪枝"><a href="#后剪枝：生成决策树之后剪枝" class="headerlink" title="后剪枝：生成决策树之后剪枝"></a>后剪枝：生成决策树之后剪枝</h2><pre><code>能不剪，则不剪，剪前后若准确率相等，则保留</code></pre><blockquote><p>同样的训练模型，后剪枝的决策树保留了更多的分支<br><br>后剪枝的欠拟合风险很小<br><br>泛化性能往往优于预剪枝(分的更细，在面对陌生数据时判断更准确)<br><br>训练时间长的多(生成决策树之后需要自底向上逐一考察，计算开销大)<br></p></blockquote><pre><code>“在有噪声的情况下，剪枝操作甚至能将泛化性能提高25%”</code></pre><h2 id="连续值：可取连续值的属性"><a href="#连续值：可取连续值的属性" class="headerlink" title="连续值：可取连续值的属性"></a>连续值：可取连续值的属性</h2><p>例如：脐部{凹陷，平坦，稍凹}这种是离散值；而密度，xx含量等很多属性值都是连续的</p><p>因此在划分分支的时候，需要有一个间断点</p><p>间断点的划分方法：二分法，例如有17个排序后的点集，两两之间算中位数，一共算16次，生成16个t值，组成一个t的集合T，用T中的划分点代入Gain算法，计算Gain(D，该属性，t为划分点)，取Gain最大值，对应的t即为最终确定的划分点<br>划分完t之后，如果子分支还需用到更细的判断， 可以使用t的子集：例如：一个节点判断“密度&lt;=0.381”那么后续的子节点可以使用任何”密度&lt;0.381”范围的判断依据</p><h2 id="缺失值：某些数据的其中某个数据缺失，若全部弃用则会很浪费"><a href="#缺失值：某些数据的其中某个数据缺失，若全部弃用则会很浪费" class="headerlink" title="缺失值：某些数据的其中某个数据缺失，若全部弃用则会很浪费"></a>缺失值：某些数据的其中某个数据缺失，若全部弃用则会很浪费</h2><p>属性a缺失值处理方法：</p><p>西瓜书上p88：跳过该属性a的判断，直接判断下一节点的所有可能性，但需要加上训练集中的比例权重</p><pre><code>(离散值)：众数填充、相关性最高的列(属性b总是与属性a的取值几乎一一对应)填充(连续值)：中位数、相关性最高的列(同上)做线性回归估计</code></pre><h2 id="多变量决策树：用线性关系替代多个变量"><a href="#多变量决策树：用线性关系替代多个变量" class="headerlink" title="多变量决策树：用线性关系替代多个变量"></a>多变量决策树：用线性关系替代多个变量</h2><p>有些属性之间有一定的线性关系，例如：密度和含糖量之间存在着线性关系，那么就把密度和含糖量分别乘上各自的权重系数，用他俩组成的一个式子&lt;=t 或 &gt;=t 作为分界点来判断</p><pre><code>多变量决策树算法：贪心寻找每个属性的最优权值，线性分类器的最小二乘法</code></pre><h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>擅长于解决数据不平衡的分类</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1，导包"><a href="#1，导包" class="headerlink" title="1，导包"></a>1，导包</h3><pre><code>import pandas as pdimport numpy as np</code></pre><h3 id="2，读取、初步查看分析数据"><a href="#2，读取、初步查看分析数据" class="headerlink" title="2，读取、初步查看分析数据"></a>2，读取、初步查看分析数据</h3><pre><code>df = pd.read_csv(&#39;broadband.csv&#39;)df.rename(str.lower, axis=&#39;columns&#39;, inplace=True)#列名全换小写，方便看print(df.head())#空参则显示前5行数据# broadband 即可：0-离开(否)，1-留存(是)df.info() #输出行列信息（总体数据特征）print(df.sample()) # 随机查看一个样本数据# 查看因变量 broadband 分布情况，看是否存在不平衡from collections import Counterprint(&#39;Broadband: &#39;, Counter(df[&#39;broadband&#39;]))     #输出结果是Broadband:  Counter(&#123;0: 131, 1: 49&#125;)，数据并不平衡</code></pre><p><img src="https://img-blog.csdnimg.cn/6a2b7fea48b04223b402fb145f80d793.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="前5行信息and随机查看样本数据"></p><p><img src="https://img-blog.csdnimg.cn/30820d3df1b24efb98664f1347d2109d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_19,color_FFFFFF,t_70,g_se,x_16" alt="info输出信息"></p><h3 id="3，划分训练集-测试集"><a href="#3，划分训练集-测试集" class="headerlink" title="3，划分训练集 测试集"></a>3，划分训练集 测试集</h3><p>由于步骤2中info()发现数据集的第一列是用户ID，最后一列是判断标准Broadband，故这两列都不用做数据分析</p><pre><code>y = df[&#39;broadband&#39;] # y就是标签(结果)X = df.iloc[:, 1:-1] # 客户 id 没有用，故丢弃 cust_id；标签y也要去掉，故1：-1#左边冒号左右端为空，表示所有行数据全部都取到X中from sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4, random_state=123)#40%划分为test集，# 这里的random_state就是为了保证程序每次运行都分割一样的训练集和测试集。# 否则，同样的算法模型在不同的训练集和测试集上的效果不一样。# 因此具体取值多少无所谓，但对结果有影响</code></pre><h3 id="4，决策树建模"><a href="#4，决策树建模" class="headerlink" title="4，决策树建模"></a>4，决策树建模</h3><h4 id="网格搜索："><a href="#网格搜索：" class="headerlink" title="网格搜索："></a>网格搜索：</h4><p>因为决策树算法是非参数学习算法，需要自行调参，利用网格搜索则可以自动调参，择优选取<br><br>把自己认为好的参数都扔进去，让网格搜索自己跑</p><pre><code>import sklearn.tree as tree# 1. 直接使用交叉网格搜索来优化决策树模型，边训练边优化from sklearn.model_selection import GridSearchCV# 2. 网格搜索参数，选择最优参数,该param_grid作为评价指标用于下面的训练模型param_grid = &#123;&#39;criterion&#39;: [&#39;entropy&#39;, &#39;gini&#39;], # 树的深度评估指标,信息熵or基尼            &#39;max_depth&#39;: [2, 3, 4, 5, 6, 7, 8], # 可选树的深度            &#39;min_samples_split&#39;: [4, 8, 12, 16, 20, 24, 28]&#125; # 可选最小拆分的叶子样本数</code></pre><h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><pre><code># 3. 定义一棵树对象clf = tree.DecisionTreeClassifier()  # 4. 传入模型，网格搜索的参数，评估指标，cv交叉验证的次数clfcv = GridSearchCV(estimator=clf, param_grid=param_grid, scoring=&#39;roc_auc&#39;,cv=4) # roc曲线和auc面积值作为评价标准（一般都用auc直接比较面积）# cv=？表示交叉验证的次数# 5. 训练模型clfcv.fit(X_train, y_train)# 6. 使用模型来对测试集进行预测test_result = clfcv.predict(X_test)</code></pre><h4 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h4><pre><code># 7. 模型评估import sklearn.metrics as metricsprint(&quot;决策树 AUC:&quot;)fpr_test, tpr_test, th_test = metrics.roc_curve(y_test, test_result)#主要是为了得到fpr，tpr，代入AUC计算公式print(&#39;AUC = %.4f&#39; %metrics.auc(fpr_test, tpr_test))#输出AUC的值print(&quot;决策树准确度:&quot;)print(metrics.classification_report(y_test,test_result))#输出准确度表格，参考价值不是很大，一般还是以AUC为准# 9. 求网格搜索后的最优参数print(clfcv.best_params_)#输出最优参数组合，但这个最优并非完全最优，可能还需要在开始的地方再重新调参，可能#算出的最后参数结果还不同#假设“最小样本设置&#123;4，5，6，7，8&#125;”，而最优结果是4 或 8，处于边缘，#就需要往边缘调参#因为该样本结果是：#&#123;&#39;criterion&#39;: &#39;entropy&#39;, &#39;max_depth&#39;: 3, &#39;min_samples_split&#39;: 12&#125;#都不是设置的边缘只，所以可以认为这些参数还不错，暂时不调参</code></pre><p><img src="https://img-blog.csdnimg.cn/16e8639fe87447e1b9f205219401708c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="决策树AUC" title="决策树AUC"></p><h3 id="5，决策树生成"><a href="#5，决策树生成" class="headerlink" title="5，决策树生成"></a>5，决策树生成</h3><h4 id="选择最优参数重新训练"><a href="#选择最优参数重新训练" class="headerlink" title="选择最优参数重新训练"></a>选择最优参数重新训练</h4><pre><code># 将最优参数代入到模型中，重新训练、预测#&#123;&#39;criterion&#39;: &#39;entropy&#39;, &#39;max_depth&#39;: 3, &#39;min_samples_split&#39;: 12&#125;clf2 = tree.DecisionTreeClassifier(criterion=&#39;entropy&#39;, max_depth=3, min_samples_split=12)clf2.fit(X_train, y_train)test_res2 = clf2.predict(X_test)</code></pre><h4 id="绘制决策树，在同目录下生成pdf"><a href="#绘制决策树，在同目录下生成pdf" class="headerlink" title="绘制决策树，在同目录下生成pdf"></a>绘制决策树，在同目录下生成pdf</h4><pre><code>#  绘制图形 pip3 install graphvizimport graphvizdot_data = tree.export_graphviz(clf2, out_file=None)graph = graphviz.Source(dot_data)graph.render(&#39;决策树&#39;)#生成文件名为决策树的pdf图片</code></pre><p><img src="https://img-blog.csdnimg.cn/bac26eaf8ba04751a8308ddf86301246.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="决策树生成" title="决策树生成"></p><h2 id="随机森林-1"><a href="#随机森林-1" class="headerlink" title="随机森林"></a>随机森林</h2><p>由于上述决策树生成的AUC值还不到0.7，认为拟合效果不够好，因此尝试使用随机森林算法</p><h3 id="1-网格搜索"><a href="#1-网格搜索" class="headerlink" title="1,网格搜索"></a>1,网格搜索</h3><pre><code>param_grid = &#123;    &#39;criterion&#39;:[&#39;entropy&#39;,&#39;gini&#39;],# 衡量标准    &#39;max_depth&#39;:[5, 6, 7, 8],    # 每棵决策树的深度    &#39;n_estimators&#39;:[11,13,15],  # 决策树个数 - 随机森林特有参数    &#39;max_features&#39;:[0.3,0.4,0.5], # 每棵决策树使用的变量占比 - 随机森林特有参数    &#39;min_samples_split&#39;:[4,8,12,16]  # 叶子的最小拆分样本量&#125;</code></pre><h3 id="2-集成学习：随机森林训练"><a href="#2-集成学习：随机森林训练" class="headerlink" title="2,集成学习：随机森林训练"></a>2,集成学习：随机森林训练</h3><pre><code>import sklearn.ensemble as ensemble # ensemble learning: 集成学习rfc = ensemble.RandomForestClassifier()rfc_cv = GridSearchCV(estimator=rfc, param_grid=param_grid,                    scoring=&#39;roc_auc&#39;, cv=4)rfc_cv.fit(X_train, y_train)</code></pre><h3 id="3-使用随机森林对结果预测，并求AUC（一般都高于决策树）"><a href="#3-使用随机森林对结果预测，并求AUC（一般都高于决策树）" class="headerlink" title="3,使用随机森林对结果预测，并求AUC（一般都高于决策树）"></a>3,使用随机森林对结果预测，并求AUC（一般都高于决策树）</h3><pre><code>predict_test = rfc_cv.predict(X_test)#训练，预测结束之后，方可查看最佳参数配置print(rfc_cv.best_params_)#输出AUC和精度表格print(&#39;随机森林 AUC...&#39;)fpr_test, tpr_test, th_test = metrics.roc_curve(predict_test, y_test) # 构造 roc 曲线print(&#39;AUC = %.4f&#39; %metrics.auc(fpr_test, tpr_test))print(&#39;随机森林精确度...&#39;)print(metrics.classification_report(predict_test, y_test))</code></pre><p><img src="https://img-blog.csdnimg.cn/f0a64f28f5004c82bc2914efde97415c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="随机森林AUC结果"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>调参的思想类似于高中生物实验探究题中的 <strong>“寻找最佳浓度”</strong></p><p>衡量决策树 or 随机森林 <strong>模型好坏的标准一般用AUC的值来判断</strong></p><p><strong>非参数学习一般都用网格搜索</strong><br><br>例如在进行网格搜索时，有很多参数，哪怕最优结果表明只需要调整一个参数，调整之后其他最优结果可能也会改变（牵一发动全身）<br><em>当然，如果电脑性能足够好，可以直接放很多参数去跑，省去了大量的调参花费的精力</em></p><p><strong>网格搜索的参数范围一开始要间隔比较大才好</strong></p><p>其他参数相同时，同一个 random_state=？保证了算出来的结果相同</p><h1 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h1><h2 id="树模型的参数"><a href="#树模型的参数" class="headerlink" title="树模型的参数"></a>树模型的参数</h2><pre><code># # -  1.criterion  gini  or  entropy# # -  2.splitter  best or random 前者是在所有特征中找最好的切分点 后者是在部分特征中（数据量大的时候）# # -  3.max_features  None（所有），log2，sqrt，N  特征小于50的时候一般使用所有的# # -  4.max_depth  数据少或者特征少的时候可以不管这个值，如果模型样本量多，特征也多的情况下，可以尝试限制下# # -  5.min_samples_split  如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。# # -  6.min_samples_leaf  这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝，如果样本量不大，不需要管这个值，大些如10W可是尝试下5# # -  7.min_weight_fraction_leaf 这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。# # -  8.max_leaf_nodes 通过限制最大叶子节点数，可以防止过拟合，默认是&quot;None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制具体的值可以通过交叉验证得到。# # -  9.class_weight 指定样本各类别的的权重，主要是为了防止训练集某些类别的样本过多导致训练的决策树过于偏向这些类别。这里可以自己指定各个样本的权重如果使用“balanced”，则算法会自己计算权重，样本量少的类别所对应的样本权重会高。# # - 10.min_impurity_split 这个值限制了决策树的增长，如果某节点的不纯度(基尼系数，信息增益，均方差，绝对差)小于这个阈值则该节点不再生成子节点。即为叶子节点 。# - n_estimators:要建立树的个数</code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA常用快捷键</title>
      <link href="/zjh/2021/12/25/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/zjh/2021/12/25/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>摘自： <a href="https://blog.csdn.net/cold___play/article/details/100178346?ops_request_misc=&request_id=&biz_id=102&utm_term=idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100178346.nonecase&spm=1018.2226.3001.4187" title="来自：CSDN"> IDEA常用命令 ,侵删</a></p><h3 id="1-自动代码"><a href="#1-自动代码" class="headerlink" title="1. 自动代码"></a>1. 自动代码</h3><p>常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。<br>例如要输入for(User user : users)只需输入user.for+Tab。</p><p>再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。代码标签输入完成后，按Tab，生成代码。</p><table><thead><tr><th align="center">快捷键</th><th align="center">指令</th></tr></thead><tbody><tr><td align="center">Ctrl+Alt+O</td><td align="center">优化导入的类和包</td></tr><tr><td align="center">Alt+Insert</td><td align="center">生成代码(如get,set方法,构造函数等) 或者右键（Generate）</td></tr><tr><td align="center">Ctrl+Alt+T</td><td align="center">生成try catch 或者 Alt+enter</td></tr><tr><td align="center">CTRL+ALT+T</td><td align="center">把选中的代码放在 TRY{} IF{} ELSE{} 里</td></tr><tr><td align="center">Ctrl + O</td><td align="center">重写方法</td></tr><tr><td align="center">Ctrl + I</td><td align="center">实现方法</td></tr><tr><td align="center">Ctr+shift+U</td><td align="center">大小写转化</td></tr><tr><td align="center">ALT+回车</td><td align="center">导入包,自动修正</td></tr><tr><td align="center">ALT+/</td><td align="center">代码提示</td></tr><tr><td align="center">CTRL+J</td><td align="center">自动代码</td></tr><tr><td align="center">Ctrl+Shift+J</td><td align="center">整合两行为一行</td></tr><tr><td align="center">CTRL+空格</td><td align="center">代码提示</td></tr><tr><td align="center">CTRL+SHIFT+SPACE</td><td align="center">自动补全代码</td></tr><tr><td align="center">CTRL+ALT+L</td><td align="center">格式化代码</td></tr><tr><td align="center">CTRL+ALT+I</td><td align="center">自动缩进</td></tr><tr><td align="center">CTRL+ALT+O</td><td align="center">优化导入的类和包</td></tr><tr><td align="center">ALT+INSERT</td><td align="center">生成代码(如GET,SET方法,构造函数等)</td></tr><tr><td align="center">CTRL+E</td><td align="center">最近更改的代码</td></tr><tr><td align="center">CTRL+ALT+SPACE</td><td align="center">类名或接口名提示</td></tr><tr><td align="center">CTRL+P</td><td align="center">方法参数提示</td></tr><tr><td align="center">CTRL+Q</td><td align="center">可以看到当前方法的声明</td></tr><tr><td align="center">Shift+F6</td><td align="center">重构-重命名 (包、类、方法、变量、甚至注释等)</td></tr><tr><td align="center">Ctrl+Alt+V</td><td align="center">提取变量</td></tr></tbody></table><h3 id="2-查询快捷键"><a href="#2-查询快捷键" class="headerlink" title="2. 查询快捷键"></a>2. 查询快捷键</h3><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Ctrl＋Shift＋Backspace</td><td align="center">可以跳转到上次编辑的地</td></tr><tr><td align="center">CTRL+ALT+ left/right</td><td align="center">前后导航编辑过的地方</td></tr><tr><td align="center">ALT+7</td><td align="center">靠左窗口显示当前文件的结构</td></tr><tr><td align="center">Ctrl+F12</td><td align="center">浮动显示当前文件的结构</td></tr><tr><td align="center">ALT+F7</td><td align="center">找到你的函数或者变量或者类的所有引用到的地方</td></tr><tr><td align="center">CTRL+ALT+F7</td><td align="center">找到你的函数或者变量或者类的所有引用到的地方</td></tr><tr><td align="center">Ctrl+Shift+Alt+N</td><td align="center">查找类中的方法或变量</td></tr><tr><td align="center">双击SHIFT</td><td align="center">在项目的所有目录查找文件</td></tr><tr><td align="center">Ctrl+N</td><td align="center">查找类</td></tr><tr><td align="center">Ctrl+Shift+N</td><td align="center">查找文件</td></tr><tr><td align="center">CTRL+G</td><td align="center">定位行</td></tr><tr><td align="center">CTRL+F</td><td align="center">在当前窗口查找文本</td></tr><tr><td align="center">CTRL+SHIFT+F</td><td align="center">在指定窗口查找文本</td></tr><tr><td align="center">CTRL+R</td><td align="center">在当前窗口替换文本</td></tr><tr><td align="center">CTRL+SHIFT+R</td><td align="center">在指定窗口替换文本</td></tr><tr><td align="center">ALT+SHIFT+C</td><td align="center">查找修改的文件</td></tr><tr><td align="center">CTRL+E</td><td align="center">最近打开的文件</td></tr><tr><td align="center">F3</td><td align="center">向下查找关键字出现位置</td></tr><tr><td align="center">SHIFT+F3</td><td align="center">向上一个关键字出现位置</td></tr><tr><td align="center">选中文本，按Alt+F3</td><td align="center">高亮相同文本，F3逐个往下查找相同文本</td></tr><tr><td align="center">F4</td><td align="center">查找变量来源</td></tr><tr><td align="center">CTRL+SHIFT+O</td><td align="center">弹出显示查找内容</td></tr><tr><td align="center">Ctrl+W</td><td align="center">选中代码，连续按会有其他效果</td></tr><tr><td align="center">F2 或Shift+F2</td><td align="center">高亮错误或警告快速定位</td></tr><tr><td align="center">Ctrl+Up/Down</td><td align="center">光标跳转到第一行或最后一行下</td></tr><tr><td align="center">Ctrl+B</td><td align="center">快速打开光标处的类或方法</td></tr><tr><td align="center">CTRL+ALT+B</td><td align="center">找所有的子类</td></tr><tr><td align="center">CTRL+SHIFT+B</td><td align="center">找变量的类</td></tr><tr><td align="center">Ctrl+Shift+上下键</td><td align="center">上下移动代码</td></tr><tr><td align="center">Ctrl+Alt+ left/right</td><td align="center">返回至上次浏览的位置</td></tr><tr><td align="center">Ctrl+X</td><td align="center">删除行</td></tr><tr><td align="center">Ctrl+D</td><td align="center">复制行</td></tr><tr><td align="center">Ctrl+/ 或 Ctrl+Shift+/</td><td align="center">注释（// 或者/…/ ）</td></tr><tr><td align="center">Ctrl+H</td><td align="center">显示类结构图</td></tr><tr><td align="center">Ctrl+Q</td><td align="center">显示注释文档</td></tr><tr><td align="center">Alt+F1</td><td align="center">查找代码所在位置</td></tr><tr><td align="center">Alt+1</td><td align="center">快速打开或隐藏工程面板</td></tr><tr><td align="center">Alt+ left/right</td><td align="center">切换代码视图</td></tr><tr><td align="center">ALT+ ↑/↓</td><td align="center">在方法间快速移动定位</td></tr><tr><td align="center">CTRL+ALT+ left/right</td><td align="center">前后导航编辑过的地方</td></tr><tr><td align="center">Ctrl＋Shift＋Backspace</td><td align="center">可以跳转到上次编辑的地</td></tr><tr><td align="center">Alt+6</td><td align="center">查找TODO</td></tr></tbody></table><h3 id="3-其它快捷键"><a href="#3-其它快捷键" class="headerlink" title="3. 其它快捷键"></a>3. 其它快捷键</h3><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SHIFT+ENTER</td><td align="center">另起一行</td></tr><tr><td align="center">CTRL+Z</td><td align="center">倒退(撤销)</td></tr><tr><td align="center">CTRL+SHIFT+Z</td><td align="center">向前(取消撤销)</td></tr><tr><td align="center">CTRL+ALT+F12</td><td align="center">资源管理器打开文件夹</td></tr><tr><td align="center">ALT+F1</td><td align="center">查找文件所在目录位置</td></tr><tr><td align="center">SHIFT+ALT+INSERT</td><td align="center">竖编辑模式</td></tr><tr><td align="center">CTRL+F4</td><td align="center">关闭当前窗口</td></tr><tr><td align="center">Ctrl+Alt+V</td><td align="center">可以引入变量。例如：new String(); 自动导入变量定义</td></tr><tr><td align="center">Ctrl+~</td><td align="center">快速切换方案（界面外观、代码风格、快捷键映射等菜单）</td></tr></tbody></table><h3 id="4-svn快捷键"><a href="#4-svn快捷键" class="headerlink" title="4. svn快捷键"></a>4. svn快捷键</h3><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ctrl+k</td><td align="center">提交代码到SVN</td></tr><tr><td align="center">ctrl+t</td><td align="center">更新代码</td></tr></tbody></table><h3 id="5-调试快捷键"><a href="#5-调试快捷键" class="headerlink" title="5. 调试快捷键"></a>5. 调试快捷键</h3><p>其实常用的 就是F8 F7 F9 最值得一提的 就是Drop Frame 可以让运行过的代码从头再来</p><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">alt+F8</td><td align="center">debug时选中查看值</td></tr><tr><td align="center">Alt+Shift+F9</td><td align="center">选择 Debug</td></tr><tr><td align="center">Alt+Shift+F10</td><td align="center">选择 Run</td></tr><tr><td align="center">Ctrl+Shift+F9</td><td align="center">编译</td></tr><tr><td align="center">Ctrl+Shift+F8</td><td align="center">查看断点</td></tr><tr><td align="center">F7</td><td align="center">步入</td></tr><tr><td align="center">Shift+F7</td><td align="center">智能步入</td></tr><tr><td align="center">Alt+Shift+F7</td><td align="center">强制步入</td></tr><tr><td align="center">F8</td><td align="center">步过</td></tr><tr><td align="center">Shift+F8</td><td align="center">步出</td></tr><tr><td align="center">Alt+Shift+F8</td><td align="center">强制步过</td></tr><tr><td align="center">Alt+F9</td><td align="center">运行至光标处</td></tr><tr><td align="center">Ctrl+Alt+F9</td><td align="center">强制运行至光标处</td></tr><tr><td align="center">F9</td><td align="center">恢复程序</td></tr><tr><td align="center">Alt+F10</td><td align="center">定位到断点</td></tr></tbody></table><h3 id="6-重构"><a href="#6-重构" class="headerlink" title="6. 重构"></a>6. 重构</h3><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Ctrl+Alt+Shift+T</td><td align="center">弹出重构菜单</td></tr><tr><td align="center">Shift+F6</td><td align="center">重命名</td></tr><tr><td align="center">F6</td><td align="center">移动</td></tr><tr><td align="center">F5</td><td align="center">复制</td></tr><tr><td align="center">Alt+Delete</td><td align="center">安全删除</td></tr><tr><td align="center">Ctrl+Alt+N</td><td align="center">内联</td></tr></tbody></table><h1 id="十大IntelliJ-IDEA快捷键"><a href="#十大IntelliJ-IDEA快捷键" class="headerlink" title="十大IntelliJ IDEA快捷键"></a>十大IntelliJ IDEA快捷键</h1><p>Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。<br>以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。</p><h3 id="智能提示："><a href="#智能提示：" class="headerlink" title="智能提示："></a>智能提示：</h3><p>Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。<br>最后要说一点，Intellij能够智能感知Spring、Hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。</p><h3 id="重构："><a href="#重构：" class="headerlink" title="重构："></a>重构：</h3><p>Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。<br>切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。</p><h3 id="代码生成："><a href="#代码生成：" class="headerlink" title="代码生成："></a>代码生成：</h3><p>这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。<br>另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。</p><h3 id="编辑："><a href="#编辑：" class="headerlink" title="编辑："></a>编辑：</h3><p>编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+&lt;/&gt;折叠代码就不多说了。<br>关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。</p><h3 id="查找打开："><a href="#查找打开：" class="headerlink" title="查找打开："></a>查找打开：</h3><p>类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。<br>类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。<br>要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。<br>Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。</p><h3 id="其他辅助："><a href="#其他辅助：" class="headerlink" title="其他辅助："></a>其他辅助：</h3><p>以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：</p><ul><li>命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。</li><li>新建：Alt+Insert可以新建类、方法等任何东西。</li><li>格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。</li><li>切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。</li><li>单元测试：Ctrl+Alt+T创建单元测试用例。</li><li>运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。</li><li>调试：F7/F8/F9分别对应Step into，Step over，Continue。</li></ul><p>此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。</p><ul><li>Top #10切来切去：Ctrl+Tab</li><li>Top #9选你所想：Ctrl+W</li><li>Top #8代码生成：Template/Postfix +Tab</li><li>Top #7发号施令：Ctrl+Shift+A</li><li>Top #6无处藏身：Shift+Shift</li><li>Top #5自动完成：Ctrl+Shift+Enter</li><li>Top #4创造万物：Alt+Insert</li><li>Top #1智能补全：Ctrl+Shift+Space</li><li>Top #1自我修复：Alt+Enter</li><li>Top #1重构一切：Ctrl+Shift+Alt+T</li></ul><p>CTRL+ALT+ left/right 前后导航编辑过的地方。<br>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回形针数字矩阵Java实现</title>
      <link href="/zjh/2021/12/25/%E5%9B%9E%E5%BD%A2%E9%92%88%E6%95%B0%E5%AD%97%E7%9F%A9%E9%98%B5Java%E5%AE%9E%E7%8E%B0/"/>
      <url>/zjh/2021/12/25/%E5%9B%9E%E5%BD%A2%E9%92%88%E6%95%B0%E5%AD%97%E7%9F%A9%E9%98%B5Java%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210726004539592.png"><br>我们发现这个回形数矩阵的逻辑是：→↓←↑四个为一个循环，故考虑框架为：一个外层for里面嵌套4个内层for</p><p>每个内层for的起点终点都随着外层的变化而变化</p><p>说实话这种问题只可意会不可言传，光看源码没什么用，你得逼着自己去思考，哪怕是一个下午，一天才做出来也比你直接看源码好啊<del>使劲想想现实逻辑怎么转化为for循环逻辑，一般看到那个→↓←↑就会感觉这四个地位等价，就尝试着把这四个for放到一个外层大for里面，一点一点试出来</del></p><pre><code>import java.util.Scanner;public class Test1 &#123;    public static void main(String[] args) &#123;        Scanner scan = new Scanner(System.in);        System.out.println(&quot;输入一个数，返回回形数矩阵&quot;);        int i = scan.nextInt();        // 键盘输入一个数        int[][] arr = new int[i][i];        int m = 1;//用于赋值        /*思考循环数的逻辑顺序，→↓←↑四个为一个循环，故考虑框架为一个外层for里面套4个内层for*/        /*每一个循环的→↓←↑内层for循环，其起点和终点都不断改变，所以起点终点必须表现出来这个联系，绝不能为常数*/        for (int j = 0; j &lt; i; j++) &#123;             for (int k = j; k &lt; i - j; k++) &#123;//k=j和k&lt;i-j都在不断的改变                        arr[j][k] = m;                m++;            &#125;             for (int l = j + 1; l &lt; i - j; l++) &#123;                arr[l][i - j - 1] = m;                m++;            &#125;            for (int p = i - j - 2; p &gt; j - 1; p--) &#123;                arr[i - j - 1][p] = m;                m++;            &#125;            for (int q = i - j - 2; q &gt; j; q--) &#123;                arr[q][j] = m;                m++;            &#125;        &#125;        // 输出矩阵        for (int a = 0; a &lt; arr.length; a++) &#123;            for (int b = 0; b &lt; arr[a].length; b++) &#123;                System.out.print(arr[a][b] + &quot;\t&quot;);             &#125;            System.out.println();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java四种next用法</title>
      <link href="/zjh/2021/12/25/Java%E5%9B%9B%E7%A7%8Dnext%E7%94%A8%E6%B3%95/"/>
      <url>/zjh/2021/12/25/Java%E5%9B%9B%E7%A7%8Dnext%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在查阅了大量网上相关资料都没有一个完整的解释，并且我查的几篇高赞回答都是错误的时候，我决定用一整天的时间来精细写下这篇文章，希望对你有帮助。</p><pre><code>大多数人对hasNext的印象停留在“判断是否有下一个值”上，而该方法还是一个阻塞式的方法</code></pre><h1 id="hasNext和hasNextLine的区别"><a href="#hasNext和hasNextLine的区别" class="headerlink" title="hasNext和hasNextLine的区别"></a>hasNext和hasNextLine的区别</h1><p>二者都是用于判断“有无键盘输入”的，有则返回true，没有则阻塞！一定记住是阻塞而不是返回false，很多人都说是返回false，但你查源码会发现是不会返回false的，他会让你一直阻塞在判断阶段，二者只是在细节上有不同</p><pre><code>hasNext()方法会判断接下来是否有非空字符.如果有,则返回true，没有则阻塞。例如一直敲回车相当于一直判断为空字符，但是不会返回false，而是一直阻塞在判断阶段，直到你输入了非空字符hasNextLine() 方法会根据行匹配模式去判断接下来是否有一行(包括空行),如果有,则返回true。这个没什么特别的，只要是你敲了回车那都是true并且不会阻塞</code></pre><p>例如像这种if语句是永远不可能执行到内部方法体的</p><pre><code>if(scan.hasNext()==false)&#123;    System.out.println(&quot;hasNext和hasNextLine不会返回false&quot;);&#125;</code></pre><p> 再举一个例子加深理解：</p><pre><code>Scanner scan = new Scanner(System.in);System.out.println(scan.hasNextLine());System.out.println(scan.hasNext());</code></pre><p> 运行该代码，一直不停敲回车键，第一次回车会直接输出true，而后面一直敲都会阻塞在hasNext语句上，运行如下图</p><p><img src="https://img-blog.csdnimg.cn/20211001130739982.png"></p><p>首先，在看用法和解释之前，有以下几个点必须时刻牢记</p><blockquote><p>next方法不能录入空格，在特定情况下会把空格当作回车，nextLine方法可以识录入空格<br>hasNext和hasNextLine的返回值都是boolean类型，但只有可能返回true，不可能返回false，并且都默认以回车键为结束（hasNext可以设置为任意符号为结束键，不在本文研究范围之内）<br>hasNext、next不能直接识别裸回车，而hasNextLine和nextLine都可以直接识别裸回车。换句话讲：对于不输入符号而直接裸敲一个回车的操作，只有后两个能识别<br>hasNext、hasNextLine在返回一个boolean类型结果true的同时，会在堆空间中开辟一块专门用于存放刚刚输入的字符串，用于下次next或者nextLine：即下次next或者nextLine不需要再从键盘输入，相当于系统自动把刚刚输入的字符串再原封不动的输入了一遍。同时这个存储寿命＝调用对象的寿命<br>对于hasNext来说，每次敲击回车都相当于在堆空间中开辟一行，敲几次回车就会直接给后续next、nextLine方法赋值几次<br>hasNext是线程阻塞的，对于hasNext来说，如果一直不输入字符，反而一直敲回车的话，整个线程会卡在这个输入的地方，直到有字符输入</p></blockquote><p>在知道 hasNext的方法用于判断和存储，next的方法用于输入之后，来做如下预备工作</p><blockquote><p>因为hasNext、hasNextLine与next、nextLine有2X2种组合方式，所以我们用4段代码做4次实验就可以大体上了解他们的特性</p></blockquote><p>以下4段代码希望看客们能亲自复制粘贴了试一试，以便更深理解</p><h2 id="hasNext-和-next组合"><a href="#hasNext-和-next组合" class="headerlink" title="hasNext 和 next组合"></a>hasNext 和 next组合</h2><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNext() ) &#123;    System.out.println(&quot;第一次&quot;+scan.next());    System.out.println(&quot;第二次&quot;+scan.next());    System.out.println(&quot;第三次&quot;+scan.next());&#125;</code></pre><p>尝试输入：空格aaa空格bbb空格ccc回车<br><img src="https://img-blog.csdnimg.cn/20211001131608748.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_18,color_FFFFFF,t_70,g_se,x_16"><br>解释：<br><img src="https://img-blog.csdnimg.cn/20211001125303907.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_15,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="hasNext-和-NextLine组合"><a href="#hasNext-和-NextLine组合" class="headerlink" title="hasNext 和 NextLine组合"></a>hasNext 和 NextLine组合</h2><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNext() ) &#123;    System.out.println(&quot;第一次&quot;+scan.nextLine());    System.out.println(&quot;第二次&quot;+scan.nextLine());    System.out.println(&quot;第三次&quot;+scan.nextLine());&#125;</code></pre><p>解释：光标仍然闪烁，证明堆空间中的  aaa bbb ccc只赋值给了第一个，这也验证了nextLine可以录入空格。此时线程正在等待用户输入第二个nextLine<br>hasNextLine 和 next组合</p><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNextLine() ) &#123;    System.out.println(&quot;第一次&quot;+scan.next());    System.out.println(&quot;第二次&quot;+scan.next());    System.out.println(&quot;第三次&quot;+scan.next());&#125;</code></pre><h2 id="hasNextLine-和-nextLine组合"><a href="#hasNextLine-和-nextLine组合" class="headerlink" title="hasNextLine 和 nextLine组合"></a>hasNextLine 和 nextLine组合</h2><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNextLine() ) &#123;    System.out.println(&quot;第一次&quot;+scan.nextLine());    System.out.println(&quot;第二次&quot;+scan.nextLine());    System.out.println(&quot;第三次&quot;+scan.nextLine());&#125;</code></pre><p>发现规律了吗<br><img src="https://img-blog.csdnimg.cn/20211001132037981.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_18,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>如果直接连续敲回车，那么hasNextLine会判断为true，同时进入if语句执行，并且输入了三个空行也会输出三个空行</strong></p><p>验证hasNext、hasNextLine对输入代码的存储寿命</p><p>hasNextLine在if语句内，我们将验证语句next放在if语句之外，输入aaa bbb ccc ddd测试</p><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNextLine() ) &#123;    System.out.println(&quot;第一次&quot;+scan.next());    System.out.println(&quot;第二次&quot;+scan.next());    System.out.println(&quot;第三次&quot;+scan.next());&#125;        System.out.println(&quot;验证存储寿命是否＝scan对象寿命&quot;+scan.next());</code></pre><p> <img src="https://img-blog.csdnimg.cn/20211001132824820.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_17,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>hasNext、hasNextLine不可能返回false，只有true和阻塞两种结果</p><p>hasNext、hasNextLine会判断有无输入，并且hasNext一直敲回车而不输入字符会导致线程阻塞</p><p>hasNext、hasNextLine也有存储功能，从“开始输入”到“判断结束”的过程中的所有输入都将储存，直到之后遇到需要键盘输入的next、nextLine，这些存储的字符串和空格会自动填写给后面的next、nextLine。而空格再next和nextLine上有不同的表现</p><p>查看API还有很多同类型的不同方法，按照这个思路可以一通百通<br><img src="https://img-blog.csdnimg.cn/2021100113530823.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/20211001135328579.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RLE算法的Java实现</title>
      <link href="/zjh/2021/12/25/RLE%E7%AE%97%E6%B3%95%E7%9A%84Java%E5%AE%9E%E7%8E%B0/"/>
      <url>/zjh/2021/12/25/RLE%E7%AE%97%E6%B3%95%E7%9A%84Java%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="针对字符的RLE压缩"><a href="#针对字符的RLE压缩" class="headerlink" title="针对字符的RLE压缩"></a>针对字符的RLE压缩</h1><pre><code>1. 针对纯字符的压缩2. 不考虑两位数及以上的循环例如：用1*2#5*3#表示：11555两个1三个5，即 数*重复次数#</code></pre><p>至于为什么只考虑一位数：多位数可以用包装类Integer表示，并且实际压缩中不会单纯压缩字符，一般都是整个对象一起压缩，所以没必要两位相连的数与后面判断</p><pre><code> public static StringBuffer RLE(char...chars)&#123;//行程编码方法，形参放char型数组        //因为频繁更改字符串，所以返回值不用String        StringBuffer dest = new StringBuffer();        //注意：StringBuffer必须用new，不然不分配空间        //StringBuffer dest = null;会空指针异常        for(int i = 0 ; i&lt;chars.length-1 ; i++)&#123;//chars数组遍历——————压缩            //每次轮到chars[i],都需要用if和屁股后面紧跟的元素判断是否相等            dest.append(chars[i]);            dest.append(&#39;*&#39;);            int count = 1;//相等元素计数器            boolean bo = true;            while(bo)&#123;//while循环直到碰不到一样的元素就break                if(i&lt;chars.length-1 &amp;&amp; chars[i]==chars[i+1])&#123;//必须要避免空指针异常                    //注意：此处对i的判断必须在前，否则角标越界                    //并且要用&amp;&amp; 不能用&amp;，否则仍角标越界                    count++;                    i++;                &#125;else&#123;                    bo = false;                &#125;            &#125;            //循环结束，统计相同的个数            dest.append(count);            dest.append(&#39;#&#39;);//标识符，#之后又开始新的判断        &#125;        return dest;        &#125;//main方法中实现 String s1 = &quot;1112233334455566777778889999&quot;;        StringBuffer s2 = RLE(s1.toCharArray());        System.out.println(s2.toString());</code></pre><p>输出结果：1<em>3#2</em>2#3<em>4#4</em>2#5<em>3#6</em>2#7<em>5#8</em>3#9*4#</p><p>含义为：1出现了3次，2出现了2次……</p><h1 id="针对一维对象的RLE压缩"><a href="#针对一维对象的RLE压缩" class="headerlink" title="针对一维对象的RLE压缩"></a>针对一维对象的RLE压缩</h1><pre><code>1. 对象具有一个属性值和一个坐标值2. 不考虑独立多属性值，因为很难重复</code></pre><p> 先定义像素点：</p><pre><code>public class PixelPoint &#123;//一维像素点       private int grayScale;//灰度值    private int x;//x坐标     public PixelPoint(int grayScale,int x)&#123;        this.grayScale = grayScale;        this.x = x;    &#125;     public int getX()&#123;        return this.x;    &#125;     public int getGrayScale() &#123;        return grayScale;    &#125;&#125;</code></pre><p> 定义像素点的压缩方法：</p><pre><code>    public static LinkedHashMap&lt;PixelPoint,Integer&gt; RLE(ArrayList&lt;PixelPoint&gt; px)&#123;        //形参放入ArryaList，返回值用LinkedHashMap存储键值对，并且LinkedHashMap可以按添加顺序遍历        LinkedHashMap&lt;ZJH.HJZ.PixelPoint,Integer&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();         for(int i = 0 ; i &lt; px.size() ; )&#123;//            int j = i;            boolean bo = true;            int count = 1;//计相同个数             while(bo)&#123;                if(i&lt;px.size()-1)&#123;                    if(px.get(i).getGrayScale() == px.get(i+1).getGrayScale())&#123;                        count++;                        i++;                    &#125;else&#123;                        i++;                        bo = false;                    &#125;                    &#125; else&#123;                    bo = false;                    i++;                &#125;            &#125;                 linkedHashMap.put(px.get(j), count);            &#125;            return linkedHashMap;    &#125;</code></pre><p>载入像素点：并使用上面定义好的压缩方法，最后迭代器遍历(完整源码如下)</p><pre><code>public class RLE_complex_one &#123;//对一维像素点的RLE算法测试    public static void main(String[] args) &#123;       //此例中所有像素点x坐标连续分布，故暂不考虑排序，用ArrayList效率更高        ArrayList&lt;ZJH.HJZ.PixelPoint&gt; arrayList = new ArrayList&lt;&gt;(20);//初始容量设为20(默认是10，每次扩大1.5X)        //以下模拟像素点的连续排布及灰度值情况        arrayList.add(new PixelPoint(1,1));        arrayList.add(new PixelPoint(1,2));        arrayList.add(new PixelPoint(1,3));        arrayList.add(new PixelPoint(1,4));        arrayList.add(new PixelPoint(1,5));        arrayList.add(new PixelPoint(50,6));        arrayList.add(new PixelPoint(50,7));        arrayList.add(new PixelPoint(50,8));        arrayList.add(new PixelPoint(50,9));        arrayList.add(new PixelPoint(255,10));        arrayList.add(new PixelPoint(255,11));        arrayList.add(new PixelPoint(255,12));        arrayList.add(new PixelPoint(255,13));        arrayList.add(new PixelPoint(255,14));        arrayList.add(new PixelPoint(255,15));        arrayList.add(new PixelPoint(255,16));        arrayList.add(new PixelPoint(255,17));        arrayList.add(new PixelPoint(255,18));           LinkedHashMap&lt;ZJH.HJZ.PixelPoint, Integer&gt; rleDest = RLE(arrayList);//返回编码结果        //以下用迭代器遍历        Set&lt;Map.Entry&lt;PixelPoint, Integer&gt;&gt; entries = rleDest.entrySet();        Iterator&lt;Map.Entry&lt;PixelPoint, Integer&gt;&gt; iterator = entries.iterator();            int i = 1;        while(iterator.hasNext())&#123;            Map.Entry&lt;PixelPoint, Integer&gt; nextentries = iterator.next();            System.out.println(&quot;第&quot;+i+&quot;位压缩后的元素的灰度值是：&quot;+nextentries.getKey().getGrayScale()+&quot;，且压缩了&quot;+nextentries.getValue()+&quot;个连续的像素点&quot;);            i++;        &#125;      &#125;     public static LinkedHashMap&lt;PixelPoint,Integer&gt; RLE(ArrayList&lt;PixelPoint&gt; px)&#123;        //形参放入ArryaList，返回值用LinkedHashMap存储键值对，并且LinkedHashMap可以按添加顺序遍历        LinkedHashMap&lt;ZJH.HJZ.PixelPoint,Integer&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();         for(int i = 0 ; i &lt; px.size() ; )&#123;//            int j = i;            boolean bo = true;            int count = 1;//计相同个数             while(bo)&#123;                if(i&lt;px.size()-1)&#123;                    if(px.get(i).getGrayScale() == px.get(i+1).getGrayScale())&#123;                        count++;                        i++;                    &#125;else&#123;                        i++;                        bo = false;                    &#125;                    &#125; else&#123;                    bo = false;                    i++;                &#125;            &#125;                 linkedHashMap.put(px.get(j), count);            &#125;            return linkedHashMap;    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/a131150dbf364cc0ada38ae815633039.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown常用语法</title>
      <link href="/zjh/2021/12/24/MarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/zjh/2021/12/24/MarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h1><p>一共支持6级标题，例如二级标题用“## 标题2”</p><h2 id="标题2示例"><a href="#标题2示例" class="headerlink" title="标题2示例"></a>标题2示例</h2><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p><strong>加粗</strong>：左右各2*</p><p><em>斜体</em>：左右各1*</p><p><em><strong>加粗斜体</strong></em>：左右各3*</p><p><del>删除横杠</del>：左右各2~</p><h1 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h1><p>&lt;br/&gt;<br>中间加上这个br<br/>就能换行了</p><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>\xxxx就能让命令原样显示</p><h1 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h1><pre><code>按tab   引用块和引用冲突，不可分层</code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>可以嵌套使用,原理同标题，&gt;表示第一层，&gt;&gt;表示内2层，&gt;后接空格</p><blockquote><p>第一层</p><blockquote><p>第二层</p><blockquote><p>第三层内容</p></blockquote></blockquote></blockquote><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><hr><p>3个或3个以上的<em>或者-，*<em>效果相同</em></em></p><hr><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p><a href="https://www.jianshu.com/p/ea1eb11db63f" title="图床">图床的应用</a></p><blockquote><p>格式<br/><br>![图片alt](图片地址 ‘’图片title’’)</p></blockquote><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</p><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>[超链接名]（超链接地址 “超链接title”）</p><p>title可加可不加</p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>表头|表头|表头</p><p>—|:–:|—:</p><p>内容|内容|内容</p><p>内容|内容|内容</p><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><p>第二行分割表头和内容。<br><strong>- 有一个就行，为了对齐，多加了几个</strong></p><p>文字默认居左<br/><br>-两边加：表示文字居中<br/><br>-右边加：表示文字居右<br/><br>注：原生的语法两边都要用 | 包起来。此处省略</p><p>第二行分割表头和内容。<br/><br>- 有一个就行，为了对齐，多加了几个<br/><br>文字默认居左<br/><br>-两边加：表示文字居中<br/><br>-右边加：表示文字居右<br/><br>注：原生的语法两边都要用 | 包起来。此处省略</p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表用"><a href="#无序列表用" class="headerlink" title="无序列表用-+*"></a>无序列表用-+*</h2><p>- 举例1<br/>+ 举例2<br/>* 举例3<br/></p><ul><li>举例1</li></ul><ul><li>举例2</li></ul><ul><li>举例3<h2 id="有序列表用1-2-3"><a href="#有序列表用1-2-3" class="headerlink" title="有序列表用1. 2. 3."></a>有序列表用1. 2. 3.</h2></li></ul><ol><li>举例1</li><li>举例2</li></ol><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>反引号`是~号的半角模式</p><h2 id="单行代码-xxxx"><a href="#单行代码-xxxx" class="headerlink" title="单行代码`xxxx`"></a>单行代码`xxxx`</h2><p><code>System.out.println(&quot;Hello&quot;);</code><br><code>System.out.println(&quot;World&quot;);</code></p><h2 id="多行代码-39-‘’xxx-xxx’’’"><a href="#多行代码-39-‘’xxx-xxx’’’" class="headerlink" title="多行代码&#39;‘’xxx xxx’’’"></a>多行代码&#39;‘’xxx xxx’’’</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(iterators.hasNextLine)&#123;</span><br><span class="line">    iterators.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><pre><code class="flow">st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;```</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
