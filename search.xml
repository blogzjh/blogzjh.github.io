<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NXB成员管理系统单页全栈</title>
      <link href="/zjh/2022/01/30/NXB%E6%88%90%E5%91%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%8D%95%E9%A1%B5%E5%85%A8%E6%A0%88/"/>
      <url>/zjh/2022/01/30/NXB%E6%88%90%E5%91%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%8D%95%E9%A1%B5%E5%85%A8%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h1><p>springboot+mybatisplus+lombok+vue+element+axios</p><p><img src="https://img-blog.csdnimg.cn/fd601084dd4d45dba2b44154bef09135.png" alt="案例结构"></p><h1 id="数据属性绑定层面"><a href="#数据属性绑定层面" class="headerlink" title="数据属性绑定层面"></a>数据属性绑定层面</h1><h2 id="数据库与domain绑定"><a href="#数据库与domain绑定" class="headerlink" title="数据库与domain绑定"></a>数据库与domain绑定</h2><p><img src="https://img-blog.csdnimg.cn/e349e9ec3b33419285906d31207d40fa.png" alt="设置自动填充当前时间"><br><img src="https://img-blog.csdnimg.cn/b360980ee55d40f7a55e735ae652a267.png" alt="domain"></p><h2 id="前端属性和domain统一"><a href="#前端属性和domain统一" class="headerlink" title="前端属性和domain统一"></a>前端属性和domain统一</h2><p><img src="https://img-blog.csdnimg.cn/3ec59c343c7240a8bf243366e53c334c.png" alt="名字和domain统一"></p><h1 id="R类的前后端交互"><a href="#R类的前后端交互" class="headerlink" title="R类的前后端交互"></a>R类的前后端交互</h1><p>后端传给前端的是一个R对象，并且需要前端对R对象进行判断解析<br>R类属性：flag\data\msg<br><img src="https://img-blog.csdnimg.cn/d4cb960282f7478d9820fb5011226d18.png"></p><h2 id="后端控制层"><a href="#后端控制层" class="headerlink" title="后端控制层"></a>后端控制层</h2><p><img src="https://img-blog.csdnimg.cn/50f9b0eda19248cab1ab5452454bcd9e.png" alt="返回R对象，设置属性"></p><h2 id="前端视图层"><a href="#前端视图层" class="headerlink" title="前端视图层"></a>前端视图层</h2><p><img src="https://img-blog.csdnimg.cn/5ec3daf8ec704312b30e1795ec3ef397.png" alt="res.data==R"></p><h1 id="异常处理拦截器"><a href="#异常处理拦截器" class="headerlink" title="异常处理拦截器"></a>异常处理拦截器</h1><p><img src="https://img-blog.csdnimg.cn/ad91f2d27bd1457996f435d8420ca2b6.png" alt="返回一个只设置msg的R对象"></p><h1 id="MybatisPlus：持久层-业务层"><a href="#MybatisPlus：持久层-业务层" class="headerlink" title="MybatisPlus：持久层+业务层"></a>MybatisPlus：持久层+业务层</h1><p><img src="https://img-blog.csdnimg.cn/42143a6991b0403f86e14b54cd9c0ec7.png"><br><img src="https://img-blog.csdnimg.cn/61b77d74244b4bebb2b3d0a9c5175094.png"></p><p><img src="https://img-blog.csdnimg.cn/0f5493531971421580cad3a082dac698.png" alt="业务层需要重写分页查询"></p><h1 id="控制层调用业务层接口"><a href="#控制层调用业务层接口" class="headerlink" title="控制层调用业务层接口"></a>控制层调用业务层接口</h1><p><img src="https://img-blog.csdnimg.cn/dcb50e6e5ef442e18cf07411c7277c0e.png" alt="调用业务层接口的方法间接操作数据库"></p><h1 id="前后端对应交互"><a href="#前后端对应交互" class="headerlink" title="前后端对应交互"></a>前后端对应交互</h1><h2 id="分页查询Get"><a href="#分页查询Get" class="headerlink" title="分页查询Get"></a>分页查询Get</h2><p>一个页面要么不分页，要么分页，分页也只能使用同一个分页组件，即便是后面的条件查询，也必须在分页的基础上<br><strong>像下面这种查完不分页的话，在前端是展示不出来的</strong><br><img src="https://img-blog.csdnimg.cn/ff8960944c3e47e88e646afe63d7c4a3.png" alt="错误示例"></p><h3 id="后端-GetMapping-“-currentPage-pageSize-”"><a href="#后端-GetMapping-“-currentPage-pageSize-”" class="headerlink" title="后端@GetMapping(“{currentPage}/{pageSize}”)"></a>后端@GetMapping(“{currentPage}/{pageSize}”)</h3><p><img src="https://img-blog.csdnimg.cn/0f92033ffb954be6a7d2bba187804ebc.png"></p><h3 id="前端钩子函数"><a href="#前端钩子函数" class="headerlink" title="前端钩子函数"></a>前端钩子函数</h3><p><img src="https://img-blog.csdnimg.cn/3c0a0cb658bb49319193dae27ccffdeb.png"></p><h3 id="前端分页查-条件查"><a href="#前端分页查-条件查" class="headerlink" title="前端分页查+条件查"></a>前端分页查+条件查</h3><p><img src="https://img-blog.csdnimg.cn/76f3aa44f3f947c790aa4c8bc62c739b.png" alt="可查id可全查">前端data中定义的是一个变量，而不是对象，所以后端使用@PathVariable来接受<img src="https://img-blog.csdnimg.cn/456e9a2bb20547f6b7f11a3c6778d6b6.png"></p><h3 id="条件查询传路径变量or对象？"><a href="#条件查询传路径变量or对象？" class="headerlink" title="条件查询传路径变量or对象？"></a>条件查询传路径变量or对象？</h3><p>因为这个案例的查询需求是“只要求从ID查询”，所以这里get的第三个参数可以只传一个路径变量this.searchById，后端通过@PathVariable Integer id来接受参数</p><p>如果是需要多条件查，可以通过多个路径变量@PathVariable<br><strong>多条件查如果条件过多，最好直接传一个对象，让后端处理</strong></p><p><strong>但是get方法是不能搭配@RequestBody的，后端直接不要用@RequestBody</strong></p><h2 id="增Post"><a href="#增Post" class="headerlink" title="增Post"></a>增Post</h2><h3 id="后端-RequestBody"><a href="#后端-RequestBody" class="headerlink" title="后端@RequestBody"></a>后端@RequestBody</h3><p><img src="https://img-blog.csdnimg.cn/a1b3590853c5478593ac78014f190673.png"></p><h3 id="前端formData-传对象"><a href="#前端formData-传对象" class="headerlink" title="前端formData:{}传对象"></a>前端formData:{}传对象</h3><p><img src="https://img-blog.csdnimg.cn/472856aa87bb4414b4f56608af9bbf49.png" alt="formData是对象"></p><p><img src="https://img-blog.csdnimg.cn/3e3293406a864102b233ae51c4f4e53c.png"></p><h2 id="删Delete"><a href="#删Delete" class="headerlink" title="删Delete"></a>删Delete</h2><h3 id="后端-删只能通过ID删"><a href="#后端-删只能通过ID删" class="headerlink" title="后端:删只能通过ID删"></a>后端:删只能通过ID删</h3><p><img src="https://img-blog.csdnimg.cn/f523f55642e042a0bb65927913b2cc18.png" alt="不允许删除开发者"></p><h3 id="前端只管传id路径变量"><a href="#前端只管传id路径变量" class="headerlink" title="前端只管传id路径变量"></a>前端只管传id路径变量</h3><p><img src="https://img-blog.csdnimg.cn/30450590f5ca46589a799125d0f81b36.png"></p><h2 id="改Put"><a href="#改Put" class="headerlink" title="改Put"></a>改Put</h2><h3 id="后端：接受对象-RequestBody"><a href="#后端：接受对象-RequestBody" class="headerlink" title="后端：接受对象@RequestBody"></a>后端：接受对象@RequestBody</h3><p><img src="https://img-blog.csdnimg.cn/babc5941f8e249b5921200b2e3e267c2.png"></p><p>前端获取待编辑的数据是不需要分页查询的，因此下面的“非分页条件查询id”是必不可少的</p><p><img src="https://img-blog.csdnimg.cn/93e30f19236b41aeac3b840b6fd6695e.png"></p><h3 id="前端：对于改的逻辑比后端复杂"><a href="#前端：对于改的逻辑比后端复杂" class="headerlink" title="前端：对于改的逻辑比后端复杂"></a>前端：对于改的逻辑比后端复杂</h3><p><img src="https://img-blog.csdnimg.cn/f4cbae77004541c389335095c4bd4b2e.png" alt="绑定点击事件"><br><img src="https://img-blog.csdnimg.cn/7abe1a128d6744eda2ac95753013d829.png" alt="重置表单，清除原有数据"></p><p><img src="https://img-blog.csdnimg.cn/e20417070e1243fa8b6c82c445b87247.png" alt="交互：先读后改"><br>dialogFormVisible4Edit = true后弹出表单，并读取数据<br><img src="https://img-blog.csdnimg.cn/c79b5ed9bcf94d16bc63dbab0088841a.png"><br><img src="https://img-blog.csdnimg.cn/bef7b71f403945d9918ae075545d6552.png" alt="跳转到修改put方法"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>axios时间交互报400</title>
      <link href="/zjh/2022/01/28/axios%E6%97%B6%E9%97%B4%E4%BA%A4%E4%BA%92%E6%8A%A5400/"/>
      <url>/zjh/2022/01/28/axios%E6%97%B6%E9%97%B4%E4%BA%A4%E4%BA%92%E6%8A%A5400/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用axios修改，向后台put请求时，报错400</p><p><img src="https://img-blog.csdnimg.cn/8e7d21bd4b3544999cd3f40238cae5cc.png"></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>后端controller<br><img src="https://img-blog.csdnimg.cn/27c3a5f3a5124714ad1ca6a64fc811cb.png"><br>前端axios.put<br><img src="https://img-blog.csdnimg.cn/5c2f284297a440fa8bff70f950341e4d.png"><br>查看前端控制台</p><p><img src="https://img-blog.csdnimg.cn/68f4c407446f4306a9525bcaefefe288.png" alt="确实PUT请求发出了"></p><p>那么问题就很可能出在了后端</p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>postman测试，仍然报错</p><p><img src="https://img-blog.csdnimg.cn/c1cb6a840e364747af03749e66f4d876.png"></p><p>那么问题基本锁定在后端控制层了<br>查看后端控制台</p><p>postman点击一次put，后台就输出如下内容，仔细阅读后发现</p><p>2022-01-28 14:38:55.920  WARN 17460 — [nio-8080-exec-7] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type <code>java.time.LocalDateTime</code> from String “2022-01-28”: Failed to deserialize java.time.LocalDateTime: (java.time.format.DateTimeParseException) Text ‘2022-01-28’ could not be parsed: <strong>Unable to obtain LocalDateTime from TemporalAccessor: {},ISO,Asia/Shanghai resolved to 2022-01-28 of type</strong> <strong>java.time.format.Parsed</strong>; nested exception is com.fasterxml.jackson.databind.exc.InvalidFormatException: Cannot deserialize value of type <code>java.time.LocalDateTime</code> from String “2022-01-28”: Failed to deserialize java.time.LocalDateTime: (java.time.format.DateTimeParseException) Text ‘2022-01-28’ could not be <strong>parsed: Unable to obtain LocalDateTime from TemporalAccessor</strong>: {},ISO,Asia/Shanghai resolved to 2022-01-28 of type java.time.format.Parsed<EOL> at [Source: (PushbackInputStream); line: 1, column: 75] (through reference chain: com.bootadmin1.bootajaxtest.domain.NXBMembers[“createDate”])]</p><p>指向了时间格式问题，仔细观察发现，后端的数据是这样<br><img src="https://img-blog.csdnimg.cn/29b1ec75b1b54a5fad357a009230e2b7.png" alt="数据库中"><br>而前端的数据是这样<br><img src="https://img-blog.csdnimg.cn/20ab6c6452be4daca14eb6ffc34c75e7.png" alt="页面的格式"></p><p>然后使用postman补全数据，发现还是报错，根据上面的信息考虑是不是前端将数据转为了String，从而无法解析</p><p><img src="https://img-blog.csdnimg.cn/e04aa8c07efe477a80ce9ea3d376db3b.png" alt="仍然报错">结果发现是controller层少写了时间hh:mm:ss<br><img src="https://img-blog.csdnimg.cn/fdedd334f6c74bbbad5eda58543da559.png" alt="添加上"></p><p>重新运行后修改操作还是报错400</p><p>因为时间不需要修改，在此尝试直接不传日期数据（属于是掩耳盗铃，不过没办法）<br>把this.formData = res.data直接list赋值改为属性赋值<br><img src="https://img-blog.csdnimg.cn/2ecddf31edb94b368c36120b0696b3d6.png" alt="但是不能三个属性都双向绑定，否则都不能修改"></p><p><img src="https://img-blog.csdnimg.cn/17d0d8c481704f72a817164e1d0111ad.png" alt="不要绑定position"></p><pre><code>      //弹出编辑窗口        handleUpdate(row) &#123;            axios.get(&quot;/nxbmem/&quot;+row.memberid).then((res)=&gt;&#123;                // if(res.data.flag &amp;&amp; res.data != null )&#123;                    this.dialogFormVisible4Edit = true;                    this.formData.username = res.data.username;                    this.formData.memberid = res.data.memberid;                    // this.formData.position = res.data.position;                //我们希望不能修改id和name，可以修改position                //因此position不要动态双向绑定                //一定要一个属性一个属性的挨个赋值，否则会把不想重传的属性给赋值重传了                //并且可以防止有些属性不便于修改所带来的问题                // &#125;else&#123;                //     this.$message.error(&quot;数据同步失败，自动刷新&quot;);                // &#125;            &#125;).finally(()=&gt;&#123;                //2.重新加载数据                this.getAll();            &#125;);        &#125;,        //修改        handleEdit() &#123;            axios.put(&quot;/nxbmem&quot;,this.formData).then((res)=&gt;&#123;                //判断当前操作是否成功                    //1.关闭弹层                    this.dialogFormVisible4Edit = false;                    this.$message.success(&quot;自动刷新&quot;);                    // this.$message.error(&quot;修改失败&quot;);            &#125;).finally(()=&gt;&#123;                //2.重新加载数据                this.getAll();            &#125;);        &#125;,</code></pre><p>这样后台就成这样了~<br><img src="https://img-blog.csdnimg.cn/06b27812b6c54529b80bf880c7b2cdde.png" alt="可以正常修改"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>由于前端对数据类型并不会区分，后端传的啥前端就显示啥，所以DateTime的前端显示和后端输出不一致，需要指定@JsonFormat</p><pre><code>  @TableField(value = &quot;creatDate&quot;)  @JsonFormat(pattern = &quot;yyyy-MM-dd hh:mm:ss&quot;, timezone = &quot;Asia/Shanghai&quot;)  private LocalDateTime createDate;</code></pre></li></ul><ul><li>并且即便是格式相同，也只能一定保证前端正确接受，而前端如果设置时间post给后端，后端可能需要额外重写业务层的post逻辑</li></ul>]]></content>
      
      
      <categories>
          
          <category> 找吖找Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BindingException: Invalid bound statement (not found)</title>
      <link href="/zjh/2022/01/28/BindingException-Invalid-bound-statement-not-found/"/>
      <url>/zjh/2022/01/28/BindingException-Invalid-bound-statement-not-found/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>springboot+mybatisplus<br>报错：未绑定<br>只是对ID(主键)进行操作的时候会有这个绑定的错误</p><p><img src="https://img-blog.csdnimg.cn/d7ea186d0d07478cb52840670e3154f6.png"></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ul><li>springboot不是配置地狱，既然其他与ID无关的操作都能跑，那问题基本是出在了主键绑定上了</li><li>而mybatis plus+springboot会自动扫描，扫描等配置问题可以不考虑</li><li>而主键，属性的绑定是在domain层，所以去找这个对应的Bean</li></ul><p><img src="https://img-blog.csdnimg.cn/66271f245f8048a6b4c0d73222153575.png" alt="定位到pojo层"><br>将@TableField改为@TableID，绑定主键</p>]]></content>
      
      
      <categories>
          
          <category> 找吖找Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合SSM</title>
      <link href="/zjh/2022/01/28/springboot%E6%95%B4%E5%90%88SSM/"/>
      <url>/zjh/2022/01/28/springboot%E6%95%B4%E5%90%88SSM/</url>
      
        <content type="html"><![CDATA[<h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><h2 id="整合JUnit"><a href="#整合JUnit" class="headerlink" title="整合JUnit"></a>整合JUnit</h2><ul><li><p>@SpringBootTest支持@Autowired注入</p></li><li><p>Test依赖会自动生成</p><p>  @SpringBootTest//表示这是一个测试类<br>  class BootAjaxtestApplicationTests {</p><p>  //1,@Autowired注入要测试的对象</p><p>  @Test//各个Test方法<br>  void contextLoads() {<br>  //2，Test方法体中调用注入对象的方法或属性</p><p>  }</p><p>  @Test<br>  void contextLoads2() {<br>  }}    </p></li></ul><h3 id="任意位置test-设置引导类"><a href="#任意位置test-设置引导类" class="headerlink" title="任意位置test(设置引导类)"></a>任意位置test(设置引导类)</h3><p>如果更改了测试类的位置，那么需要修改为<br>@SpringBootTest(classes = 主类名.class)<br><strong>即指明测试集的配置类是主类下的 or 这个测试类是主类的测试类</strong></p><h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><h3 id="配置yml"><a href="#配置yml" class="headerlink" title="配置yml"></a>配置yml</h3><pre><code>spring:  datasource:    username: 账号(通常为root)    password: 密码    url: jdbc:mysql://localhost:3306/数据库名    driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><ul><li>url后可以接时区，utf-8等设置</li><li>mysql5.0驱动名去掉cj</li></ul><h3 id="Mybatis测试"><a href="#Mybatis测试" class="headerlink" title="Mybatis测试"></a>Mybatis测试</h3><h4 id="dao层的使用"><a href="#dao层的使用" class="headerlink" title="dao层的使用"></a>dao层的使用</h4><p><strong>DAO层定义的接口可以添加一些方法，并且可以直接注入使用，如果不进行前后端交互，仅仅使用接口就可以了</strong></p><p><a href="https://blog.csdn.net/mn_kw/article/details/80985392">链接：domain和dao层</a><br><strong>domain类就是bean类</strong><br><strong>有dao和domain才能从数据库拿出来的数据编程bean，bean又可以通过ajax技术转为json和前端交互</strong></p><p>@Mapper使其被容器识别到<br>@Mapper的作用是可以给mapper接口自动生成一个实现类,让spring对mapper接口的bean进行管理,并且可以省略去写复杂的xml文件<br>    <img src="https://img-blog.csdnimg.cn/f7620aa9c03d4632bac0c875a2be71b7.png" alt="定义Dao接口"></p><pre><code>@Mapperpublic interface YebDao &#123;    @Select(&quot;select * from t_joblevel where id = #&#123;id&#125;&quot;)    public JobLevel getById(Integer id);&#125;</code></pre><p>需要注入<br><img src="https://img-blog.csdnimg.cn/3fd0cdc8cc904e24a1e49a41041499fa.png" alt="注入，测试"></p><pre><code>@SpringBootTest//表示这是一个测试类class BootAjaxtestApplicationTests &#123;    //1,@Autowired注入要测试的对象,Dao接口也可以注入@Autowiredprivate YebDao yebDao;//可能会假报错，能正常运行    //注入了Dao接口，可以使用Dao定义的@Select    @Test    void sql1() &#123;        System.out.println(yebDao.getById(1));    &#125;&#125;</code></pre><h2 id="整合MyBatis-Plus"><a href="#整合MyBatis-Plus" class="headerlink" title="整合MyBatis-Plus"></a>整合MyBatis-Plus</h2><p>这玩意是真的叼~<br><strong>extends BaseMapper&lt;&gt;之后连sql都可以不用写了</strong></p><h3 id="1，添加坐标依赖"><a href="#1，添加坐标依赖" class="headerlink" title="1，添加坐标依赖"></a>1，添加坐标依赖</h3><p>MyBatis-Plus是国内开发的，只能通过手动在pom.xml添加依赖</p><pre><code>        &lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;3.5.0&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>坐标查询方式在上面的两个大标题中</p><h3 id="2，定义数据层接口于映射配置"><a href="#2，定义数据层接口于映射配置" class="headerlink" title="2，定义数据层接口于映射配置"></a>2，定义数据层接口于映射配置</h3><pre><code>@Mapperpublic interface YebDao extends BaseMapper&lt;JobLevel&gt; &#123;   //继承BaseMapper，作用于JobLevel的Bean&#125;</code></pre><h3 id="3，MyBatisPlus可用的CRUD方法"><a href="#3，MyBatisPlus可用的CRUD方法" class="headerlink" title="3，MyBatisPlus可用的CRUD方法"></a>3，MyBatisPlus可用的CRUD方法</h3><p><img src="https://img-blog.csdnimg.cn/0ef764fe9ad74536ba802e2d7e161b2f.png" alt="包含了太多方法了，CRUD啥都有"><a href="https://www.jianshu.com/p/ceb1df475021">链接：方法使用示例</a></p><h4 id="一定要关闭驼峰命名"><a href="#一定要关闭驼峰命名" class="headerlink" title="一定要关闭驼峰命名"></a>一定要关闭驼峰命名</h4><pre><code>mybatis-plus:  configuration:    # 是否开启自动驼峰命名规则（camel case）映射，#    即从经典数据库列名 A_COLUMN（下划线命名） #    到经典 Java 属性名 aColumn（驼峰命名） 的类似映射    map-underscore-to-camel-case: false</code></pre><h2 id="整合Druid"><a href="#整合Druid" class="headerlink" title="整合Druid"></a>整合Druid</h2><p>同样，德鲁伊是阿里开发的数据源（数据连接池）框架，需要在maven repository找坐标<br>    <img src="https://img-blog.csdnimg.cn/ea0773633f974665bb8ef656987ea1b9.png" alt="选择启动器"></p><pre><code>&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt; /****************application.yml************/#spring:#  datasource:#    username: root#    password: zjh521418#    url: jdbc:mysql://localhost:3306/yeb#    driver-class-name: com.mysql.cj.jdbc.Driver##    type: com.alibaba.druid.pool.DruidDataSource在标准配置下加这句，或下面整合配置：spring:   datasource:    druid:      username: root      password: zjh521418      url: jdbc:mysql://localhost:3306/yeb      driver-class-name: com.mysql.cj.jdbc.Driver#德鲁伊专用配置法</code></pre><h2 id="整合总结"><a href="#整合总结" class="headerlink" title="整合总结"></a>整合总结</h2><ul><li>导入对应的starter依赖</li><li>对非默认值的项进行配置</li></ul><h1 id="postman测试接口"><a href="#postman测试接口" class="headerlink" title="postman测试接口"></a>postman测试接口</h1><p><a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a><br><a href="https://www.jianshu.com/p/d3eaed7b876a">教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot注意点1</title>
      <link href="/zjh/2022/01/28/springboot%E6%B3%A8%E6%84%8F%E7%82%B91/"/>
      <url>/zjh/2022/01/28/springboot%E6%B3%A8%E6%84%8F%E7%82%B91/</url>
      
        <content type="html"><![CDATA[<h1 id="边缘知识"><a href="#边缘知识" class="headerlink" title="边缘知识"></a>边缘知识</h1><h2 id="tomcat服务器"><a href="#tomcat服务器" class="headerlink" title="tomcat服务器"></a>tomcat服务器</h2><p>tomcat是用java编写的服务器，在springboot中把tomcat的内容全部托管，因此可以使用tomcat服务器。但需要导入依赖tomcat-embed-core和spring-boot-starter-tomcat</p><p>同时tomcat也可以被其他的技术所替换，例如Jetty:spring-boot-starter-Jetty<br>例如:undertow<br><strong>轻量级的项目可以尝试使用以下配置，tomcat负载能力较强！</strong><br><img src="https://img-blog.csdnimg.cn/234a6f7d00104eeea27db83136fc8ac7.png" alt="剔除tomcat依赖，导入jetty依赖"></p><p><strong>springboot封装了这些技术，如果发现哪个技术不好用，直接改依赖就好了~~</strong></p><h2 id="REST风格开发-风格不是规范"><a href="#REST风格开发-风格不是规范" class="headerlink" title="REST风格开发(风格不是规范)"></a>REST风格开发(风格不是规范)</h2><p>Representational State Transfer:表现形式状态转换——一种访问网络资源的格式</p><p><img src="https://img-blog.csdnimg.cn/de6261b1d72545b284a66cc97906b243.png" alt="定义"><br><img src="https://img-blog.csdnimg.cn/95326a9abe5d4c978b145b90545219a4.png" alt="常见访问行为"></p><h3 id="哪些不同？"><a href="#哪些不同？" class="headerlink" title="哪些不同？"></a>哪些不同？</h3><p>例如：</p><ul><li>在controller包下的UserController类中，@RequestMapping有8种提交方式method,通过不同的提交方式来区分上图种的不同访问行为</li><li>路径变量@PathVariable的格式要注意</li></ul><p><img src="https://img-blog.csdnimg.cn/71710de3e6bb477f813fa3f288927c42.png" alt="简化操作"></p><pre><code>//Rest模式@RestController@RequestMapping(&quot;该BookController下的跟访问路径&quot;)public class BookController &#123;    @GetMapping//可以带路径参数，没有可以不写    public String getById()&#123;        System.out.println(&quot;springboot is running...&quot;);        return &quot;springboot is running...&quot;;    &#125;&#125;</code></pre><h2 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h2><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/">springboot——application-properties官方文档</a></p><p><strong>“每一个配置对应的都是一种技术”</strong></p><h3 id="同时出现properties-yml-yaml时"><a href="#同时出现properties-yml-yaml时" class="headerlink" title="同时出现properties.yml.yaml时"></a>同时出现properties.yml.yaml时</h3><ul><li>不同属性相互叠加</li><li>相同属性优先级：properties&gt;yml&gt;yaml</li></ul><h3 id="yml-yaml没有自动提示"><a href="#yml-yaml没有自动提示" class="headerlink" title="yml yaml没有自动提示"></a>yml yaml没有自动提示</h3><p>弹提示的功能是springboot提供的，而不是idea提供的<br><a href="https://www.bilibili.com/video/BV15b4y1a7yG?p=20&spm_id_from=pageDriver">链接：解决属性提示消失</a></p><p><img src="https://img-blog.csdnimg.cn/dd67d73d9653432abbcb2c05ab4b111e.png" alt="yaml为什么优秀">注：</p><ul><li>IDEA处理yml文件可以使用tab</li><li>不用加引号</li></ul><h3 id="单一取值-Value-SpEL"><a href="#单一取值-Value-SpEL" class="headerlink" title="单一取值@Value + SpEL"></a>单一取值@Value + SpEL</h3><ul><li>只能在注册类中使用，例如@RestController下</li><li>可能跟Lombok下的@value冲突</li></ul><p>已经在application.yml文件中配置了</p><pre><code>user1:  name: 张家豪users3: [&#123;name:zhangsan,age:18&#125;,&#123;name:lisi,age:17&#125;]users2:  -    name: zhangsan    age: 18  -    name: lisi    age: 17</code></pre><p>那么可以在任意位置按如下操作取值</p><pre><code>@Value(&quot;$&#123;name2[1].name&#125;&quot;)//取出1号索引位的lisiprivate String namexxx;//赋值给namexxx</code></pre><h3 id="在配置中引用配置"><a href="#在配置中引用配置" class="headerlink" title="在配置中引用配置"></a>在配置中引用配置</h3><pre><code>yml文件中baseDir: d:/spring/springboottempDir: $&#123;baseDir&#125;/temp</code></pre><h3 id="转义解析"><a href="#转义解析" class="headerlink" title="转义解析"></a>转义解析</h3><p>yml文件不需要加引号“” 如果加了引号，内容将被解析，比如</p><pre><code>tempDir: &quot;$&#123;baseDir&#125;/temp&quot;会被转义出一个/t制表符</code></pre><h2 id="自动装配Environment"><a href="#自动装配Environment" class="headerlink" title="自动装配Environment"></a>自动装配Environment</h2><pre><code>@Autowiredprivate Environment environment;</code></pre><p>这样一来，所有配置信息都封装了，引用的时候用getProperties就可以取出</p><h2 id="Spring的取数据方式：Bean绑定"><a href="#Spring的取数据方式：Bean绑定" class="headerlink" title="Spring的取数据方式：Bean绑定"></a>Spring的取数据方式：Bean绑定</h2><p>Bean包下</p><pre><code>@Component//注入容器，让这个bean成为spring管控的bean@ConfigurationProperties(prefix = &quot;user1&quot;)//前缀//因为配置了// user1://  name: 张家豪//  age: 21@Data//lombok下的的注解，提供get set等方法public class UserBean &#123;    private String name;    private int age;&#125;</code></pre><p>controller包下</p><pre><code>@AutowiredUserBean userBean;//实例化bean@GetMapping(&quot;/test&quot;)    public void beantest()&#123;        System.out.println(userBean);//当页面访问时，控制台输出    &#125;</code></pre><h3 id="Autowired和Bean注意点"><a href="#Autowired和Bean注意点" class="headerlink" title="Autowired和Bean注意点"></a>Autowired和Bean注意点</h3><p>这两个都是配套使用，Bean代表只有这一个单例并绑定配置文件的哪个前缀；Autowired是注入Bean实例<br>这个userBean实例只能在当前的controller层读取，不能在其他地方使用</p>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>axios+element+vue的前端数据交互框架</title>
      <link href="/zjh/2022/01/26/axios-element-vue%E7%9A%84%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E6%A1%86%E6%9E%B6/"/>
      <url>/zjh/2022/01/26/axios-element-vue%E7%9A%84%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Element基本结构"><a href="#Element基本结构" class="headerlink" title="Element基本结构"></a>Element基本结构</h1><p>一个网页组件库，需要调用导入的库，语法比较特别，不同于前端语法</p><p><strong>固定的几个引入链接，位置千万不能弄错</strong>，链接的作用是在线引入渲染文件，可以不用下载到本地<br>添加组件和修改功能只再body中的div  和 script中的new Vue代码块中进行，并且要注意绑定~~<br><a href="https://element.eleme.cn/#/zh-CN/component/button">Element官网</a><br>Element给出的代码是一整块，需要自己区分哪个是组件，哪个是依赖，哪个是控制，分别放入哪个位置<br><img src="https://img-blog.csdnimg.cn/3050347e2d1a48f589b657ce16f9156e.png"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;后台管理&lt;/title&gt;&lt;!--Style相当于CSS--&gt;&lt;!-- 引入样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;对应模块名&quot;&gt;    &lt;!--这里放入组件--&gt;  &lt;/div&gt;&lt;/body&gt;&lt;!-- import Vue before Element --&gt;&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;!-- import JavaScript --&gt;&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    &lt;!--Vue的核心对象相当于js--&gt;    new Vue(&#123;        el:&quot;#对应模块名&quot;    &#125;)&lt;/script&gt;&lt;/html&gt;</code></pre><h1 id="组件布局：表格"><a href="#组件布局：表格" class="headerlink" title="组件布局：表格"></a>组件布局：表格</h1><h2 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h2><pre><code>&lt;template&gt;引入&lt;body&gt;&lt;style&gt;引入&lt;head&gt;&lt;script&gt;引入new Vue(&#123;    el:&quot;#对应模块名&quot;,    )&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/66c55d2e4e754dd2afa82bbcf6a7f3da.png"></p><h3 id="修改表的结构，内容"><a href="#修改表的结构，内容" class="headerlink" title="修改表的结构，内容"></a>修改表的结构，内容</h3><ul><li><p>要把templeate和@data()中return的tableData:[{ ]}对应都修改了</p></li><li><p>align=”center”</p></li><li><p>注意配置要被左&lt;&gt;包裹</p><h3 id="添加数据无关列-操作按钮"><a href="#添加数据无关列-操作按钮" class="headerlink" title="添加数据无关列(操作按钮)"></a>添加数据无关列(操作按钮)</h3></li><li><p>先添加一个操作列operate</p></li><li><p>这个列不需要属性prop</p></li><li><p>这个列都需要操作按钮，所以把按钮放在列中</p><pre><code>  &lt;template&gt;  &lt;el-table&gt;      ......略      &lt;el-table-column                  align=&quot;center&quot;                  label=&quot;操作&quot;&gt;  &lt;!--这个列不需要属性，所以不加prop--&gt;          &lt;el-row&gt;              &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle&gt;&lt;/el-button&gt;              &lt;el-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; circle&gt;&lt;/el-button&gt;          &lt;/el-row&gt;  &lt;!--按钮放在table-column列中，每列都有--&gt;      &lt;/el-table-column&gt;      &lt;/el-table&gt;  &lt;/template&gt;</code></pre></li></ul><h3 id="数字编号"><a href="#数字编号" class="headerlink" title="数字编号"></a>数字编号</h3><p><img src="https://img-blog.csdnimg.cn/503071d83ceb4d418a41994a4c04a1a5.png" alt="找到了有数字编号的(不同于id)">这个数字编号是第一列，所以去源码中找第一列  直接扔进去</p><pre><code>   &lt;el-table-column  type=&quot;index&quot;  width=&quot;50&quot;&gt;&lt;/el-table-column&gt;</code></pre><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>同理，找到有复选框的源码，选择第一列</p><h3 id="复选取对象：可以批量操作"><a href="#复选取对象：可以批量操作" class="headerlink" title="复选取对象：可以批量操作"></a>复选取对象：可以批量操作</h3><ul><li>表头属性加@selection-change=”handleSelectionChange”</li><li>在method屁股后面 handleSelectionChange(val) {<pre><code>  this.multipleSelection = val;  可以添加具体执行方法&#125;，</code></pre></li><li>在data()return{}中添加multipleSelection: []，注意不要加到tabledata中了</li></ul><h3 id="批量删除、新增按钮"><a href="#批量删除、新增按钮" class="headerlink" title="批量删除、新增按钮"></a>批量删除、新增按钮</h3><ul><li>添加<strong>按钮</strong>，绑定@click事件，点击后弹出对话框<br><img src="https://img-blog.csdnimg.cn/bd023d9dd3ef415c9318d3059b5c760b.png" alt="官方文档解析"></li></ul><h3 id="对话框-表单：查询和新增"><a href="#对话框-表单：查询和新增" class="headerlink" title="对话框+表单：查询和新增"></a>对话框+表单：查询和新增</h3><p>当点击“新增”按钮的时候，弹出对话框，对话框的内容是一个表单，表单中填数据，点击“确定”则POST给服务器，返回一个是否成功的信息</p><h4 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h4><ul><li>点击按钮弹出对话框@click=” 对话框名 “</li><li>对话框设置对应的“对话框名” :visible.sync=”对话框名”</li><li>在return中添加初始不可见 对话框名:false</li></ul><pre><code>    &lt;!--批量删除、新增按钮--&gt;    &lt;el-row&gt;        &lt;el-button type=&quot;danger&quot; &gt;批量删除&lt;/el-button&gt;        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible1=true&quot; &gt;新增&lt;/el-button&gt;        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible2=true&quot; &gt;查询&lt;/el-button&gt;        &lt;!--查询用dialogVisible2表单--&gt;    &lt;/el-row&gt;    &lt;!--新增对话框dialogVisible1--&gt;    &lt;el-dialog            title=&quot;新增数据，填写表单后确定&quot;            :visible.sync=&quot;dialogVisible1&quot;            width=&quot;30%&quot;           &gt;        &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;    &lt;el-button @click=&quot;dialogVisible1 = false&quot;&gt;取 消&lt;/el-button&gt;    &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible1 = false&quot;&gt;确 定&lt;/el-button&gt;            &lt;!--确定取消都使dialogVisible1不可见--&gt;  &lt;/span&gt;    &lt;/el-dialog&gt;    &lt;!--查询对话框dialogVisible2--&gt;    &lt;el-dialog            title=&quot;新增数据，填写表单后查询&quot;            :visible.sync=&quot;dialogVisible2&quot;            width=&quot;30%&quot;    &gt;        &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;    &lt;el-button @click=&quot;dialogVisible2 = false&quot;&gt;取 消&lt;/el-button&gt;    &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible2 = false&quot;&gt;查 询&lt;/el-button&gt;            &lt;!--确定取消都使dialogVisible2不可见--&gt;  &lt;/span&gt;    &lt;/el-dialog&gt;/*********************************************/ data() &#123;            return &#123;            dialogVisible1: false,            dialogVisible2: false,            //表单初始不可见，必须设置，不然点都点不出来&#125;&#125;</code></pre><h3 id="新增表单"><a href="#新增表单" class="headerlink" title="新增表单"></a>新增表单</h3><p>添加在两个el-dialog对话框&lt;&gt;尖括号之间</p><h3 id="查询表单"><a href="#查询表单" class="headerlink" title="查询表单"></a>查询表单</h3><p>添加在两个el-dialog对话框&lt;&gt;尖括号之间</p><ul><li>这个案例的查询功能为：同时选定职称名 和 职称等级</li></ul><h3 id="前端页面框架"><a href="#前端页面框架" class="headerlink" title="前端页面框架"></a>前端页面框架</h3><ul><li>批量删除需要getID的List</li><li>查询可以共用一个模型绑定数据</li></ul><p><img src="https://img-blog.csdnimg.cn/19ad40a967454ea5897ed7c5ff7d1f17.png" alt="基本结构"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>异常处理、多线程</title>
      <link href="/zjh/2022/01/25/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/zjh/2022/01/25/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>早年写在csdn上的笔记，因为没用markdown写，所以滕不过来，直接上链接咯~</p><p><a href="https://blog.csdn.net/m0_56079407/article/details/119790045?spm=1001.2014.3001.5501">为什么synchronized同步代码块既不能框多，也不能框少</a></p><p><a href="https://blog.csdn.net/m0_56079407/article/details/119788505?spm=1001.2014.3001.5501">yield、join、sleep区别</a></p><p><a href="https://blog.csdn.net/m0_56079407/article/details/119839272?spm=1001.2014.3001.5501">生产者消费者案例</a></p><p><a href="https://blog.csdn.net/m0_56079407/article/details/119676784?spm=1001.2014.3001.5501">三种异常处理机制</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO:TCP URL网络编程</title>
      <link href="/zjh/2022/01/25/IO-TCP-URL%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/zjh/2022/01/25/IO-TCP-URL%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>方便起见，所有代码都直接throws异常，没有处理<br>以“Client把文件上传至Server为例”</p><h2 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h2><ul><li>Socket s = new Socket(“Sever的IP地址” , 端口号);</li><li>OutputStream os = s.getOutputStream();</li></ul><ol><li>先建立Socket连接</li><li>“上传文件”，所以getOutputStream</li><li>普通IO(FileInputStream)先读取文件，然后赋值给网络IO流</li></ol><pre><code>    public class Client9548 &#123;    public static void main(String[] args) throws IOException &#123;        //Client IP：192.168.3.82        Socket clientsocket = new Socket(&quot;192.168.3.47&quot;,9548);//Server的IP，共用的端口        File file = new File(&quot;D:\\FFOutput\\201983250028张家豪.docx&quot;);        OutputStream outputStream = clientsocket.getOutputStream();//从Client输出        FileInputStream fis = new FileInputStream(file);        byte[] bbuf = new byte[1024];        int len;        while((len=fis.read(bbuf))!=-1)&#123;            outputStream.write(bbuf,0,len);        &#125;        outputStream.close();        fis.close();            &#125;&#125;</code></pre><h2 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h2><ul><li>ServerSocket ss = new ServerSocket(端口号);</li><li>Socket s = ss.accept();</li><li>InputStream is = s.getInputStream();</li></ul><ol><li>Server端会多一个ServerSocket端口，并且也需要额外关闭</li><li>“接受文件”，所以s.getInputStream();</li><li>其他的本地读写操作都是普通IO</li></ol><p>public class Server9548 {<br>    public static void main(String[] args) throws IOException {<br>//Server IP:192.168.3.47<br>        ServerSocket serverSocket = new ServerSocket(9548);//new ServerSocket，端口和Client端口保持一致</p><pre><code>    Socket sa = serverSocket.accept();//SeverScoket——&gt;socket    InputStream is = sa.getInputStream();//输入流，接受来自Client的文件数据    //这下面创建输出流，保存在硬盘    File file = new File(&quot;D:\\fromClient\\file4.docx&quot;);    FileOutputStream fos = new FileOutputStream(file);   byte[] bbuf = new byte[1024];    int len;    while((len=is.read(bbuf))!=-1)&#123;        fos.write(bbuf);    &#125;        fos.close();    sa.close();    serverSocket.close();//注意接口关闭    &#125;</code></pre><p>}</p><h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><pre><code>URL url = new URL(&quot;http://localhost:8080/examples/myTest.txt&quot;);System.out.println(&quot;getProtocol() :&quot;+url.getProtocol());System.out.println(&quot;getHost() :&quot;+url.getHost());System.out.println(&quot;getPort() :&quot;+url.getPort());System.out.println(&quot;getPath() :&quot;+url.getPath());System.out.println(&quot;getFile() :&quot;+url.getFile());System.out.println(&quot;getQuery() :&quot;+url.getQuery());</code></pre><p><img src="https://img-blog.csdnimg.cn/7a6dc6222f614b6fa15ce2b6a1a926b4.png"></p><h2 id="从指定网址下载指定文件"><a href="#从指定网址下载指定文件" class="headerlink" title="从指定网址下载指定文件"></a>从指定网址下载指定文件</h2><pre><code>public class URLTest1 &#123;    public static void main(String[] args) throws IOException &#123;        URL url1 = new URL(&quot;https://img-blog.csdnimg.cn/img_convert/5cef01f2bb72055365b892b39b01cdfb.png&quot;);//URL地址        HttpURLConnection hURLc =  (HttpURLConnection) url1.openConnection();//建立URL连接+强转        hURLc.connect();//连接        //从该URL地址下载，input流        InputStream URLis = hURLc.getInputStream();        //导入本地，普通IO        File file = new File(&quot;temp1.jpg&quot;);        FileOutputStream fos = new FileOutputStream(file);        //从Client读，并写到Server硬盘        byte[] bbuf = new byte[1024];        int len;        while((len=URLis.read(bbuf))!=-1)&#123;            fos.write(bbuf,0,len);        &#125;                URLis.close();        fos.close();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/zjh/2022/01/25/JDBC/"/>
      <url>/zjh/2022/01/25/JDBC/</url>
      
        <content type="html"><![CDATA[<p>java.sql支持多数据库访问</p><ul><li>Java与SQL对应数据类型转换表</li></ul><table><thead><tr><th>Java类型</th><th>SQL类型</th></tr></thead><tbody><tr><td>boolean</td><td>BIT</td></tr><tr><td>byte</td><td>TINYINT</td></tr><tr><td>short</td><td>SMALLINT</td></tr><tr><td>int</td><td>INTEGER</td></tr><tr><td>long</td><td>BIGINT</td></tr><tr><td>String</td><td>CHAR,VARCHAR,LONGVARCHAR</td></tr><tr><td>byte array</td><td>BINARY , VAR BINARY</td></tr><tr><td>java.sql.Date</td><td>DATE</td></tr><tr><td>java.sql.Time</td><td>TIME</td></tr><tr><td>java.sql.Timestamp</td><td>TIMESTAMP</td></tr></tbody></table><h1 id="连接，mysql重点用第4个"><a href="#连接，mysql重点用第4个" class="headerlink" title="连接，mysql重点用第4个"></a>连接，mysql重点用第4个</h1><h2 id="1，不出现第三方API，高可移植性"><a href="#1，不出现第三方API，高可移植性" class="headerlink" title="1，不出现第三方API，高可移植性"></a>1，不出现第三方API，高可移植性</h2><pre><code>    //Driver driver = new com.mysql.jdbc.Driver();    //创建Driver实例,用如下反射方法创建更有普适性    Class clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);    Driver driver = (Driver)clazz.newInstance();    String url = &quot;jdbc:mysql://localhost:3306/yeb&quot;;//数据库的url    //jdbc:mysql://localhost:3306/是固定前缀//Properties：用户名和密码    Properties info= new Properties();    info.setProperty(&quot;user&quot;,&quot;root&quot; );    info.setProperty(&quot;password&quot;, &quot;zjh521418&quot;);//获取连接    Connection connect = driver.connect(url, info);//返回一个Connection    System.out.println(connect);</code></pre><h2 id="2，DriverManager替换Driver"><a href="#2，DriverManager替换Driver" class="headerlink" title="2，DriverManager替换Driver"></a>2，DriverManager替换Driver</h2><pre><code>//反射获取Driver对象     Class clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        Driver driver = (Driver) clazz.newInstance();//提供三个基本信息        String url = &quot;jdbc:mysql://localhost:3306/yeb&quot;;        String user = &quot;root&quot;;        String password = &quot;zjh521418&quot;;//注册驱动,DriverManager替换Driver        DriverManager.registerDriver(driver);//获取链接        Connection connection = DriverManager.getConnection(url,user,password);        System.out.println(connection);</code></pre><h2 id="3，mysql的自动注册驱动"><a href="#3，mysql的自动注册驱动" class="headerlink" title="3，mysql的自动注册驱动"></a>3，mysql的自动注册驱动</h2><p>中间的注册步骤全部可以省（仅对mysql可以）</p><pre><code>//提供三个基本信息        String url = &quot;jdbc:mysql://localhost:3306/yeb&quot;;        String user = &quot;root&quot;;        String password = &quot;zjh521418&quot;;//反射，静态加载Driver对象//     Class clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//        Driver driver = (Driver) clazz.newInstance();//注册驱动,DriverManager替换Driver::::::mysql会自动注册驱动//        DriverManager.registerDriver(driver);        //获取链接        Connection connection = DriverManager.getConnection(url,user,password);        System.out.println(connection);</code></pre><h2 id="4，配置文件加载：松耦合"><a href="#4，配置文件加载：松耦合" class="headerlink" title="4，配置文件加载：松耦合"></a>4，配置文件加载：松耦合</h2><p>读配置文件——流——存Properties——get</p><pre><code>    //读取配置信息:properties——&gt;流    InputStream is = ConnectionTest1.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);//还可以写成InputStream is =ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;配置文件名&quot;);    Properties pros = new Properties();    pros.load(is);//配置信息存储到Propertires中    String user = pros.getProperty(&quot;user&quot;);    String password = pros.getProperty(&quot;password&quot;);    String url = pros.getProperty(&quot;url&quot;);    String driverClass = pros.getProperty(&quot;driverClass&quot;);    //加载驱动    Class.forName(driverClass);    //获取连接    Connection conn = DriverManager.getConnection(url, user, password);        System.out.println(conn);</code></pre><p><img src="https://img-blog.csdnimg.cn/0c43761779654ccfbd7c3d3707883653.png" alt="用properties配置"><img src="https://img-blog.csdnimg.cn/974e80bb735e4a79882d6514b608840c.png" alt="配置信息"></p><h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><h2 id="PreparedStatement实现"><a href="#PreparedStatement实现" class="headerlink" title="PreparedStatement实现"></a>PreparedStatement实现</h2><p>PreparedStatement是Statement的子对象，也是最常用的；原始的Statement无法解决SQL注入问题，所以弃用了。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>SQL语句被<strong>预编译</strong>并存储再PreparedStatement对象中，方便使用此对象多次执行<br><img src="https://img-blog.csdnimg.cn/619c79af7ac1469fb23c4874e64967f0.png"></p><h3 id="使用：增"><a href="#使用：增" class="headerlink" title="使用：增"></a>使用：增</h3><p>以增为例：向yeb数据库文件中的t_role表添加一组数据<br><img src="https://img-blog.csdnimg.cn/e1add7bb73354d6baa1b3dba7bf73320.png" alt="t_role表"></p><ul><li>固定连接操作+PreparedStatement三步操作</li><li>开发中一定像IO处理异常一样try-catch而不是简单的throws</li><li>开发中可以把固定操作封装成一个util工具</li></ul><pre><code>    /**********固定操作******************/        //读取配置信息:properties——&gt;流        InputStream is = ConnectionTest1.class.getClassLoader().getResourceAsStream(&quot;t_role.properties&quot;);        //还可以写成InputStream is =ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;配置文件名&quot;);        Properties pros = new Properties();        pros.load(is);//配置信息存储到Propertires中        String user = pros.getProperty(&quot;user&quot;);        String password = pros.getProperty(&quot;password&quot;);        String url = pros.getProperty(&quot;url&quot;);        String driverClass = pros.getProperty(&quot;driverClass&quot;);        //加载驱动        Class.forName(driverClass);        //获取连接        Connection conn = DriverManager.getConnection(url, user, password);    /***************使用PreparedStatement增删改查**************/        String sql = &quot;insert into t_role(name,nameZh)values(?,?)&quot;;//sql操作        PreparedStatement ps = conn.prepareStatement(sql);//预编译sql语句，返回PreparedStatement实例        //填充占位符？  索引从1开始        ps.setString(1, &quot;张家豪&quot;);//第一个属性值        ps.setString(2,&quot;大数据开发&quot; );//第二个属性值            /*******执行操作**********/        ps.execute();    /*************关闭流**************/        ps.close();        conn.close();</code></pre><h3 id="规范完整代码"><a href="#规范完整代码" class="headerlink" title="规范完整代码"></a>规范完整代码</h3><pre><code>        Connection conn = null;        PreparedStatement ps = null;//预编译sql语句，返回PreparedStatement实例        try &#123;/**********固定操作******************/            //读取配置信息:properties——&gt;流            InputStream is = ConnectionTest1.class.getClassLoader().getResourceAsStream(&quot;t_role.properties&quot;);            //还可以写成InputStream is =ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;配置文件名&quot;);            Properties pros = new Properties();            pros.load(is);//配置信息存储到Propertires中            String user = pros.getProperty(&quot;user&quot;);            String password = pros.getProperty(&quot;password&quot;);            String url = pros.getProperty(&quot;url&quot;);            String driverClass = pros.getProperty(&quot;driverClass&quot;);            //加载驱动            Class.forName(driverClass);            //获取连接            conn = DriverManager.getConnection(url, user, password);/***************使用PreparedStatement增删改查**************/            String sql = &quot;insert into t_role(name,nameZh)values(?,?)&quot;;//sql操作            ps = conn.prepareStatement(sql);            //填充占位符？  索引从1开始            ps.setString(1, &quot;张家豪&quot;);//第一个属性值            ps.setString(2,&quot;大数据开发&quot; );//第二个属性值/*******执行操作**********/            ps.execute();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;/*************关闭流**************/            try &#123;                if(ps != null)&#123;                ps.close();                &#125;            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if(ps != null)&#123;                conn.close();                &#125;            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;</code></pre><h3 id="使用：改"><a href="#使用：改" class="headerlink" title="使用：改"></a>使用：改</h3><pre><code>/************改**********/String sql = &quot;updatE t_role set nameZh = ? where name = ? &quot;;//sql语句对语法的大小写不敏感，即便是uPdAtE也能识别为update        PreparedStatement ps = conn.prepareStatement(sql);        ps.setObject(1, &quot;大数据开发工程师&quot;);        ps.setObject(2,&quot;张家豪&quot; );        ps.execute();        ps.close();        conn.close();</code></pre><h3 id="使用：删"><a href="#使用：删" class="headerlink" title="使用：删"></a>使用：删</h3><pre><code>    PreparedStatement ps = conn.prepareStatement(sql);    ps.setObject(1,&quot;张家豪&quot;);    ps.execute();    System.out.println(conn.getAutoCommit());    //返回true则提交成功    //但提交成功≠操作成功，操作成功需要保证业务正确    ps.close();    conn.close();</code></pre><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>execute——&gt;</p><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><ul><li>封装的JDBC，最简单的持久化框架</li><li>灵活，sql语句写在xml里，降低耦合度</li><li>提供xml标签，支持编写动态sql语句</li><li>提供映射标签，映射对象和数据库的字段(ORM)</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>对SQL语法要求高，编写工作量大</li><li>SQL语法依赖于数据库，移植性差</li></ul><p>springboot对mybatis进行封装，解决了跨平台问题</p><h1 id="Springboot整合JDBC"><a href="#Springboot整合JDBC" class="headerlink" title="Springboot整合JDBC"></a>Springboot整合JDBC</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h3 id="pom-yaml"><a href="#pom-yaml" class="headerlink" title="pom.yaml"></a>pom.yaml</h3><pre><code>spring:  datasource:    username: root    password: 123456    #?serverTimezone=UTC解决时区的报错    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8    driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><h2 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a>获取连接</h2><pre><code>@SpringBootTestclass Boot05ApplicationTests &#123;    @Qualifier(&quot;dataSource&quot; )    @Autowired    DataSource dataSource;    //注入数据源，以便下面获得数据库连接    @Test    void contextLoads() throws SQLException &#123;        //当且仅当@AutoWired注入了DataSource，这里才能运行        System.out.println(dataSource.getClass());//class com.zaxxer.hikari.HikariDataSource        Connection conn = dataSource.getConnection();//获取数据库连接        System.out.println(conn);    conn.close();&#125;&#125;</code></pre><p><strong>数据源DataSource有什么作用:</strong></p><ol><li>通过DataSource可以获取数据库连接Connection</li><li>通过DataSource创建JdbcTemplate操作数据库</li></ol><h2 id="JdbcTemplate-封装JDBC-CRUD"><a href="#JdbcTemplate-封装JDBC-CRUD" class="headerlink" title="JdbcTemplate:封装JDBC CRUD"></a>JdbcTemplate:封装JDBC CRUD</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>Spring Boot 默认提供了数据源，默认提供了org.springframework.jdbc.core.JdbcTemplate</li><li>JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作</li><li>不用再自己来关闭数据库连接</li></ol><p><strong>JdbcTemplate主要提供以下几类方法：</strong></p><ul><li><p>   <strong>execute方法</strong>：可以用于执行任何SQL语句，一般用于执行DDL语句；</p></li><li><p>   <strong>update方法及batchUpdate方法</strong>：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</p></li><li><p>   <strong>query方法及queryForXXX方法</strong>：用于执行查询相关语句；</p></li><li><p>  <strong>call方法</strong>：用于执行存储过程、函数相关语句。</p></li></ul><h3 id="controller类JDBCTemplate"><a href="#controller类JDBCTemplate" class="headerlink" title="controller类JDBCTemplate"></a>controller类JDBCTemplate</h3><pre><code>@RestControllerpublic class JDBCTemplate &#123;   @Autowired    JdbcTemplate jdbcTemplate;         /******下面写requestmapping****/      &#125;</code></pre><h3 id="增-update-GetMapping-“-add-……"><a href="#增-update-GetMapping-“-add-……" class="headerlink" title="增:update   +  @GetMapping(“/add/{……"></a>增:update   +  @GetMapping(“/add/{……</h3><p>前端处理注册数据，返回一个url，如：</p><pre><code>localhost:8080/add/&#123;张家豪&#125;/&#123;123456&#125;/&#123;13288888888&#125;/&#123;222222222@qq.com&#125;</code></pre><p>然后GetMapping处理这条url附带的信息</p><pre><code>//增    @GetMapping(&quot;/add/&#123;username&#125;/&#123;password&#125;/&#123;phonenum&#125;/&#123;email&#125;&quot;)//格式标准public String addUser(@PathVariable(&quot;username&quot;) String name,                      @PathVariable(&quot;password&quot;) String pass,                      @PathVariable(&quot;phonenum&quot;) String phone,                      @PathVariable(&quot;email&quot;) String e)&#123;    //占位符sql语句    String sql = &quot;insert into userinfo(username,password,phonenum,email) &quot;            + &quot;values(name,pass,phone,e)&quot;;    //执行sql    jdbcTemplate.update(sql);    //返回值    return &quot;添加成功&quot;;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSMp整合案例</title>
      <link href="/zjh/2022/01/25/SSMp%E6%95%B4%E5%90%88%E6%A1%88%E4%BE%8B/"/>
      <url>/zjh/2022/01/25/SSMp%E6%95%B4%E5%90%88%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="制作流程"><a href="#制作流程" class="headerlink" title="制作流程"></a>制作流程</h1><h2 id="导入依赖后Maven刷新"><a href="#导入依赖后Maven刷新" class="headerlink" title="导入依赖后Maven刷新"></a>导入依赖后Maven刷新</h2><pre><code>druid-spring-boot-starter//版本号spring-webmvclombok//简化pojo开发spring-boot-starter-jdbcspring-boot-starter-webmybatis-plus-boot-starter//版本号mysql-connector-javaspring-boot-starter-test</code></pre><h2 id="实体类pojo：对应数据表单"><a href="#实体类pojo：对应数据表单" class="headerlink" title="实体类pojo：对应数据表单"></a>实体类pojo：对应数据表单</h2><ul><li><strong>实体类名=表名</strong></li><li><strong>属性=列名</strong></li><li><strong>驼峰命名问题可以选择关闭or打开</strong></li></ul><pre><code>    mybatis-plus:      configuration:    # 是否开启自动驼峰命名规则（camel case）映射，    #    即从经典数据库列名 A_COLUMN（下划线命名）     #    到经典 Java 属性名 aColumn（驼峰命名） 的类似映射            map-underscore-to-camel-case: false    </code></pre><p>在domain包下</p><pre><code>//@AllArgsConstructor//@NoArgsConstructor//因为实际使用中都是用get set方法，所以不需要上面的构造器注释  @Datapublic class t_user &#123;    private Integer id;    private String name;    private String phone;&#125;</code></pre><h2 id="数据层开发：MybatisPlus-Druid"><a href="#数据层开发：MybatisPlus-Druid" class="headerlink" title="数据层开发：MybatisPlus+Druid"></a>数据层开发：MybatisPlus+Druid</h2><h3 id="yml配置信息"><a href="#yml配置信息" class="headerlink" title="yml配置信息"></a>yml配置信息</h3><pre><code>server:  port: 80    spring:  datasource:    druid:      username: root      password: zjh521418      url: JDBC://localhost:3306/yeb      driver-class-name: com.mysql.cj.jdbc.Driver                              #mybatis-plus:#  global-config: #   db-config: #     table-prefix: t_##      表名前缀，例如t_jobLevel前缀就是这个          </code></pre><h1 id="数据层开发Dao"><a href="#数据层开发Dao" class="headerlink" title="数据层开发Dao"></a>数据层开发Dao</h1><h2 id="数据层接口Dao：整合MP"><a href="#数据层接口Dao：整合MP" class="headerlink" title="数据层接口Dao：整合MP"></a>数据层接口Dao：整合MP</h2><ul><li>接口是interface不是class！！！！</li><li>接口可以extends接口~</li><li>这个Dao接口要继承BaseMapper接口</li><li>使用之前要@Autowried注入Dao</li></ul><p><img src="https://img-blog.csdnimg.cn/d6d3653e3b46445bad8b6b829e494cc3.png" alt="t_user表"></p><pre><code>@Mapperpublic interface UserDao extends BaseMapper&lt;t_user&gt;&#123;&#125;@Datapublic class t_user &#123;    private Integer id;    private String name;    private String phone;&#125;@AutowiredUserDao userDao;</code></pre><h3 id="MP：CRUD"><a href="#MP：CRUD" class="headerlink" title="MP：CRUD"></a>MP：CRUD</h3><p><img src="https://img-blog.csdnimg.cn/d37a7852260242a39583cb59efa18078.png" alt="增删改查都有"></p><pre><code>@Testpublic void testUserAdd()&#123;    t_user tu = new t_user();    tu.setId(2);    tu.setName(&quot;sada&quot;);    tu.setPhone(&quot;5654653215&quot;);    userDao.insert(tu);    &#125;</code></pre><h4 id="BUG记录"><a href="#BUG记录" class="headerlink" title="BUG记录"></a>BUG记录</h4><ul><li>java.lang.IllegalStateException: Failed to load ApplicationContext<br>Caused by: java.lang.NoSuchFieldError: APPLICATION_NDJSON<br>要保证命名规则相同 以及 属性类型对应    </li></ul><h2 id="Mybatis-Plus的配置"><a href="#Mybatis-Plus的配置" class="headerlink" title="Mybatis-Plus的配置"></a>Mybatis-Plus的配置</h2><p><img src="https://img-blog.csdnimg.cn/77cfc73228ec444bb5c294920d1295af.png" alt="可配置项超多"></p><h3 id="开启日志：log下"><a href="#开启日志：log下" class="headerlink" title="开启日志：log下"></a>开启日志：log下</h3><p>log即日志</p><p><strong>测试的时候可以开，但上线运行千万不要开，服务器会裂开</strong><br><img src="https://img-blog.csdnimg.cn/c658e8b2b1064433b30ea7b2d8bc783b.png"></p><h4 id="StdOutImpl：控制台输出"><a href="#StdOutImpl：控制台输出" class="headerlink" title="StdOutImpl：控制台输出"></a>StdOutImpl：控制台输出</h4><p><img src="https://img-blog.csdnimg.cn/9e34ed24b8274ee6ac6aea6e254f6bf8.png" alt="sql语句是如何创建的">包括了创建sql+预编译+参数等信息<br>有了这个配置就不需要sout了</p><h2 id="分页查询：拦截器-MP"><a href="#分页查询：拦截器-MP" class="headerlink" title="分页查询：拦截器+MP"></a>分页查询：拦截器+MP</h2><h3 id="创建MPconfig配置类：拦截器，固定操作"><a href="#创建MPconfig配置类：拦截器，固定操作" class="headerlink" title="创建MPconfig配置类：拦截器，固定操作"></a>创建MPconfig配置类：拦截器，固定操作</h3><pre><code>//Mybatis-plus配置类，需要在此添加拦截器才能正常实现分页查询@Configurationpublic class MPconfig &#123;@Beanpublic MybatisPlusInterceptor mpi()&#123;    //1，定义拦截器    MybatisPlusInterceptor mpi = new MybatisPlusInterceptor();    //2，添加具体的拦截器__PaginationInnerInterceptor分页查询拦截器    mpi.addInnerInterceptor(new PaginationInnerInterceptor());    //3，返回拦截器    return mpi;    &#125;    &#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/61b93045c1c346658829dfe78e08d9e5.png" alt="拦截器"></p><h3 id="数据层：分页查询"><a href="#数据层：分页查询" class="headerlink" title="数据层：分页查询"></a>数据层：分页查询</h3><pre><code>    @Testpublic void testUserPage()&#123;        /*********分页查询*********/        IPage iPage = new Page(2,3);        //按顺序，每页size=3条数据，分页；选择第current=2页    userDao.selectPage(iPage, null);//第二个参数是queryWrapper条件    //这个方法还会返回这个iPage对象本身                System.out.println(&quot;*******iPage对象的6个属性值*******&quot;);        System.out.println(iPage.getCurrent());//2        System.out.println(iPage.getRecords());//[]        System.out.println(iPage.getSize());//3        System.out.println(iPage.getTotal());//0        System.out.println(iPage.getPages());//0    &#125;</code></pre><p>在yaml中配置了log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</p><p>如下的运行结果<img src="https://img-blog.csdnimg.cn/9910670d03eb43c9a0c7cb914f006132.png"></p><h2 id="条件查询：queryWrapper"><a href="#条件查询：queryWrapper" class="headerlink" title="条件查询：queryWrapper"></a>条件查询：queryWrapper</h2><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><pre><code>    @Testpublic void testUserQuery()&#123;//基础的条件查询        QueryWrapper&lt;t_user&gt; qw = new QueryWrapper&lt;&gt;();//查询包实例化,绑定查询的表单        qw.like(&quot;name&quot;, &quot;张三&quot;);        qw.like(&quot;id&quot;, 1);//多条like就是“且”        //查询id=1 name=张三 的数据        userDao.selectList(qw);//返回一个list        &#125;</code></pre><h3 id="lambda表达式安全绑定"><a href="#lambda表达式安全绑定" class="headerlink" title="lambda表达式安全绑定"></a>lambda表达式安全绑定</h3><pre><code>    @Testpublic void testUserLambdaQuery()&#123;//加入lambda表达式防止写错字符        LambdaQueryWrapper&lt;t_user&gt; lqw = new LambdaQueryWrapper&lt;&gt;();//查询包实例化        lqw.like(t_user::getName, &quot;aaaa&quot;);        //t_user是个pojo类        userDao.selectList(lqw);    &#125;</code></pre><h3 id="lambda-if"><a href="#lambda-if" class="headerlink" title="lambda + if"></a>lambda + if</h3><pre><code>    @Testpublic void testUserLambdaIf()&#123;//lambda + if + 条件        String namefrom = &quot;bbb&quot;;//前端传来的数据可能为null值    LambdaQueryWrapper&lt;t_user&gt; lqw = new LambdaQueryWrapper&lt;&gt;();    lqw.like(namefrom!=null , t_user::getName , namefrom);    //参数解析：        //条件1：如果前端传入的namefrom值不为空，数据才查询        //条件2：安全获取t_user的pojo类的name属性名        //条件3: 传入namefrom属性的值        userDao.selectList(lqw);    &#125;</code></pre><h3 id="like条件查询的其他用法"><a href="#like条件查询的其他用法" class="headerlink" title="like条件查询的其他用法"></a>like条件查询的其他用法</h3><p><img src="https://img-blog.csdnimg.cn/9ecae93d1e2e41d2b8dd515f77fbbb83.png" alt="like方法源码"></p><h1 id="业务层开发Service"><a href="#业务层开发Service" class="headerlink" title="业务层开发Service"></a>业务层开发Service</h1><p>相比数据层（关心如何跟数据库交互），业务层更关心<strong>业务名称</strong>，不要混用，例如：同样的登录操作，</p><ul><li>在数据层的接口：selectByUserNameAndPassword( 形参 )</li><li>在业务层的接口：login( 形参 )</li></ul><p>业务层也可以在调用数据层方法的同时，添加自己的逻辑<br><img src="https://img-blog.csdnimg.cn/5ddd2ffe71b34dbb80f5c5485e365f5f.png" alt="文件结构"></p><h2 id="Service接口和实现类"><a href="#Service接口和实现类" class="headerlink" title="Service接口和实现类"></a>Service接口和实现类</h2><ul><li>实现类中注入Dao，那么使用时注入Service就可以通过Service使用Dao了</li><li>增删改的返回值用Boolean，查询才返回一个实体类</li></ul><pre><code>    public interface UserService &#123;//是接口    Boolean save(t_user u);//    Boolean update(t_user u);//    Boolean deleteById(Integer id);//    t_user getById(Integer id);//    List&lt;t_user&gt; getAll();    &#125;    /*******实现类**********/    @Service//注入业务层的bean    public class UserServiceImpl implements UserService&#123;//Impl就是implement    @Autowired    private UserDao userDao;    //嵌套调用，因为使用中，需要注入Service    //在Service中嵌套注入Dao    //即可在业务层操作数据    @Override    public Boolean save(t_user u) &#123;//业务层的save对应数据层的insert        return userDao.insert(u) &gt; 0;        //MybatisPlus定义的CRUD方法返回值是“修改了多少个数据”        //因此判断 &gt; 0 即可    &#125;    @Override    public Boolean update(t_user u) &#123;        return userDao.update(u,null )&gt;0;        //在业务层中调用数据层的方法    &#125;    @Override    public Boolean deleteById(Integer id) &#123;        return userDao.deleteById(id)&gt;0;    &#125;    @Override    public t_user getById(Integer id) &#123;        return userDao.selectById(id);    &#125;    @Override    public List&lt;t_user&gt; getAll() &#123;        return userDao.selectList(null);    &#125;    &#125;</code></pre><h2 id="Service测试"><a href="#Service测试" class="headerlink" title="Service测试"></a>Service测试</h2><pre><code>@SpringBootTestpublic class TUserServiceTestCase &#123;@Autowiredprivate UserService userService;//注入业务层对象@Testpublic void testGetById()&#123;    System.out.println(userService.getById(1));    //业务层看不了日志，所以需要打印    //如果查询结果有多个，则会报错&#125;&#125;</code></pre><h3 id="Service层的分页查询"><a href="#Service层的分页查询" class="headerlink" title="Service层的分页查询"></a>Service层的分页查询</h3><ul><li><p>在Service接口中定义抽象方法 IPage<t_user> getPage(int currentPage,int pageSize);</p></li><li><p>在Service实现类中重写抽象方法</p><pre><code>  @Override  public IPage&lt;t_user&gt; getPage(int currentPage, int pageSize) &#123;  IPage&lt;t_user&gt; iPage = new Page&lt;&gt;(currentPage,pageSize);//定义如何分页  return userDao.selectPage(iPage,null);//返回值本身就是ipage    &#125;</code></pre></li></ul><ul><li><p>业务层进行查询没有log，需要sout输出</p><pre><code>  @Test  public void testSelectByPage()&#123;      System.out.println(userService.getPage(2, 2));      //返回一个ipage对象，但toString在@Service下已重载，可以正常输出  &#125;</code></pre></li></ul><ul><li><strong>仍然需要保证注解的嵌套注入</strong></li></ul><ul><li>下面证明BaseMapper接口下“分页查询selectPage”返回值就是形参ipage</li></ul><pre><code>    IPage&lt;t_user&gt; iPage = new Page&lt;&gt;(currentPage,pageSize);//定义如何分页    IPage&lt;t_user&gt; iPage1 = userDao.selectPage(iPage, null);//返回值本身就是ipage   System.out.println(iPage==iPage1);//true</code></pre><h2 id="MP业务层快速开发"><a href="#MP业务层快速开发" class="headerlink" title="MP业务层快速开发"></a>MP业务层快速开发</h2><p>MP不光简化了数据层的操作（在Dao上@Mapper，并extends BaseMapper&lt;&gt;，就能直接调用CRUD）<br>MP还简化了业务层的开发~（IService&lt;&gt;接口）</p><h3 id="MP业务层接口"><a href="#MP业务层接口" class="headerlink" title="MP业务层接口"></a>MP业务层接口</h3><p><img src="https://img-blog.csdnimg.cn/4ac6dfe87a5045c0bf06659f40a66619.png" alt="位置"></p><pre><code>@Servicepublic interface IMPUserService extends IService&lt;t_user&gt; &#123;//继承IService    //idea下Ctrl+O查看IService提供的方法    //还可以自己再根据业务添加方法    //I开头表示接口，MP代表mybatis plus整合业务层快速开发 //这里面可以写抽象方法，自定义业务层的方法&#125;</code></pre><h3 id="MP业务层实现类"><a href="#MP业务层实现类" class="headerlink" title="MP业务层实现类"></a>MP业务层实现类</h3><p><img src="https://img-blog.csdnimg.cn/a18756a3a14b41babbf7d0534e4d24ec.png" alt="位置"></p><pre><code>package com.bootadmin1.bootajaxtest.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.bootadmin1.bootajaxtest.service.IMPUserService;import com.bootadmin1.bootajaxtest.dao.UserDao;import com.bootadmin1.bootajaxtest.domain.t_user;//导入了4个必要的包，4个类都被MP托管了import org.springframework.stereotype.Service;/** * @author zjh * @create 2022-01-25 18:49 *///@Service之后可以被Spring托管，才能注入后使用@Servicepublic class MPUserServiceImpl extends ServiceImpl&lt;UserDao,t_user&gt; implements IMPUserService &#123;    //继承ServiceImpl可以免去写很多个IMPUserService的重载方法    //泛型指定Dao和实体类    //同时实现“实现了IService接口”的接口IMPUserService    //现在就可以不用手动重写那么多的方法了，Ctrl+O可以看能用的方法&#125;</code></pre><p>需要添加自定义方法的话，跟不用Mybatisplus托管操作是一样的</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>@Autowiredprivate IMPUserService impUserService;//注入MP快速搭建的业务层接口@Service//查get@Testpublic void testGetById()&#123;    t_user byId = impUserService.getById(1);//这个方法是MP提供的    //只要实现了IService接口就能使用这些个方法    System.out.println(byId);&#125;</code></pre><h3 id="调用分析"><a href="#调用分析" class="headerlink" title="调用分析"></a>调用分析</h3><ul><li><p>public interface IMPUserService <strong>extends IService&lt;实体类&gt;</strong></p></li><li><p>@Service<br>public class MPUserServiceImpl <strong>extends ServiceImpl&lt;Dao,实体类&gt; implements IMPUserService</strong></p></li><li><p>@Test @Autowired 注入父类子类都OK，多态性的体现</p><pre><code>  @Autowired  private IMPUserService impUserService;  //private 其子类MPUserServiceImpl也可以 impUserService;</code></pre></li></ul><h1 id="表现层开发Controller"><a href="#表现层开发Controller" class="headerlink" title="表现层开发Controller"></a>表现层开发Controller</h1><p><img src="https://img-blog.csdnimg.cn/a5146e26282f4f918610d65b4cabc036.png" alt="位置"></p><pre><code>package com.bootadmin1.bootajaxtest.controller;import com.bootadmin1.bootajaxtest.domain.t_user;import com.bootadmin1.bootajaxtest.service.IMPUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * @author zjh * @create 2022-01-25 19:45 */@RestController@RequestMapping(&quot;/users&quot;)//users是有说法的，复数嘛public class UserController &#123;    @Autowired    private IMPUserService impUserService;    //同样因为多态性，这里也可以注入其子类    @GetMapping    public List&lt;t_user&gt; getAll()&#123;        return impUserService.list();    &#125;    //增：Post提交，save：mp的保存方法    @PostMapping    public boolean save(@RequestBody  t_user u)&#123;//        @ResponseBody请求体参数，异步提交json数据        return impUserService.save(u);    &#125;    //改：Put提交，update：mp的修改方法    @PutMapping    public boolean updata(@RequestBody t_user u)&#123;        return impUserService.updateById(u);    &#125;    //http://localhost：8080/users/id    @DeleteMapping(&quot;&#123;id&#125;&quot;)    public boolean delete(@PathVariable Integer id)&#123;        //@PathVariable表示从url路径获取的变量        return impUserService.removeById(id);    &#125;    @GetMapping(&quot;&#123;id&#125;&quot;)    public t_user getByid(@PathVariable Integer id)&#123;        return impUserService.getById(id);    &#125;&#125;</code></pre><h2 id="postman测试"><a href="#postman测试" class="headerlink" title="postman测试"></a>postman测试</h2><h3 id="查所有"><a href="#查所有" class="headerlink" title="查所有"></a>查所有</h3><p><img src="https://img-blog.csdnimg.cn/db9c7f7b1b804bb4a94090d2875f0183.png" alt="GET请求"></p><h3 id="ID查"><a href="#ID查" class="headerlink" title="ID查"></a>ID查</h3><p><img src="https://img-blog.csdnimg.cn/555e6d3e32804c588b5f9e3ce91df865.png"></p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul><li>换Post提交</li><li>Body下选raw，换位JSON，写JSON字符串<br><img src="https://img-blog.csdnimg.cn/62cebe7bed9b4217bb94bbdd5f2571bc.png" alt="这里故意超出数据库限制，提交失败"><br>然后把数据设置合理<br><img src="https://img-blog.csdnimg.cn/9829e5ac57a7405bbf966209a12441c0.png" alt="提交成功"><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3></li></ul><p><img src="https://img-blog.csdnimg.cn/f6bca076957c46af8ad338f217280407.png" alt="通过id修改成功"></p><h3 id="分页查询-自定义"><a href="#分页查询-自定义" class="headerlink" title="分页查询:自定义"></a>分页查询:自定义</h3><p><img src="https://img-blog.csdnimg.cn/10da1f38f8754c5ba043ba76d3ee01f5.png" alt="第二页，每页显示3条"></p><h4 id="业务层接口定义抽象方法"><a href="#业务层接口定义抽象方法" class="headerlink" title="业务层接口定义抽象方法"></a>业务层接口定义抽象方法</h4><pre><code>public interface IMPUserService extends IService&lt;t_user&gt; &#123;//继承IService    //idea下Ctrl+O查看IService提供的方法    //还可以自己再根据业务添加方法    //I开头表示接口，MP代表mybatis plus整合业务层快速开发    IPage&lt;t_user&gt; getPage(int current,int size);&#125;</code></pre><h4 id="业务层实现类实现抽象方法：需要注入Dao"><a href="#业务层实现类实现抽象方法：需要注入Dao" class="headerlink" title="业务层实现类实现抽象方法：需要注入Dao"></a>业务层实现类实现抽象方法：需要注入Dao</h4><pre><code>//@Service之后可以被Spring托管，才能注入后使用@Servicepublic class MPUserServiceImpl extends ServiceImpl&lt;UserDao,t_user&gt; implements IMPUserService &#123;    //继承ServiceImpl可以免去写很多个IMPUserService的重载方法    //泛型指定Dao和实体类    //同时实现“实现了IService接口”的接口IMPUserService    //现在就可以不用手动重写那么多的方法了，Ctrl+O可以看能用的方法    @Autowired    private UserDao userDao;    //自定义方法肯定需要注入Dao来操作数据库了    @Override    public IPage&lt;t_user&gt; getPage(int current, int size) &#123;        Page&lt;t_user&gt; ipage = new Page&lt;&gt;(current, size);        return userDao.selectPage(ipage,null );    &#125;&#125;</code></pre><h4 id="表现层控制请求"><a href="#表现层控制请求" class="headerlink" title="表现层控制请求"></a>表现层控制请求</h4><pre><code>//分页查询@GetMapping(&quot;&#123;current&#125;/&#123;size&#125;&quot;)public IPage&lt;t_user&gt; getPages(@PathVariable Integer current, @PathVariable Integer size)&#123;   return impUserService.getPage(current,size );//调用自定义的方法&#125;</code></pre><h2 id="Restful风格总结"><a href="#Restful风格总结" class="headerlink" title="Restful风格总结"></a>Restful风格总结</h2><p>基于Restful风格制作的表现层接口</p><ul><li>增：POST</li><li>删：DELETE</li><li>改：PUT</li><li>查：GET</li></ul><p>对于增，改操作，会从客户端读取数据参数</p><ul><li>实体数据：@RequestBody</li><li>路径变量：@PathVariable</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Springboot基本结构</title>
      <link href="/zjh/2022/01/20/Springboot%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
      <url>/zjh/2022/01/20/Springboot%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="基本运行功能"><a href="#基本运行功能" class="headerlink" title="基本运行功能"></a>基本运行功能</h1><p><img src="https://img-blog.csdnimg.cn/ef2744d2043545cb80069240f28c9c6d.png" alt="基本项目结构"></p><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><a href="https://blog.csdn.net/qq_33363618/article/details/79438044">pom.xml配置详解</a><br>注意结构，如：dependencies中包括了多个dependency</p><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li><p>@<strong>Data</strong>：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法</p></li><li><p><em>有了@Data提供的get set方法才能顺利的从配置文件中读取信息</em>*</p></li><li><p>@<strong>ConfigurationProperties(prefix = “zjh”)</strong>//配置zjh属性，这个注解要结合config中的<strong>EnableConfigurationProperties({Person.class,Pet.class})<strong>允许配置，还要结合controller中的    <br></strong>@Autowired<br>Person zjh;</strong>//注入到IOC容器才能反应</p></li></ul><p>（@Component以被@EnableConfigurationProperties替代）</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>@ConfigurationProperties(prefix = &quot;zjh&quot;)//配置zjh属性@Data@ToStringpublic class Person &#123;    private String userName;    private Boolean boss;    private Date birth;    private Integer age;    private Pet pet;    private String[] interests;    private List&lt;String&gt; animal;    private Map&lt;String, Object&gt; score;    private Set&lt;Double&gt; salarys;    private Map&lt;String, List&lt;Pet&gt;&gt; allPets;&#125;</code></pre><h2 id="config配置类"><a href="#config配置类" class="headerlink" title="config配置类"></a>config配置类</h2><p><img src="https://img-blog.csdnimg.cn/045ca7ac7b5f487d895018f21fa7cd8b.png"></p><h3 id="常用注解-1"><a href="#常用注解-1" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li><p><strong>@Configuration(proxyBeanMethods = false或true)</strong><br>Full(proxyBeanMethods = <strong>true</strong>)【保证每个@Bean方法被调用多少次返回的组件都是<strong>单实例</strong>的】<br>Lite(proxyBeanMethods = <strong>false</strong>)【每个@Bean方法被调用多少次返回的组件都是<strong>新创建</strong>的】</p></li><li><p><em>组件依赖必须使用Full模式默认。其他默认是否Lite模式</em>*</p></li><li><p><strong>@EnableConfigurationProperties({Person.class,Pet.class})</strong>{}中的类可以由配置文件配置</p></li><li><p>@Bean 给IOC容器添加组件，@Bean和@Import、@ConfigurationProperties 有冲突，<strong>并且@Bean也需要在controller下@Autowired注入</strong></p></li><li><p>@Import 导入某个类，创建默认组件，组件名默认为全类名，和@Bean冲突</p></li><li><p>@ImportResource 解析xml配置</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>  @ImportResource(“classpath:beans.xml”)<br>  @Import({ImportTest1.class})<br>  //下面两个才是基本运行所必要的注解<br>  @EnableConfigurationProperties({Person.class,Pet.class})<br>  @Configuration(proxyBeanMethods = false)<br>  public class MyConfig {</p><pre><code>  @Bean  public ImportTest1 importTest1()&#123;      ImportTest1 it1 = new ImportTest1(&quot;test&quot;);      return it1;  &#125;//这个Bean组件就唯一添加到了IOC容器中，并且可以被Cotroller或main获取  &#125;</code></pre></li></ul><h2 id="controller控制类"><a href="#controller控制类" class="headerlink" title="controller控制类"></a>controller控制类</h2><p><img src="https://img-blog.csdnimg.cn/4ffa26c0bc7e4596bc8ff02e84a2ba12.png"></p><h3 id="常用注解-2"><a href="#常用注解-2" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li>@RestController声明，== @ResponseBody+@Controller</li><li>@RequestMapping(“/hello”),RUL后缀映射访问请求</li><li>@Autowired，每个要使用的Bean都需要@Autowired注入容器</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><pre><code>    @RestControllerpublic class hello &#123;        //映射请求：浏览器访问请求    @RequestMapping(&quot;/hello&quot;)//收到hello请求    public String handle01()&#123;//反应        return &quot;world&quot;;    &#125;//   自动注入，需要Person有空参构造    //或Person类直接实现@Data注解    @Autowired    Person zjh;    @RequestMapping(&quot;/zjh&quot;)//zjh必须先   //用 @ConfigurationProperties(prefix = &quot;zjh&quot;)    //并且在application.yaml中配置    public Person handle02()&#123;        return zjh;    &#125;    @Autowired    Pet nn;    @RequestMapping(&quot;/nn&quot;)    public Pet handle03()&#123;        return nn;    &#125;    &#125;</code></pre><h2 id="运行主类"><a href="#运行主类" class="headerlink" title="运行主类"></a>运行主类</h2><ul><li>@SpringBootApplication声明为主类</li><li>SpringApplication.run(MainApp.class, args)运行且返回IOC容器<ul><li>该单独的类MainAPP.class和以上三个包同目录<img src="https://img-blog.csdnimg.cn/9e3e59181d394103b9ac04a441494b27.png">  <h3 id="单例、组件依赖：proxyBeanMethods"><a href="#单例、组件依赖：proxyBeanMethods" class="headerlink" title="单例、组件依赖：proxyBeanMethods"></a>单例、组件依赖：proxyBeanMethods</h3>因为在config类中也遇到了proxyBeanMethods，主类中也有proxyBeanMethods参数<br>他们分别为：</li></ul></li><li><em>@Configuration(proxyBeanMethods = true)<br>@SpringBootApplication(proxyBeanMethods = true)</em>*</li></ul><p>Full(proxyBeanMethods = <strong>true</strong>)【保证每个@Bean方法被调用多少次返回的组件都是<strong>单实例</strong>的】<br>Lite(proxyBeanMethods = <strong>false</strong>)【每个@Bean方法被调用多少次返回的组件都是<strong>新创建</strong>的】</p><p>组件依赖必须使用默认的Full模式，其他则默认使用Lite模式。</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><pre><code>@SpringBootApplicationpublic class MainApp &#123;//这是入口    public static void main(String[] args) &#123;        //不光可以启动，还可以有返回值IOC容器        ConfigurableApplicationContext run = SpringApplication.run(MainApp.class, args);//返回容器run        &#125;        &#125;</code></pre><h4 id="Bean单例的体现"><a href="#Bean单例的体现" class="headerlink" title="Bean单例的体现"></a>Bean单例的体现</h4><pre><code>//单例实例的创建不能用new，而是反射机制//并且在MyConfig中已创建该类的@Bean    //或者    //具体属性值由yaml配置//总之，IOC容器中如下getBean得到的是该类的唯一：单例    Person person1 = run.getBean(Person.class);    Pet pet1 = run.getBean(Pet.class);    System.out.println(pet1);    System.out.println(person1);</code></pre><h4 id="体现2"><a href="#体现2" class="headerlink" title="体现2"></a>体现2</h4><pre><code>    System.out.println(&quot;***************************&quot;);    String[] beanNamesForType = run.getBeanNamesForType(person1.getClass());    //获取所有Person组件的所有名字    for(String str : beanNamesForType)&#123;        System.out.println(str);    &#125;//单例下只有一个zjh-ZJH.inditest.bean.Person</code></pre><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><ul><li><strong>属性设置</strong>：Bean声明@ConfigurationProperties(prefix = “zjh”)——&gt;在application.yaml中配置</li><li><strong>配置组件</strong>：声明@Configuration的类就是配置组件——&gt;<br>@EnableConfigurationProperties({Person.class,Pet.class})<br>使配置好的Bean生效</li><li><strong>控制组件</strong>：声明@RestController的类就是控制组件——&gt;<br>结合@Autowired注入，@RequestMapping(“/hello”)映射请求</li><li><strong>主类运行</strong>：声明@SpringBootApplication的类就是主类，有main方法体——&gt; ConfigurableApplicationContext run = SpringApplication.run(MainApp.class, args);固定用法，运行且返回IOC容器</li></ul><h1 id="基本依赖"><a href="#基本依赖" class="headerlink" title="基本依赖"></a>基本依赖</h1><pre><code>&lt;!--可执行jar包--&gt;    &lt;!--Maven中点clean package--&gt;    &lt;!--cmd上方右键属性关闭快速编辑--&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;!--父项目，依赖管理，控制版本--&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.6.2&lt;/version&gt;    &lt;/parent&gt;&lt;!--Web场景启动器--&gt;    &lt;!--启动器：springboot stater- ：相当于import--&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;    &lt;!--&lt;dependency&gt;--&gt;        &lt;!--&lt;groupId&gt;mysql&lt;/groupId&gt;--&gt;        &lt;!--&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt;        &lt;!--&lt;version&gt;8.0.28&lt;/version&gt;--&gt;    &lt;!--&lt;/dependency&gt;--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.16.20&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件:文件加密解密器</title>
      <link href="/zjh/2022/01/16/%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%99%A8/"/>
      <url>/zjh/2022/01/16/%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一个基于对称加密机制的文件加密器"><a href="#一个基于对称加密机制的文件加密器" class="headerlink" title="一个基于对称加密机制的文件加密器"></a>一个基于对称加密机制的文件加密器</h1><ul><li>这是我写的第一个版本，能加密所有文件，但基于对称加密，安全系数不是特别高。<br></li><li>并且由于算法操作了所有字节，在执行效率上有所缺陷，后续有精力了会进行版本迭代<br></li><li>第一个版本不支持自定义输出目录<br></li></ul><p>下个版本将：自定义输出地址，可以文件夹整体加密，非对称加密方式，只操作部分字节</p><p><img src="https://img-blog.csdnimg.cn/b8edf3c2b2e049de9f9aea9c511d3ed1.png"></p><p>链接：<a href="https://pan.baidu.com/s/1eHVwitD0ZfVZLLNXfCL8TA">https://pan.baidu.com/s/1eHVwitD0ZfVZLLNXfCL8TA</a><br>提取码：iai9</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ul><li>输入的路径是文件夹，这个加密器是把<strong>整个文件夹中文件全部加密</strong></li><li>该方法默认了输出路径， 路径会自动生成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/zjh/2022/01/16/IO%E6%B5%81/"/>
      <url>/zjh/2022/01/16/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="IO流特点"><a href="#IO流特点" class="headerlink" title="IO流特点"></a>IO流特点</h1><p>IO流属于物理连接，需要手动显示close()，否则内存泄漏<br>File对象必须是<strong>文件路径</strong>而不能是文件目录，<strong>否则在使用流时会报错java.io.FileNotFoundException: D:\io\io1\io2 (拒绝访问。)</strong></p><h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><ul><li>按操作<strong>数据单位</strong>不同分为：字节流(8 bit)，字符流(16 bit)</li><li>按数据流的<strong>流向</strong>不同分为：输入流，输出流</li><li>按流的<strong>角色</strong>的不同分为：节点流，处理流<h2 id="为什么这样分类？"><a href="#为什么这样分类？" class="headerlink" title="为什么这样分类？"></a>为什么这样分类？</h2><h3 id="1，数据单位"><a href="#1，数据单位" class="headerlink" title="1，数据单位"></a>1，数据单位</h3></li><li>字节流(8bit = 255位)：适合<strong>图像视频等</strong>(.jpg .mp3 .mp4 .avi <strong>.doc</strong> .ppt….)传输，因为电脑像素点的灰度值范围是[0,255]<br></li><li>字符流(16bit = 2字节)：适合传输<strong>文本</strong>(<strong>.java  .c  .cpp</strong>  .txt)，Java语言规范规定，Java的char类型是UTF-16的code unit，也就是一定是16位（2字节）</li></ul><h3 id="2，流向"><a href="#2，流向" class="headerlink" title="2，流向"></a>2，流向</h3><p>输出流： 程序(内存)——&gt;存储设备<br><br>输入流：键盘，磁盘等——&gt;程序(内存)</p><h3 id="3，角色"><a href="#3，角色" class="headerlink" title="3，角色"></a>3，角色</h3><p>节点流：直接读写数据，最简单的一类流<br><br>处理流：以节点流对象为形参，为节点流提供更好的性能的流<br><img src="https://img-blog.csdnimg.cn/5bac5466455a45cea57bbe2d9abcf5cd.png"></p><ul><li><strong>基类（抽象类）给定了节点流的规范</strong></li><li>子类的命名后缀规则一致，虽然有40多个类，但都很规范<br><img src="https://img-blog.csdnimg.cn/9bb30cfd68a1451cbae8f3f5703f4d44.png"></li></ul><h1 id="字符流：Reader和Writer（以FileReader和FileWriter为例）"><a href="#字符流：Reader和Writer（以FileReader和FileWriter为例）" class="headerlink" title="字符流：Reader和Writer（以FileReader和FileWriter为例）"></a>字符流：Reader和Writer（以FileReader和FileWriter为例）</h1><h2 id="1-FileWriter"><a href="#1-FileWriter" class="headerlink" title="(1)FileWriter"></a>(1)FileWriter</h2><ul><li><strong>主要方法</strong></li></ul><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">构造器 <br>FileWriter(File路径or对象，可选项append)</td><td align="center">append默认为false<br>true表示write方法<strong>追加写入</strong><br>false表示write方法<strong>覆盖写入</strong></td></tr><tr><td align="center">write(“写入的内容”)<br>write(String或char[],offset,len)</td><td align="center">可以传入String或char[ ]<br>offset表示从索引offset号开始传入<br>len表示传入的长度，<strong>注意角标越界问题</strong></td></tr><tr><td align="center">flush(空参)</td><td align="center">刷新，不刷新的话，虽然写入了，但是read不到，文件打开也看不到写入</td></tr><tr><td align="center">close()</td><td align="center">显示关闭流，防止内存溢出</td></tr></tbody></table><ul><li><p><strong>示例</strong><br>准备工作：先创建好file</p><pre><code>File file = new File(&quot;text.txt&quot;);//在当前project下创建一个text.txt文件if(!file.exists())&#123;    file.createNewFile();//防止FileNotFoundException: text.txt (系统找不到指定的文件。)&#125;  /***************Writer操作*******************/      FileWriter fileWriter = new FileWriter(file,true);//流的实例化      //append为true则多个write是追加写入      //append为false则write是覆盖写入      fileWriter.write(&quot;hello world\n&quot;);      fileWriter.flush();//刷新，不刷新的话，虽然写入了，但是read不到，文件打开也看不到写入      fileWriter.write(&quot;it&#39;s a test\n&quot;);      fileWriter.flush();//刷新  //该程序运行几遍就write几遍，下面read就会重复几遍      fileWriter.close();</code></pre><h2 id="2-FileReader"><a href="#2-FileReader" class="headerlink" title="(2)FileReader"></a>(2)FileReader</h2></li><li><p><strong>主要方法</strong></p></li></ul><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">构造器<br>FileReader(File对象或路径)<br>FileReader(FileDescriptor fd)</td><td align="center">/</td></tr><tr><td align="center">read(空参)</td><td align="center">空参<strong>迭代</strong>返回该文件的<strong>一个</strong>字符的ASCII码值data，需配合强转char输出</td></tr><tr><td align="center">read(char[] cbuf)</td><td align="center"><strong>迭代</strong>返回本次流读取的长度len，<strong>并把读取的数去填入cbuf数组中</strong></td></tr><tr><td align="center">read(char[] cbuf,偏移量offset,最大读取长度length)</td><td align="center">length为0时线程阻塞，length为<strong>装填长度</strong><br>read方法返回值<br>若某段流没有可读字符，read返回-1</td></tr></tbody></table><pre><code>  当FileReader流能read到字符时，返回值len=实际读取长度&gt;0  读取不到返回-1，所以可以利用len!=-1创建循环条件  注意区别read返回值 和 对cbuf赋值的差别</code></pre><p>read()是一个迭代器，无论是read(空参)还是read(cbuf)都会导致迭代器指针移动</p><ul><li><strong>解释：什么叫“目的缓冲区”和“装填长度”？为什么read方法最好不要带offset和len参数？</strong></li></ul><p>1.char[] cbuf数组就是目的缓冲区，把cbuf传入read()的形参，则会把目标文件中cbuf.length()个连续的字符读入cbuf，然后遍历cbuf数组，故称“缓冲”<strong>目标缓冲区(cbuf数组)设置过大则内存占用大，过小则运行速度慢。</strong><br>2.而read(cbuf,offset,len)中的len就是装填长度，装填长度不影响最后read输出结果，但可能造成角标越界<br>3.len为0线程阻塞，offset会影响读取结果，所以通常不带这两个参数</p><ul><li><strong>示例</strong><pre><code>      /*************Reder操作**************/      FileReader fileReader = new FileReader(file);//流的实例化      char[] cbuf = new char[6];//设置“目的缓冲区”      int len ; //定义“装填长度”      while((len=fileReader.read(cbuf,0,6)) != -1)&#123;//最好是不带后面两个形参      //当FileReader流能read到字符时，返回值len=实际读取长度&gt;0  //形参解析：目的缓冲区数组，offset索引偏移量(为0时保证从cbuf[0]开始装填)，  // len最大装填长度：len+offset之和不能超过cbuf.length()否则报错指针越界        //输出的方式1：注意len和length区别          for(int i = 0 ; i&lt;len ; i++)&#123;              //必须是i&lt;len“装填长度”，而不能是i&lt;cbuf.length“缓冲区长度”              System.out.print(cbuf[i]);              &#125;              &#125;       fileReader.close();</code></pre></li></ul><p><img src="https://img-blog.csdnimg.cn/1b010d62b70541ac8232765d39d0476a.png" alt="输出结果"></p><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><p>为了防止各种报错，开发时最好满足以下规范</p><ul><li>close()防止内存溢出</li><li>try-catch-finally而不是简单的throws IOException </li><li>close()放在finally中，以便出问题时及时关闭流</li><li>在finally中的close()还需要<strong>if判断是否存在，并嵌套try-catch</strong></li><li><strong>使用IDEA的alt+insert调try-catch时，会自动在外边生成FileWriter fw = null;和FileReader fr = null;</strong></li></ul><h1 id="字节流：InputStream和OutputStream"><a href="#字节流：InputStream和OutputStream" class="headerlink" title="字节流：InputStream和OutputStream"></a>字节流：InputStream和OutputStream</h1><ul><li>步骤规范：创建File对象——创建流对象——操作——关闭流</li></ul><p>我们把刚刚创建的“C:\Users\Administrator\IdeaProjects\ZJHindi\text.txt”复制到“D:\io\io1\io2”下</p><ol><li>关掉QQ(热键冲突)Alt+Ctrl+T调用try-catch-finally<br><img src="https://img-blog.csdnimg.cn/ee815e5e76ae49df930872a924a786cd.png"> </li><li>第二步<br><img src="https://img-blog.csdnimg.cn/96fd16a8e316441ea0b1a1899c9b09bc.png"></li><li>第三步，两个close()分别try -catch(注意去掉throws IOException)</li></ol><p><img src="https://img-blog.csdnimg.cn/5664f138fb254c15bee917af0abf49aa.png"><br>完整代码：</p><pre><code>package zjh;import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class CopyTest &#123;    public static void main(String[] args)&#123;        FileReader fr = null;//从源文件读取        FileWriter fw = null;//写入目的文件        try &#123;            File scrfile = new File(&quot;C:\\Users\\Administrator\\IdeaProjects\\ZJHindi\\text.txt&quot;);            File destfile = new File(&quot;D:\\io\\io1\\io2\\desttext.txt&quot;);            fr = new FileReader(scrfile);            fw = new FileWriter(destfile);            char[] cbuf = new char[5];            int len;            while((len=fr.read(cbuf))!=-1)&#123;                fw.write(cbuf);            &#125;            fw.flush();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if(fw!=null)&#123;//先判断fw非空            try &#123;                fw.close();//防止关闭时出错            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            &#125;            if(fr!=null) &#123;//判断fr非空                try &#123;                    fr.close();//关闭                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        &#125;&#125;</code></pre><h1 id="处理流：缓冲流：BufferedInputStream和BufferedOutputStream"><a href="#处理流：缓冲流：BufferedInputStream和BufferedOutputStream" class="headerlink" title="处理流：缓冲流：BufferedInputStream和BufferedOutputStream"></a>处理流：缓冲流：BufferedInputStream和BufferedOutputStream</h1><ul><li>把节点流作为形参new缓冲流，套接在已有的节点流之外</li><li><strong>传统的节点流是线程阻塞的</strong>，而缓冲流则通过<strong>在内存中开辟一块缓冲区</strong>用于各节点流缓冲，缓冲满之后执行，<strong>利用空间换时间</strong></li><li><strong>外层处理流close()的时候，内层字节流也会关闭</strong>，因此只需对外层流finally{close()}</li></ul><p>如下是一个封装好的图片复制方法：</p><pre><code>    public static void BufferedStreamCopy(String srcPath,String destPath) &#123;//缓冲流字节流的复制方法        //形参直接放入源文件路径 和 目的文件路径,文件自动复制        BufferedInputStream bis = null;//写的时候按正常步骤写        BufferedOutputStream bos = null;//这两句是try-catch-finally自动生成的        try &#123;//File对象的创建，导入路径            File srcfile = new File(srcPath);            File destfile = new File(destPath);//节点流的创建，用于复制图像视频等            FileInputStream fis = new FileInputStream(srcfile);            FileOutputStream fos = new FileOutputStream(destfile);//处理流（缓冲流）的创建，用于加速            bis = new BufferedInputStream(fis);            bos = new BufferedOutputStream(fos);            //原本对节点流的操作照搬给处理流            byte[] bbuf = new byte[1024];            int len;            while((len=bis.read(bbuf)) != -1)&#123;                //每从bis读一次，就往bos写一次                bos.write(bbuf);                &#125;            //因为有处理流自动flush，所以不用显示的flush            //缓冲区满了之后自动会flush，默认长度1024x8        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;//关闭流，只需要关闭外层            if(bis!=null)&#123;                try &#123;                    bis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(bos!=null) &#123;                try &#123;                    bos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            &#125;        &#125;</code></pre><p>调用一下：</p><pre><code>public static void main(String[] args) &#123;BufferedStreamCopy(&quot;D:\\io\\io1\\io2\\QQ截图20220115002227.png&quot;,&quot;D:\\io\\io2\\io3\\新建文件夹\\复制后的图.png&quot;);//目的路径也必须是文件，并且格式(.png)最好相同&#125;</code></pre><h2 id="字符流处理文本——-gt-字节流处理图片视频"><a href="#字符流处理文本——-gt-字节流处理图片视频" class="headerlink" title="字符流处理文本——&gt;字节流处理图片视频"></a>字符流处理文本——&gt;字节流处理图片视频</h2><ul><li> 把FileReader——&gt;FileInputStream,把FileWriter——&gt;FileOutputStream</li><li> 把char[] cbuf——&gt;byte[] bbuf</li></ul><p>其实<strong>字节流</strong>也可以<strong>复制</strong>（仅仅是复制）文本文件，<strong>只是中途不能控制台输出，否则中文会被切分</strong></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="加密算法：适用于所有文件，加密解密方法相同（-5）"><a href="#加密算法：适用于所有文件，加密解密方法相同（-5）" class="headerlink" title="加密算法：适用于所有文件，加密解密方法相同（^5）"></a>加密算法：适用于所有文件，加密解密方法相同（^5）</h2><pre><code>public static void MethodEncrpt(String srcpath,String destpath)&#123;//定义方法：加密，解密    BufferedInputStream bis = null;    BufferedOutputStream bos = null;    try &#123;        bis = new BufferedInputStream(new FileInputStream(new File(srcpath)));        bos = new BufferedOutputStream(new FileOutputStream(new File(destpath)));        int data;        while((data= bis.read()) != -1)&#123;            bos.write(data^5);//异或加密，加密解密方式都相同(M^n^n=M)        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; finally &#123;        if (bos != null) &#123;            try &#123;                bos.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (bis != null) &#123;            try &#123;                bis.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;  /********************加密解密方法使用示例********************/public static void main(String[] args) &#123;//加密MethodEncrpt(&quot;C:\\Users\\Administrator\\Desktop\\数据结构文档\\00_课程介绍.pdf&quot;,&quot;D:\\io\\加密\\字节流文件\\加密数据结构课程介绍.pdf&quot;);//解码        MethodEncrpt(&quot;D:\\io\\加密\\字节流文件\\加密数据结构课程介绍.pdf&quot;,&quot;D:\\io\\解密\\字节流文件\\解密1.pdf&quot;);MethodEncrpt(&quot;D:\\io\\io1\\io2\\desttext.txt&quot;,&quot;D:\\io\\io1\\io3\\加密1.txt&quot;);MethodEncrpt(&quot;D:\\io\\io1\\io3\\加密1.txt&quot;,&quot;D:\\io\\io1\\io3\\解密1.txt&quot;);    &#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/197ea36e2f734182a9eaf220b6ea10f5.png" alt="加密后"></p><h2 id="字数统计算法-加入了转换流"><a href="#字数统计算法-加入了转换流" class="headerlink" title="字数统计算法:加入了转换流"></a>字数统计算法:加入了转换流</h2><p>注意：实际开发中应该用try-catch-finally，此处为了方便直接throws IOException</p><pre><code>public static void MethodCount(String path) throws IOException &#123;    File file = new File(path);    FileInputStream fis = new FileInputStream(file);    BufferedInputStream bis = new BufferedInputStream(fis);    InputStreamReader isr = new InputStreamReader(bis);    HashMap&lt;Character,Integer&gt; hsm1 = new HashMap&lt;&gt;();    int len;    char[] cbuf = new char[1024];    while((len=isr.read(cbuf)) != -1)&#123;//读取到cbuf        for(int i=0 ; i&lt;len ; i++)&#123;            if(hsm1.containsKey(cbuf[i]))&#123;                hsm1.replace(cbuf[i],hsm1.get(cbuf[i])+1);            &#125;            else&#123;                hsm1.put(cbuf[i],1);            &#125;        &#125;    &#125;    //输出遍历hsm1数组    Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = hsm1.entrySet();    Iterator&lt;Map.Entry&lt;Character, Integer&gt;&gt; iterator = entries.iterator();    while (iterator.hasNext())&#123;        Map.Entry&lt;Character, Integer&gt; next = iterator.next();        Character key = next.getKey();        Integer value = next.getValue();        switch (key) &#123;            case &#39; &#39;:                System.out.println(&quot;空格：&quot;+value+&quot;次&quot;);                break;            case &#39;\t&#39;:                System.out.println(&quot;tab：&quot;+value+&quot;次&quot;);                break;            case &#39;\r&#39;:                System.out.println(&quot;回车：&quot;+value+&quot;次&quot;);                break;            case &#39;\n&#39;:                System.out.println(&quot;换行：&quot;+value+&quot;次&quot;);                break;            default:                System.out.println(key+&quot;：&quot;+value+&quot;次&quot;);                break;        &#125;    &#125;    &#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/442698d2bdb245ebab578aa34137a46c.png"></p><h2 id="加密解密GUI"><a href="#加密解密GUI" class="headerlink" title="加密解密GUI"></a>加密解密GUI</h2><p><img src="https://img-blog.csdnimg.cn/aa539cc7a4724a9082f1a652f1868cc8.png"><img src="https://img-blog.csdnimg.cn/b8edf3c2b2e049de9f9aea9c511d3ed1.png"></p><pre><code>public class EncrptDir &#123;public static void EncrptMethod(String dirpath) throws IOException &#123;//文件目录    File srcfile = new File(dirpath);    File destfile = new File(&quot;D:\\加密照片\\加密照片5&quot;);//加密照片存储地址    if(!destfile.exists())&#123;        destfile.mkdirs();    &#125;    File[] files = srcfile.listFiles();//罗列所有照片的File对象    for(int i = 0 ; i&lt;files.length ; i++)&#123;//处理每个文件        String s = files[i].getName().split(&quot;\\.&quot;)[1];//s表示文件名后缀        //split方法是正则表达式，所以要用\\.        String d = &quot;加密图片&quot;+i+&quot;.&quot; + s;        File file_jm = new File(destfile,d);        //创建节点流        FileInputStream fis = new FileInputStream(files[i]);//输入原图        BufferedInputStream bis = new BufferedInputStream(fis);        FileOutputStream fos = new FileOutputStream(file_jm);//输出加密        BufferedOutputStream bos = new BufferedOutputStream(fos);    //读写操作       int data;        while((data=bis.read())!=-1)&#123;            bos.write(data^5);//加密操作        &#125;    //关闭流        bos.close();        bis.close();        System.out.println(&quot;正在加密第  &quot;+i+&quot;  张图&quot;);    &#125;    System.out.println(&quot;加密完成，文件位于D:\\加密照片\\加密照片5&quot;);    &#125;public static void DecrptMethod(String dirpath) throws IOException &#123;//文件目录    File srcfile = new File(dirpath);    File destfile = new File(&quot;D:\\解密照片\\解密照片5&quot;);//解密照片存储地址    if(!destfile.exists())&#123;        destfile.mkdirs();    &#125;    File[] files = srcfile.listFiles();//罗列所有照片的File对象    for(int i = 0 ; i&lt;files.length ; i++)&#123;//处理每个文件        String s = files[i].getName().split(&quot;\\.&quot;)[1];//s表示文件名后缀        //split方法是正则表达式，所以要用\\.        String d = &quot;加密图片&quot;+i+&quot;.&quot; + s;        File file_jm = new File(destfile,d);        //创建节点流        FileInputStream fis = new FileInputStream(files[i]);//输入原图        BufferedInputStream bis = new BufferedInputStream(fis);        FileOutputStream fos = new FileOutputStream(file_jm);//输出解密        BufferedOutputStream bos = new BufferedOutputStream(fos);        //读写操作        int data;        while((data=bis.read())!=-1)&#123;            bos.write(data^5);//解密操作        &#125;        //关闭流        bos.close();        bis.close();        System.out.println(&quot;正在解密第  &quot;+i+&quot;  张图&quot;);    &#125;    System.out.println(&quot;解密完成，文件位于D:\\解密照片\\解密照片5&quot;);    &#125;&#125;package ZJHindi;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.io.*;public class EncrptGUI &#123;    public static void main(String[] args) &#123;        JFrame jf = new JFrame(&quot;文件加密工具&quot;);        jf.setLayout(new FlowLayout(FlowLayout.LEFT));        jf.setBounds(460,300,350,200);        /*********逻辑部分**********/        JLabel label1 = new JLabel(&quot;需要加密or解密的文件源路径:&quot;);        JTextField srcfilepath = new JTextField(&quot;&quot;,30);        JButton jButton1 = new JButton(&quot;点击加密&quot;);        jButton1.setSize(20,30);        JLabel jLabe2 = new JLabel(&quot;输出位置D:\\加密照片\\加密照片5&quot;);        jf.add(label1);        jf.add(srcfilepath);        jf.add(jButton1);        jf.add(jLabe2);        JButton jButton2 = new JButton(&quot;点击解密&quot;);        jf.add(jButton2);        JLabel jLabe3 = new JLabel(&quot;输出位置D:\\解密照片\\解密照片5&quot;);        jf.add(jLabe3);        /****************************/        jf.setVisible(true);        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        JLabel outter = new JLabel(&quot;执行信息：&quot;);        jf.add(outter);        JTextArea jta = new JTextArea();        jf.add(jta);/****************************加密*********************/        jButton1.addActionListener(new AbstractAction() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                String path = srcfilepath.getText();//获取输入的路径                try &#123;                    EncrptDir.EncrptMethod(path);                &#125; catch (IOException e1) &#123;                    e1.printStackTrace();                &#125;jta.append(&quot;加密完成\n&quot;);            &#125;            &#125;);/******************解密*****************/        jButton2.addActionListener(new AbstractAction() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                String path = srcfilepath.getText();//获取输入的路径                try &#123;                    EncrptDir.DecrptMethod(path);                &#125; catch (IOException e1) &#123;                    e1.printStackTrace();                &#125;                jta.append(&quot;解密完成\n&quot;);            &#125;        &#125;);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>File常用操作</title>
      <link href="/zjh/2022/01/13/File%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/zjh/2022/01/13/File%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="File对象实例化"><a href="#File对象实例化" class="headerlink" title="File对象实例化"></a>File对象实例化</h1><p>三种构造器</p><pre><code>File file = new File(&quot;C:\\Users\\Administrator\\Desktop\\数据结构代码\\algorithm&quot;);//绝对路径File file1 = new File(file,&quot;testtss.txt&quot;);//根据parent和child构造File file2 = new File(file,&quot;test&quot;);//相对路径</code></pre><p>相对路径在main方法体 和 Test单元测试 二者不同</p><pre><code>main是创建在当前projectTest是创建在当前module</code></pre><ul><li>File对象的实例化仅仅是内存层面开辟了一个空间</li><li>File对象可以存储<strong>文件</strong>，也可以存储<strong>文件目录</strong></li><li>File对象表示的是<strong>路径的最后一个文件</strong>，例如：”C:\Users\Administrator\Desktop\数据结构代码\algorithm”的对象对其操作更改的是algorithm文件目录<br><img src="https://img-blog.csdnimg.cn/7a49bfba1e4f42128289965a77f5c149.png" alt="该文件目录实际存在与否的区别"><h1 id="部分API"><a href="#部分API" class="headerlink" title="部分API"></a>部分API</h1><table><thead><tr><th>方法</th><th>解释</th><th>备注</th></tr></thead><tbody><tr><td>createTempFile</td><td><br>(String prefix, String suffix) <br> (String prefix, String suffix, File directory)</td><td>static方法，“创建空文件”<br>文件名前缀(最少3字符)，文件名后缀<br>前缀，后缀，指定路径的File对象</td></tr><tr><td>deleteOnExit</td><td>run结束后就删掉</td><td>创建的方式是mkdirs，但删除时是只删除该File对象路径的最末尾文件</td></tr><tr><td>delete</td><td>删除File对象对应的文件or文件目录</td><td>必须保证是末梢路径，不然不能删除并且返回false<br><strong>用delete删除的文件不走回收站</strong></td></tr><tr><td>renameTo(File dest)</td><td>1,如果<strong>destFile对象与源文件File对象</strong>是在同一个路径下，那么renameTo的作用是重命名<br> 2,如果目标文件与源文件不是在同一个路径下，那么renameTo的作用就是剪切，而且还不能操作文件夹。</td><td>见代码详解</td></tr><tr><td>getParent<br>getParentFile</td><td>返回父路径String<br>返回父路径File</td><td>用于同路径创建等操作</td></tr><tr><td>length</td><td>返回字节长度long</td><td>非空小文件的length返回值可能为0</td></tr></tbody></table></li></ul><p><a href="https://www.cnblogs.com/wangjinlong-padan/p/6382924.html">参考链接</a></p><pre><code>    File file1 = new File(&quot;D:\\io\\io2\\io3\\start.txt&quot;);    System.out.println(file1.createNewFile());//true创建成功，存在则false    File file2 = new File(&quot;D:\\io\\io1\\io3\\dest.txt&quot;);    System.out.println(file1.renameTo(file2));//dest不存在，则true    // &quot;D:\\io\\io2\\io3\\start.txt&quot;变成了&quot;D:\\io\\io1\\io3\\dest.txt&quot;( 路径不同：剪切 )    //若dest文件已存在，则返回false    File file3 = new File(&quot;D:\\io\\io1\\io3\\file.txt&quot;);    System.out.println(file2.renameTo(file3));( 同路径：重命名)</code></pre><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><h3 id="1，遍历删除"><a href="#1，遍历删除" class="headerlink" title="1，遍历删除"></a>1，遍历删除</h3><p>要求：</p><ul><li>遍历d:\io目录下的所有文件and文件目录名</li><li>删除png，img格式的文件，并告知删除成功</li></ul><p>代码示例：</p><pre><code>public class FileTest1 &#123;    public static void intoDir(File f)&#123;//定义静态方法            File[] files = f.listFiles();//罗列内部所有File对象        for(File ff : files)&#123;            if (ff.isFile())&#123;                System.out.println(&quot;文件&quot; + ff.toString());                /*****************删除img，png格式的图片文件**********/                if(ff.toString().endsWith(&quot;img&quot;) || ff.toString().endsWith(&quot;png&quot;))&#123;                    ff.delete();                    System.out.println(&quot;删除成功：&quot;+ff.toString());                &#125;                /****************************************************/            &#125;            else&#123;                System.out.println(&quot;文件目录&quot; + ff.toString());                intoDir(ff);//递归            &#125;        &#125;    &#125;    public static void main(String[] args) throws IOException &#123;    File file = new File(&quot;D:\\io&quot;);   FileTest1.intoDir(file);//调用静态遍历方法    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/7d1eec4e4ffa462dbea8d2fadcb2a6d4.png" alt="运行结果"></p><h3 id="2，遍历计算大小"><a href="#2，遍历计算大小" class="headerlink" title="2，遍历计算大小"></a>2，遍历计算大小</h3><p>要求：</p><ul><li>计算指定文件目录的大小</li><li>删除空文件（不是删空的文件目录）</li></ul><p>代码示例：</p><pre><code>public class FileTest1 &#123;    public static long sumLength(File file)&#123;        File[] files = file.listFiles();        long sum = 0;        for(File f : files)&#123;            if (f.isFile())&#123;                /****判断是否为空文件，若是则删除并告知****/                long length = f.length();                if(length == 0)&#123;                    f.delete();                    System.out.println(&quot;删除空文件：&quot;+f.toString());                &#125;                else&#123;                    sum += length;                &#125;                /*******************  *****************/            &#125;            else&#123;                FileTest1.sumLength(f);            &#125;        &#125;        return sum;    &#125;    public static void main(String[] args) &#123;        File file = new File(&quot;D:\\io&quot;);        long l = FileTest1.sumLength(file);        System.out.println(&quot;该文件总长为：&quot;+l);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/42f104763d8742e3b6dd707a10e1b2e6.png" alt="运行结果"></p><h3 id="为什么最后的文件总长计算结果为0？"><a href="#为什么最后的文件总长计算结果为0？" class="headerlink" title="为什么最后的文件总长计算结果为0？"></a>为什么最后的文件总长计算结果为0？</h3><p> <strong>因为小文件会内联存储</strong><br><a href="https://www.zhihu.com/question/23972911?rf=51585723">NTFS文件系统是如何处理小文件的</a></p><p><a href="https://product.pconline.com.cn/itbk/software/dnyw/1703/8961027.html">占用空间和文件大小的区别</a></p><table><thead><tr><th align="center"><p></th><th align="center">大小对比</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">小文件</td><td align="center">文件大小 &gt; 占用空间<br>通常,占用空间为0</td><td align="center">因为小文件内联存储</td></tr><tr><td align="center">大文件</td><td align="center">文件大小 &lt; 占用空间</td><td align="center">大文件占用空间包括了<strong>没有使用的簇</strong>的空间大小</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随机森林——泰坦尼克号获救预测</title>
      <link href="/zjh/2022/01/11/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E8%8E%B7%E6%95%91%E9%A2%84%E6%B5%8B/"/>
      <url>/zjh/2022/01/11/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E8%8E%B7%E6%95%91%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>定义问题——&gt;数据收集——&gt;数据清洗——&gt;分析——&gt;建模——&gt;验证——&gt;优化</p><p>该问题下前两步已经完成，本文从数据清洗开始</p><h1 id="数据集的特征解读"><a href="#数据集的特征解读" class="headerlink" title="数据集的特征解读"></a>数据集的特征解读</h1><table><thead><tr><th align="center">英</th><th align="center">中</th><th align="center">分析</th></tr></thead><tbody><tr><td align="center">PassengeID</td><td align="center">乘客ID</td><td align="center">乘客ID不影响Survive与否，但可标识身份</td></tr><tr><td align="center">Pclass</td><td align="center">船舱等级</td><td align="center">高等船舱靠近甲板，更容易Survive</td></tr><tr><td align="center">Name</td><td align="center">姓名</td><td align="center">标记</td></tr><tr><td align="center">Sex</td><td align="center">性别</td><td align="center">男女生理差别，对Survive有影响</td></tr><tr><td align="center">Age</td><td align="center">年龄</td><td align="center">同上</td></tr><tr><td align="center">SibSp</td><td align="center">兄弟配偶数</td><td align="center">有无同行兄弟or配偶，同行会影响决策</td></tr><tr><td align="center">Parch</td><td align="center">父母孩子数</td><td align="center">有无同行父母or孩子，从而影响Survive</td></tr><tr><td align="center">Ticket</td><td align="center">船票信息</td><td align="center">/</td></tr><tr><td align="center">Fare</td><td align="center">票价</td><td align="center">票价跟Pclass也是正相关</td></tr><tr><td align="center">Cabin</td><td align="center">船舱信息</td><td align="center">/</td></tr><tr><td align="center">Embarked</td><td align="center">港口</td><td align="center">/</td></tr><tr><td align="center">Survived</td><td align="center">存活与否</td><td align="center">/</td></tr></tbody></table><p>以上信息中</p><ul><li>有些特征对分析没什么意义，建模时可以不扔进算法</li><li>有些特征之间互相有关联，可以多特征线性合并</li><li>部分数据需要清洗</li><li>Train集中的Survived变量要放入模型训练</li><li>Test集中的Survived变量作为验证标准</li></ul><h1 id="库和数据导入，简单分析"><a href="#库和数据导入，简单分析" class="headerlink" title="库和数据导入，简单分析"></a>库和数据导入，简单分析</h1><pre><code>import pandas as pdimport numpy as npimport timeimport sklearnfrom sklearn import ensemble#集成学习，包括了随机森林，SVM等集成学习算法from sklearn import feature_selection#特征值选择，分类回归都需要的特征值如F和Pfrom sklearn import model_selection#模型选择，包括了交叉验证，网格搜索等from sklearn import metrics#包括了多个计算模型评估的算法from sklearn.preprocessing import LabelEncoder#将Label标准化，如：字符串——&gt;数字，以便代入模型##绘图import matplotlib as mplimport matplotlib.pyplot as pltimport seaborn as sns#一个封装好的matplotlib，底层是matplotlib，使用更方便#mpl.style_use(&quot;ggplot&quot;)#设置matplotlib的绘图风格，可有可无data_train = pd.read_csv(&quot;train.csv&quot;)data_test  = pd.read_csv(&quot;test.csv&quot;)#显示数据集信息print(data_train.info())print(data_test.head(10))</code></pre><h2 id="完整显示数据集统计信息（完整描述）set-option"><a href="#完整显示数据集统计信息（完整描述）set-option" class="headerlink" title="完整显示数据集统计信息（完整描述）set_option"></a>完整显示数据集统计信息（完整描述）set_option</h2><pre><code>pd.set_option(&#39;display.max_columns&#39;,11)#train集中有11列属性，设置最大列数为11print(data_train.describe())</code></pre><ul><li>同样的，pd.set_option(‘display.max_columns’,10)也可以让原本显示不全的head()显示全</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/5cef01f2bb72055365b892b39b01cdfb.png" alt="info和head输出结果"></p><pre><code>count:有效值个数（非空值）unique:特征值的种类数top：出现最多的特征freq: top出现的次数mean：均值std : 标准差min ：最小值25%：四分之一位50%：中位数75%：四分之三位max：最大值</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/aadde03b94c0c0ced9033806d8fa540f.png" alt="describe输出结果"></p><ul><li><strong>一共有891行数据，但Age、Cabin属性明显缺失，此案例下的缺失值暂时用中位数代替</strong></li></ul><h1 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h1><p>数据清洗是数据分析中耗时最长最麻烦的阶段</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><pre><code>#列名小写,方便后续data_test.columns = data_test.columns.str.lower()data_train.columns = data_train.columns.str.lower()data_train.info()#查看属性小写后的info#合并Train和Test以便统一数据清洗data_sum = [data_train , data_test]#但由于这个sum是一个list，会缺少很多原本train和test能用的属性or方法，如columns#注意：此处的合并不是直接合并数据集，而是创建一个list，实现一键操作#一定是先分别lower再合并成sum</code></pre><p>   <strong>要想调用方法，需要使用for循环</strong></p><h3 id="查看survived的统计直方图"><a href="#查看survived的统计直方图" class="headerlink" title="查看survived的统计直方图"></a>查看survived的统计直方图</h3><pre><code>#查看属性统计量seaborn下的countplot，绘制图像sns.countplot(x = data_train[&#39;survived&#39;] )#sns.coutplot(x = &quot;survived&quot; , data = data_train)#两种表达方式plt.show()#olt.show()是生成图的操作，必不可少</code></pre><h2 id="补全缺失值fillna"><a href="#补全缺失值fillna" class="headerlink" title="补全缺失值fillna"></a>补全缺失值fillna</h2><pre><code>#分别查看train和test集中为null值的汇总print(data_train.isnull().sum())print(&#39;\n&#39;)print(data_test.isnull().sum())</code></pre><ul><li><strong>age embarked的缺失值占比比较少，可以替换值</strong></li><li><strong>cabin的缺失值占比很高，建模时直接把cabin属性全扔掉</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/6608f6f8d8f17032998fd2e2801c213b.png" alt="左：null汇总  右：contplot直方图"></p><h3 id="利用for循环对样本集一键纠正"><a href="#利用for循环对样本集一键纠正" class="headerlink" title="利用for循环对样本集一键纠正"></a>利用for循环对样本集一键纠正</h3><pre><code>for dataset in data_sum:    dataset[&#39;age&#39;].fillna(dataset[&#39;age&#39;].median() , inplace=True)    dataset[&#39;fare&#39;].fillna(dataset[&#39;fare&#39;].median() , inplace=True)    ###因为age、fare都是数字类型，因此可以调用median中位数    ###而像属性值位字符串的特征则不能调用median    dataset[&#39;embarked&#39;].fillna(dataset[&#39;embarked&#39;].mode()[0] , inplace=True)    #mode返回的是 众数，因为即便是字符串，也可以调用</code></pre><ul><li><p>注意：mode和median的用法场景区别</p></li><li><p>注意fillna的使用格式</p></li><li><p>inplace=True表示更改原数据集，而不是返回一个新的数据集</p></li><li><p>mode是pandas下的一个方法，返回按索引号排序的众数，<strong>mode()[索引号]的索引号很重要，如果省略则不填充</strong></p><h2 id="删除无用字段-特征-drop"><a href="#删除无用字段-特征-drop" class="headerlink" title="删除无用字段(特征)drop"></a>删除无用字段(特征)drop</h2><p>  drop_columns = [‘cabin’,’passengerid’,’ticket’]#创建一个list<br>  #分析认为：cabin缺失值太多，需要删除<br>  #passengerid无关survive，删除<br>  #ticket都是编号，删除</p><p>  data_train.drop(drop_columns,axis=1,inplace=True)<br>  data_test.drop(drop_columns,axis=1,inplace=True)<br>  #drop参数的意义(行or列 , axis=0删行 axis=1删列 ， inplace=True直接更改调用者数据集本身)</p></li><li><p>注意：drop的参数含义</p></li><li><p>可以构建for循环 + drop_columns一次操作</p></li></ul><h2 id="纠正异常值"><a href="#纠正异常值" class="headerlink" title="纠正异常值"></a>纠正异常值</h2><h3 id="利用for循环的样本集一键纠正"><a href="#利用for循环的样本集一键纠正" class="headerlink" title="利用for循环的样本集一键纠正"></a>利用for循环的样本集一键纠正</h3><p>因为这个案例中信息来源准确，可以认为没有异常值，故在此案例中不做处理</p><h2 id="构建新特征"><a href="#构建新特征" class="headerlink" title="构建新特征"></a>构建新特征</h2><ul><li>连续值用cut或者qcut来划分</li><li>离散值直接划分，合并数量少的值<h3 id="同行规模"><a href="#同行规模" class="headerlink" title="同行规模"></a>同行规模</h3><pre><code>  #同行规模 = 配偶 + 兄弟姐妹 + 1(自己)  dataset[&#39;together_size&#39;] =  dataset[&#39;sibsp&#39;] + dataset[&#39;parch&#39;] + 1</code></pre></li></ul><h3 id="是否单身"><a href="#是否单身" class="headerlink" title="是否单身"></a>是否单身</h3><pre><code>    #是否单身：单身可以不顾别人，会影响survive    dataset[&#39;isSingle&#39;] = 0    dataset[&#39;isSingle&#39;].loc[dataset[&#39;together_size&#39;] &gt; 1] = 1</code></pre><h3 id="票价分段：cut"><a href="#票价分段：cut" class="headerlink" title="票价分段：cut"></a>票价分段：cut</h3><pre><code>    #票价分段fare_bin:票价的离散值太多，应该划分为几个集    #数据集中票价0~512，并且绝大多数都是便宜票，所以用cut等宽划分    dataset[&#39;fare_bin&#39;] = pd.cut(dataset[&#39;fare&#39;] , 4)</code></pre><h3 id="年龄分段：qcut"><a href="#年龄分段：qcut" class="headerlink" title="年龄分段：qcut"></a>年龄分段：qcut</h3><pre><code>    #年龄分段age_bin    dataset[&#39;age_bin&#39;] = pd.qcut(dataset[&#39;age&#39;] , 4)</code></pre><h3 id="身份分类：合少为1"><a href="#身份分类：合少为1" class="headerlink" title="身份分类：合少为1"></a>身份分类：合少为1</h3><pre><code>    #身份 status:因为英国人的名字会加入跟身份有关的职业，身份也会影响获救概率    dataset[&#39;status&#39;] = dataset[&#39;name&#39;].str.split(&#39;, &#39; , expand = True)[1].str.split(&#39;.&#39; , expand = True)[0]    ###参数含义：str是返回字符串，expand要为True值    ###按引号中的符号进行split拆分，[0]表示取前半段，[1]表示取后半段    print(dataset[&#39;status&#39;].value_counts())#查看统计</code></pre><p><img src="https://img-blog.csdnimg.cn/6a4e973ba6174e63a9514db8712abbc3.png" alt="可以把少的分为一类other"></p><pre><code>   #把少的分为一类other    othersSum = dataset[&#39;status&#39;].value_counts() &lt; 10    #other对象 = 小于10的    dataset[&#39;status&#39;] = dataset[&#39;status&#39;].apply(lambda x : &#39;ohter&#39; if othersSum[x] else x)    #更新后的status属性 = 之前的status.aooly(lambda x : &#39;新的名字&#39; if other对象[x] else x)    print(dataset[&#39;status&#39;].value_counts())</code></pre><p><img src="https://img-blog.csdnimg.cn/2629dc2066e64987b95896a87db5dd6c.png" alt="少的被分到了other组"></p><h2 id="新特征分析：评估新特征划分的好坏"><a href="#新特征分析：评估新特征划分的好坏" class="headerlink" title="新特征分析：评估新特征划分的好坏"></a>新特征分析：评估新特征划分的好坏</h2><p>以不同的特征分类计算各属性值的均值，以标签survived的均值为参考，不同特征值的标签均值差别越大越好</p><pre><code>#简单分析上述构建特征是否有效:groupby根据属性值分组print(data_train[&#39;survived&#39;].groupby(data_train[&#39;status&#39;]).mean())#查看按这样构建的特征status的不同值survived对应的均值print(data_train[&#39;survived&#39;].groupby(data_train[&#39;age_bin&#39;]).mean())print(data_train[&#39;survived&#39;].groupby(data_train[&#39;fare_bin&#39;]).mean())print(data_train[&#39;survived&#39;].groupby(data_train[&#39;isSingle&#39;]).mean())print(data_train[&#39;survived&#39;].groupby(data_train[&#39;together_size&#39;]).mean())</code></pre><p><img src="https://img-blog.csdnimg.cn/7fb4dcd3150d4be886223a0af1715d6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_19,color_FFFFFF,t_70,g_se,x_16" alt="新特征分析">于是对age_bin进行修改，最终尝试结果是qcut改cut，区分度提升最明显</p><h1 id="格式替换-构建新字段，"><a href="#格式替换-构建新字段，" class="headerlink" title="格式替换,构建新字段，"></a>格式替换,构建新字段，</h1><p>1，基于scikit-learn中的LabelEncoder()<br>把属性值为字符串的特征转化为“特征_code”，字符串——&gt;数字，以便放入模型中跑<br><strong>机器学习模型只能处理int和float的数据</strong></p><pre><code>#实例化label = LabelEncoder()#字符串——&gt;数字for dataset in data_sum:    # （1）新字段：sex_code    dataset[&#39;sex_code&#39;] = label.fit_transform(dataset[&#39;sex&#39;])    # （2）新字段：embarked_code    dataset[&#39;embarked_code&#39;] = label.fit_transform(dataset[&#39;embarked&#39;])    # （3）新字段：status_code    dataset[&#39;status_code&#39;] = label.fit_transform(dataset[&#39;status&#39;])    # （4）新字段：age_bin_code    dataset[&#39;age_bin_code&#39;] = label.fit_transform(dataset[&#39;age_bin&#39;])    # （5）新字段：fare_bin_code    dataset[&#39;fare_bin_code&#39;] = label.fit_transform(dataset[&#39;fare_bin&#39;])print(data_train.columns.to_list)    </code></pre><p><img src="https://img-blog.csdnimg.cn/e20dfbee4e5b4bb7992cfb15aaeae6ac.png" alt="新的列名"><br><img src="https://img-blog.csdnimg.cn/cda97a956c634886b678242a3a315ec8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br>2，通过Pandas中的get_dummies() 进行编码</p><h1 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h1><h2 id="标签、特征选择"><a href="#标签、特征选择" class="headerlink" title="标签、特征选择"></a>标签、特征选择</h2><h3 id="标签选择"><a href="#标签选择" class="headerlink" title="标签选择"></a>标签选择</h3><pre><code>target = [&#39;survived&#39;]    </code></pre><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><pre><code>data_feature_one = [&#39;sex&#39;, &#39;pclass&#39;, &#39;embarked&#39;, &#39;status&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;age&#39;, &#39;fare&#39;, &#39;together_size&#39;,                    &#39;isSingle&#39;]</code></pre><h3 id="通过Pandas中的get-dummies-进行编码"><a href="#通过Pandas中的get-dummies-进行编码" class="headerlink" title="通过Pandas中的get_dummies() 进行编码"></a>通过Pandas中的get_dummies() 进行编码</h3><p>这是一个暴力转码（字符串——&gt;数字代号）的方法，十分简单，且更好用</p><pre><code>data_one_dummy = pd.get_dummies(data_train[data_feature_one])#把data_feature_one中需要转码的如：status、embarked转为数字代号data_one_dummy_list = data_one_dummy.columns.tolist()#转list，以便放入网格搜索的形参中去跑</code></pre><h2 id="把train集拆分为训练集和测试"><a href="#把train集拆分为训练集和测试" class="headerlink" title="把train集拆分为训练集和测试"></a>把train集拆分为训练集和测试</h2><pre><code>X_train_one, X_test_one, y_train_one, y_test_one = model_selection.train_test_split(data_one_dummy[data_one_dummy_list],#转码后的list格式的train[feature]                                                                    data_train[target],#标签                                                                    random_state = 0)#随机种子print(X_train_one.shape)print(X_test_one.shape)#shape查看分割的大小，也可以通过size参数自己设置分割比例,数据量很大时通常使用2 8分，train_size=0.8print(y_train_one.shape)print(y_test_one.shape)#大X表示：特征  小y表示：标签</code></pre><p><img src="https://img-blog.csdnimg.cn/f70f693e524f4c75bfdb6ccfe37883b4.png" alt="左：数据量(行)  右：特征数(列)"></p><h2 id="网格搜索：寻找最优"><a href="#网格搜索：寻找最优" class="headerlink" title="网格搜索：寻找最优"></a>网格搜索：寻找最优</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><pre><code>from sklearn.model_selection import GridSearchCV   #网格搜索from sklearn.ensemble import RandomForestClassifier #随机森林分类器rfc = RandomForestClassifier(max_features=&#39;auto&#39; , random_state= 0 , n_jobs=-1 )#实例化一个RandomForestClassifier对象#简单选取所有特征 ， 随机种子=0  ， 利用所有线程#这里实例化RandomForestClassifier时可以不用写入太多参数，参数可以放进网格里面自己跑出最优的</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><pre><code>param_gird = &#123;#需要最优化的参数对象    &#39;criterion&#39; : [&#39;gini&#39;, &#39;entropy&#39;],#标准选择    &#39;min_samples_leaf&#39; : [ 1,3,5, 10],#最小子叶数    &#39;min_samples_split&#39; : [10, 12, 16,20,24],#最小样本数    &#39;n_estimators&#39; : [20,35,50,100]#决策树的个数选择&#125;gscv = GridSearchCV(#网格搜索交叉验证对象                estimator=rfc,#rf带入网格算                param_grid=param_gird,#需要最优化的参数带入                scoring= &#39;accuracy&#39;, #得分评判————准确度                cv=3,#交叉验证次数                n_jobs=-1)#-1 利用CPU所有线程gs = gscv.fit(X_train_one , y_train_one.values.ravel())#自动训练，两个参数都是train集#.values.ravel()是为了防止warning#自动训练的所有结果返回在gs中，这个print(gs.best_score_)#最高分数print(gs.best_params_)#最佳组合</code></pre><p><img src="https://img-blog.csdnimg.cn/7b7e4e2ba989488b8e4d553f025731fc.png"></p><h3 id="网格搜索调参"><a href="#网格搜索调参" class="headerlink" title="网格搜索调参"></a>网格搜索调参</h3><ul><li>如果某特征的最优值是在罗列的数的中间，那么认为比较优秀</li><li>如果在边上，就需要往那个方向调参重新跑</li><li>同时有多个参数需要调时，先调差距最大的</li><li>即使是位于中间的参数也可以细分调整</li><li>类似高中生物实验探究题《寻找最佳浓度》的思想</li></ul><h2 id="用最优参数训练随机森林"><a href="#用最优参数训练随机森林" class="headerlink" title="用最优参数训练随机森林"></a>用最优参数训练随机森林</h2><pre><code>#实例化RandomForestClassifier对象rfc2 = RandomForestClassifier(criterion=&#39;entropy&#39;,                             min_samples_leaf=5,                             min_samples_split=16,                             n_estimators=35,                             n_jobs=-1,                             random_state=1)#训练rfc2.fit(X_train_one, y_train_one.values.ravel())</code></pre><p>此时训练完成，等待后续用<strong>split分割出来的测试集test来测试</strong></p><h3 id="根据特征的重要性排序"><a href="#根据特征的重要性排序" class="headerlink" title="根据特征的重要性排序"></a>根据特征的重要性排序</h3><pre><code>print(pd.concat((pd.DataFrame(X_train_one.iloc[:, 1:].columns, columns=[&#39;Variable&#39;]),           pd.DataFrame(rfc2.feature_importances_, columns=[&#39;importance&#39;])),           axis=1).sort_values(by=&#39;importance&#39;, ascending=False))</code></pre><p><img src="https://img-blog.csdnimg.cn/1583b73b3f2845c2b203ded785146e72.png"></p><ul><li><strong>重要性</strong>：重要性是特征在模型中的决定能力，而不是越高就代表标签越接近1</li></ul><h2 id="在test上预测：是split分割出来的test"><a href="#在test上预测：是split分割出来的test" class="headerlink" title="在test上预测：是split分割出来的test"></a>在test上预测：是split分割出来的test</h2><pre><code>predict_test = rfc2.predict(X_test_one)#test集中的特征数据Xpred_df = pd.DataFrame(predict_test, columns=[&#39;survived&#39;])#预测结果表print(pred_df)#test集的验证结果print(&#39;随机森林 AUC...&#39;)fpr_test, tpr_test, th_test = metrics.roc_curve(predict_test, y_test_one)# 构造 roc 曲线print(&#39;AUC = %.4f&#39; %metrics.auc(fpr_test, tpr_test))#参考意义最大的就是AUCprint(&#39;随机森林精确度...&#39;)print(metrics.classification_report(predict_test, y_test_one))#精准度表格</code></pre><p><img src="https://img-blog.csdnimg.cn/04fabbe4baed47c68ad12214800bf1d0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_19,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="验证：不是split分割出来的test，而是test-csv"><a href="#验证：不是split分割出来的test，而是test-csv" class="headerlink" title="验证：不是split分割出来的test，而是test.csv"></a>验证：不是split分割出来的test，而是test.csv</h2><pre><code>data_val_dummy = pd.get_dummies(data_test[data_feature_one])#转码data_val_dummy_list = data_val_dummy.columns.tolist()print(data_val_dummy_list)#查看转码后的列名，拿着这些列名预测pred_val = rfc2.predict(data_val_dummy[[#根据上一条语句的结果，copy了列名                                        &#39;pclass&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;age&#39;,                                        &#39;fare&#39;, &#39;together_size&#39;, &#39;isSingle&#39;,                                        &#39;sex_female&#39;, &#39;sex_male&#39;, &#39;embarked_C&#39;,                                        &#39;embarked_Q&#39;, &#39;embarked_S&#39;, &#39;status_Master&#39;,                                        &#39;status_Miss&#39;, &#39;status_Mr&#39;, &#39;status_Mrs&#39;,                                        &#39;status_ohter&#39;]])pred_val_df = pd.DataFrame(pred_val, columns=[&#39;survived&#39;])print(pred_val_df.head(10))#展示前10个数据</code></pre><p><img src="https://img-blog.csdnimg.cn/348435ac3b974dfd827f256ee10998f0.png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/zjh/2022/01/03/Java%E9%9B%86%E5%90%88/"/>
      <url>/zjh/2022/01/03/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><blockquote><ul><li>集合框架被设计成要满足以下几个目标。<br></li><li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。<br></li><li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li><li>对一个集合的扩展和适应必须是简单的。</li></ul></blockquote><p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet 等,<strong>除此之外你也可以通过这些接口实现自己的集合。</strong></p><p><img src="https://img-blog.csdnimg.cn/202109060840461.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/20210906085157676.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/20210906085253299.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif"></p><p><strong>一般名为xxxxList  xxxxSet   xxxxMap的类都是集合，集合的子类非常多，本文介绍以下的集中常用集合类</strong><br>常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。</p><blockquote><p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p></blockquote><blockquote><p><strong>接口</strong>：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</p></blockquote><blockquote><p><strong>实现（类）</strong>：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</p></blockquote><blockquote><p><strong>算法</strong>：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。**(Collections类提供了排序，遍历等多种算法实现)**<br>Java 集合框架提供了一套性能优良，使用方便的接口和类，<strong>java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。</strong></p></blockquote><h1 id="线程安全和线程不安全的集合"><a href="#线程安全和线程不安全的集合" class="headerlink" title="线程安全和线程不安全的集合"></a>线程安全和线程不安全的集合</h1><p>Vector、HashTable、Properties是线程安全的；</p><p>ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap等都是线程不安全的。</p><h1 id="Collection根接口：单列集合"><a href="#Collection根接口：单列集合" class="headerlink" title="Collection根接口：单列集合"></a>Collection根接口：单列集合</h1><p>Collection下定义了很多方法：<strong>add  addAll  clear  contains  containsAll  equals  hashCode  isEmpty  iterator  parallelStream  remove  removeAll  removeIf  retainAll  size  spliterator  stream  toArray</strong>等</p><h2 id="List子接口：有序可重复"><a href="#List子接口：有序可重复" class="headerlink" title="List子接口：有序可重复"></a>List子接口：有序可重复</h2><p>有序：List的有序源于它的元素有地址值<br>List接口下的ArrayList，LinkedList都线程不安全，多线程访问时需显式同步。</p><h3 id="ArrayList实现类："><a href="#ArrayList实现类：" class="headerlink" title="ArrayList实现类："></a>ArrayList实现类：</h3><p>List接口的主要实现类<br>底层是Object[] elementData(<strong>动态可修改的数组，封装好的数组，存储地址连续</strong>)</p><ul><li>增删操作低效(底层是数组)</li><li>查找、修改效率高(有索引)</li><li>执行效率高，但线程不安全。多线程访问时需显式同步。</li></ul><h4 id="ArrayList底层分析"><a href="#ArrayList底层分析" class="headerlink" title="ArrayList底层分析"></a>ArrayList底层分析</h4><ul><li><strong>参数int capacity:</strong> 空参默认底层创建长度为10的数组，<br>JDK7之前是“饿汉”，JDK8之后是“懒汉”————JDK8后延迟底层数组创建，<em>new时底层不创建数组，当且仅当add元素后创建底层数组</em>，节约了内存</li><li><strong>扩容:</strong> 当前底层数组长度不够用时，扩容为原来的<strong>1.5倍</strong></li><li>开发中尽量带参构造，防止内存浪费</li></ul><h3 id="LinkedList实现类："><a href="#LinkedList实现类：" class="headerlink" title="LinkedList实现类："></a>LinkedList实现类：</h3><p>底层是<strong>双向链表</strong></p><ul><li>增删效率高(改变链表的next和prev地址即可，涉及的操作元素很少)</li><li>查找、修改效率低(没有索引)</li><li>执行效率高，但线程不安全。多线程访问时需显式同步。<blockquote><p>LinkedList 继承了 AbstractSequentialList 类。<br><br>LinkedList 实现了 Queue 接口，可作为队列使用。<br><br>LinkedList 实现了 List 接口，可进行列表的相关操作。<br><br>LinkedList 实现了 Deque 接口，可作为队列使用。<br><br>LinkedList 实现了 Cloneable 接口，可实现克隆。<br><br>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。</p></blockquote></li></ul><h2 id="Set子接口：无序不可重复"><a href="#Set子接口：无序不可重复" class="headerlink" title="Set子接口：无序不可重复"></a>Set子接口：无序不可重复</h2><p>因为无序，所以不能重复，类似于高中所学的“集合”<br><br>开发中Set接口用的不太多，一般用List和Map更多</p><ul><li>Set没有额外定义方法，所有方法和Collection根接口定义的相同</li><li><strong>无序性</strong>：不是随机，而是add时由数据的哈希值决定存储位置，对外“相对无序”<br></li><li><strong>不可重复性</strong>：add时先调用hashcode方法算哈希值，不相等则直接add；若有相同的哈希值，则进行equals方法比对细节，若还相等，则add方法返回false，添加失败</li></ul><h3 id="HashSet实现类"><a href="#HashSet实现类" class="headerlink" title="HashSet实现类"></a>HashSet实现类</h3><p>底层是<strong>哈希表</strong>(元素为链表的数组)</p><ul><li>效率高，但线程不安全。多线程访问时需显式同步。</li><li>可以存储一个null值并分配空间</li><li>遍历无序，每次遍历输出的顺序都可能不同</li></ul><h4 id="LinkedHashSet实现类"><a href="#LinkedHashSet实现类" class="headerlink" title="LinkedHashSet实现类"></a>LinkedHashSet实现类</h4><ul><li>LinkedHashSet是HashSet的一个子类<br>底层是<strong>哈希表+链表</strong>(链表可以保证元素的顺序透明)</li><li>遍历时会<strong>按照添加进来的顺序进行遍历</strong><blockquote><p>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p></blockquote></li><li><em>LinkedHashSet在迭代访问（遍历）Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</em>*<br><br><br>在开发中由需求决定具体使用哪个</li></ul><blockquote><ul><li>补充：去除List中重复元素的方法：把List对象扔给LinkedHashSet的构造器形参</li></ul></blockquote><h3 id="TreeSet实现类（用的少）"><a href="#TreeSet实现类（用的少）" class="headerlink" title="TreeSet实现类（用的少）"></a>TreeSet实现类（用的少）</h3><p>SortedSet接口的唯一实现类，<strong>自排序</strong>的集合<br><br>底层是<strong>红黑树</strong>(自平衡的二叉树)</p><ul><li><strong>自排序</strong>：存储元素的类必须实现Comparable接口或Comparator接口<br><br>  并且为了保证可以排序，<strong>后续add的所有元素必须跟第一个add的元素类型相同</strong>，否则报错ClassCastException</li><li><strong>包装类的自排序</strong>：由于包装类都实现了Comparable自然排序，所以包装类元素可以直接扔进TreeSet</li><li>自定义类需先实现排序接口才能扔进TreeSet</li></ul><h1 id="Map根接口"><a href="#Map根接口" class="headerlink" title="Map根接口"></a>Map根接口</h1><p>双列数据，存储键值对，类似高中函数y=f(x)<br>key:无序、不可重复——&gt;Set储存<br>value:无序、可重复——&gt;Collection储存</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><a href="https://zhuanlan.zhihu.com/p/78079598">链接：HashMap底层原理</a></p><p>散列表</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="/zjh/2022/01/02/Java%E6%B3%9B%E5%9E%8B/"/>
      <url>/zjh/2022/01/02/Java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Java 泛型（generic）是 JDK 5 中引入的一个新特性, 泛型提供了<strong>编译时</strong>类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>泛型设计背景：集合容器类在设计/声明的时候不能确定到底是存储什么类型的元素，但对元素如何存储，如何使用都是清楚的，唯一不确定的是元素的类型，因此在JDK1.5的时候引入了泛型来解决这个问题；把元素的类型设置为一个参数，这个参数就叫泛型：Collection<E>  List<E>  Map<E>这个E就是类型参数，即泛型；</p><p>什么时候使用：设计时只设计用法不考虑类型，使用时必须确定类型</p><p>正如ArrayList<String>表示的含义即为：只能存储String类型元素的ArrayList集合</p><h1 id="1-0泛型使用特点"><a href="#1-0泛型使用特点" class="headerlink" title="1.0泛型使用特点"></a>1.0泛型使用特点</h1><p>在<strong>编译之后程序会采取<u>去泛型化</u>的措施</strong>。也就是说Java中的泛型，<u>只在编译阶段有效</u>。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出（<strong>类型擦除</strong>），并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><h2 id="1-1符号"><a href="#1-1符号" class="headerlink" title="1.1符号"></a>1.1符号</h2><p>常用的通配符有T,E,K,V分别表示类型、元素、键、值，当然这并不是硬性规定，而是大家形成的一种通识。</p><h2 id="1-2规范"><a href="#1-2规范" class="headerlink" title="1.2规范"></a>1.2规范</h2><p>泛型只能是类，不能是基本数据类型：int(×) Integer(√)</p><p>定义了泛型之后，在编译期也要受泛型的约束，从而在某些情况可以避免强转操作</p><p>方法中不是出现<E>就一定是泛型方法，详见</p><p>类上声明的泛型<T>和类中又声明的泛型<E>是两回事</p><h1 id="2-0泛型的声明与指定"><a href="#2-0泛型的声明与指定" class="headerlink" title="2.0泛型的声明与指定"></a>2.0泛型的声明与指定</h1><p><a href="https://www.cnblogs.com/GGYC/p/10951794.html?ivk_sa=1024320u">链接：泛型的使用场景</a></p><h2 id="2-1类上声明"><a href="#2-1类上声明" class="headerlink" title="2.1类上声明"></a>2.1类上声明</h2><p>声明在类上时，写在类名后边；作为参数或者返回值时，如果在类上没有声明，必须在访问修饰符和返回值之间</p><pre><code>/** * 声明在类上时，写在类名后边 * @param &lt;E&gt; */class Animal &lt;E&gt; &#123;    /**     * 作为属性声明时，必须在类上声明泛型     */    E pet;     /**     * 作为参数或者返回值时，如果在类上没有声明，必须在访问修饰符和返回值之间     * @param pet     */    public  void setPet(E pet)&#123;        this.pet = pet;    &#125;     public E getPet()&#123;        return pet;    &#125;//这里的T在泛型类中没有声明，所以要在泛型方法中&lt;T&gt;声明为泛型方法    public &lt;T&gt; void call(T t)&#123;        System.out.println( t.toString() );     &#125; &#125;</code></pre><h2 id="2-2接口声明、子类声明和指定"><a href="#2-2接口声明、子类声明和指定" class="headerlink" title="2.2接口声明、子类声明和指定"></a>2.2接口声明、子类声明和指定</h2><p>使用泛型实现时，实现类必须使用对应的泛型类。<br>实现类声明泛型跟接口指定泛型可以同时使用。（“声明”“指定”互不影响）</p><pre><code>/** * 作用在接口上，如果实现该接口时指定实现类型 * @param &lt;T&gt; */public interface Animals&lt;T&gt;&#123;    double PI = 3.1415926535;//等价于public static final double PI = 3.1415926535;    void call(T t);//等价于public abstract void call(T t);&#125;/** * 拉布拉多犬 */ /** * 使用泛型实现时，实现类必须使用对应的泛型类。 * 实现类声明泛型跟接口指定泛型可以同时使用。 *如下代码： */ class LaBuLaDuo&lt;T&gt; implements Animals&lt;String&gt; &#123;//&lt;T&gt;是声明新泛型  &lt;String&gt;是指定旧泛型     public void call(String s) &#123;        System.out.println( s );    &#125; &#125;</code></pre><h2 id="2-3泛型通配符？-上限与下限"><a href="#2-3泛型通配符？-上限与下限" class="headerlink" title="2.3泛型通配符？ 上限与下限"></a>2.3泛型通配符？ 上限与下限</h2><p>泛型占位符  ?  的使用<br>如何设置泛型的上限下限</p><p>上限：泛型为E或者E的子类：&lt;? extends E&gt;</p><p>下限：泛型为E或者E的父类：&lt;? super E&gt;</p><p>单独使用：泛型为Object及其子类：&lt;?&gt;</p><pre><code>/** * 小狗狗 */ class Dog extends  Animal &#123;    public String name;    public Integer age; &#125;  /** * 泛型占位符  ?  的使用 * 泛型的上限 &lt; ? extends E&gt;  即传入参数必须为E 的子类 * 泛型的下限 &lt; ? super E&gt; */public class ErHa &lt;E&gt;  &#123;     //当参数传递时可以设置上下限 比如下面的是  传入类型必须是 Dog 的子类，上限为Dog    public  void call(Animal&lt; ? extends E&gt; s)&#123;        System.out.println(s.pet);    &#125;     //传入类型必须是 Dog 的父类，下限为Dog    public  void jump(Animal&lt; ? super E&gt; s)&#123;        System.out.println(s.pet);    &#125;     // ? 占位符单独使用时，相当于 &lt; ? extends Object &gt;    public  void smile(Animal&lt;?&gt; s)&#123;        System.out.println(s.pet);    &#125;      public static void main(String[] args) &#123;        new ErHa&lt;Dog&gt;().call(new Dog());    &#125;&#125;</code></pre><h2 id="2-4上下边界的测试和get-set限制及解释"><a href="#2-4上下边界的测试和get-set限制及解释" class="headerlink" title="2.4上下边界的测试和get set限制及解释"></a>2.4上下边界的测试和get set限制及解释</h2><pre><code>class plate&lt;T&gt;&#123;    private T t;    public plate(T t)&#123;        this.t = t;    &#125;    public  void set(T t)&#123;//测试1        this.t = t;    &#125;    public T get()&#123;        return t;    &#125;&#125;  class Food&#123;&#125;class Furit extends Food&#123;&#125;class Apple extends Furit&#123;&#125;class Banana extends Furit&#123;&#125;   /*************下面测试上下边界通配符***************/         //1.0 extends 通配符上界        plate&lt;? extends Furit&gt; p10 = new plate&lt;Furit&gt;(new Apple());        plate&lt;? extends Furit&gt; p11 = new plate&lt;Banana&gt;(new Banana());        p10 = p11;        p11 = p10;        //上述例子中，&lt;? extends Furit&gt;表示“该盘子可以装Furit包括Furit的所有子类”        //2.0 super 通配符下界(注意第二个&lt;&gt;中的细微差别)        plate&lt;? super Furit&gt; p12 = new plate&lt;Furit&gt;(new Apple());        plate&lt;? super Furit&gt; p13 = new plate&lt;Furit&gt;(new Banana());//        p13.set(new Food());        p13.set(new Furit());        plate&lt;? super Furit&gt; p14 = new plate&lt;Food&gt;(new Food());        plate&lt;? super Furit&gt; p15 = new plate&lt;Furit&gt;(new Furit());        p12 = p13;        p13 = p14;        p14 = p15;        //上述例子中，&lt;? super Furit&gt;表示“该盘子可以装Fuirt包括Fuirt的所有父类”        //并且可知：当指定了泛型时，可以装入泛型的实例化子类          /************通配符？有get和set的限制规则**************/        //p10 p11是extends通配符上界，p12~p15是super通配符上界 //        p10.set(new Apple());即便是同类型也报错//        p15.get(0);  不能获取，报错        p10.get();        p15.set(new Furit());//? extends xxx只能调用get不能调用set//? super xxx只能调用set不能调用get        /*********问：为什么有这样的限制呢*************/        /**答：         * 首先明确一点，创建的plate对象具体存储什么由左右两边共同决定，set和get方法都会受二者的影响         * 具体就是左边的&lt;&gt;限制右边的&lt;&gt;,而右边的&lt;&gt;决定最终存储的类型         *  1，plate&lt;? extends Furit&gt; p10 = new plate&lt;Apple&gt;(new Apple());确定了通配符？,该plate能存储Apple及其子类的实例         *  ~1.1，不能使用set()的原因：         *  从结构出发，左边部分plate&lt;? extends Furit&gt; p10：决定了p10只能接受Furit及其子类Apple或Banana         *  编译看左：&lt;? extends Furit&gt;         *  假设set()可以使用，编译器只能识别set(形参)中是否为“new了一个Furit及其子类的形参”         *  运行看右：&lt;Apple&gt;         *  而右边部分new plate&lt;Apple&gt;(new Apple())一开始就确定了p10只能放Apple         *  倘若可以使用set(new Banana())，由于Banana也是Furit子类，编译器无法判断错误，但运行则会出错         *  因此编译器直接取消了上边界extends中的set方法         *         *  ~1.2而对于get()方法，则没有限制，因为返回值一定是由右边new plate&lt;Apple&gt;(new Apple())所决定的Apple类型,         *      即使是依据左边来盛放返回值，Furit getback = p.get();也是一定可以的         *         * 2，plate&lt;? super Furit&gt; p12 = new plate&lt;Food&gt;(new Apple());右边的&lt;&gt;中必须填Furit或者Food         *  ~2.1不能使用get()的原因：         *  从结构出发，左边部分plate&lt;? super Furit&gt; p12：决定了p12只能接受Furit及其父类Food         *  编译看左，运行看右：         *  假设get()方法可以使用，那么get的返回值用什么接收呢？         *  Furit getback = p12.get();运行时不一定正确         *  Food getback = p12.get();运行时也不一定正确         *  只有超类Object getback = p12.get();才能一定不报错         *  因此继续假设get返回值用Object存储         *  但是这样就使用不了除Object以外的任何方法，并且本身还很容易出错         *  因此编译器直接取消了下边界super中的get方法         *  ~2.2         *  而对于set()方法，则没有限制，因为形参中只要满足右边的&lt;&gt;即可         *         *         */</code></pre><h1 id="3-0自定义结构的泛型"><a href="#3-0自定义结构的泛型" class="headerlink" title="3.0自定义结构的泛型"></a>3.0自定义结构的泛型</h1><p>（结构包括：类、接口、方法）</p><h2 id="3-1自定义类、接口的泛型"><a href="#3-1自定义类、接口的泛型" class="headerlink" title="3.1自定义类、接口的泛型"></a>3.1自定义类、接口的泛型</h2><pre><code>plate p1 = new plate(new Apple());        plate p2 = new plate(new Banana());        p1 = p2;        /*1.0因为省略了泛型，默认泛型T为Object，        该plate盘子可以装所有Object及其子类，所以p1可以转化为p2*/         plate&lt;Food&gt; p3 = new plate&lt;&gt;(new Apple());        plate&lt;Food&gt; p4 = new plate&lt;&gt;(new Banana());        p3 = p4;        p4 = p3;        /*2.0表示该盘子plate可以装Food及其子类，因此可以相互转化*/         plate&lt;Furit&gt; p5 = new plate&lt;&gt;(new Apple());        plate&lt;Furit&gt; p6 = new plate&lt;&gt;(new Banana());        p5 = p6;        p6 = p5;        /*3.0表示盘子可以装Furit及其子类，因此也能相互转化*/         plate&lt;Apple&gt; p7 = new plate&lt;&gt;(new Apple());        /*4.0表示p7盘子只能装Apple及其子类，只有Apple及其子类的盘子可以相互转化*///        plate&lt;Apple&gt; p8 = new plate&lt;&gt;(new Banana());泛型确定为Apple，所以不能赋值Banana        plate&lt;Banana&gt; p8 = new plate&lt;&gt;(new Banana());//        p7 = p8;泛型不同不能相互转化        /*4.1表示p8盘子只能装Banana及其子类，只有Banana及其子类的盘子可以相互转化*/</code></pre><h2 id="自定义方法的泛型"><a href="#自定义方法的泛型" class="headerlink" title="自定义方法的泛型"></a>自定义方法的泛型</h2><pre><code>泛型方法与所处类是否泛型无关只有在public之后跟上&lt;&gt;的才是泛型方法，使用时    public &lt;T&gt; ArrayList&lt;T&gt; arrayToList(T... arr) &#123;        //泛型方法与所处类是否泛型无关        //只有在public之后跟上&lt;&gt;的才是泛型方法，使用时如下        ArrayList&lt;T&gt; DestArr = new ArrayList&lt;&gt;();       for(T t:arr)&#123;           DestArr.add(t);       &#125;//foreach循环中每个t都代表对应的arr[i]        return DestArr;    &#125;</code></pre><h1 id="继承与泛型"><a href="#继承与泛型" class="headerlink" title="继承与泛型"></a>继承与泛型</h1><p>类A&lt;父类&gt;和 类A&lt;子类&gt;是不能相互转化的<br>        //要想实现这种转化，必须使用通配符? 利用上下边界通配符解决</p><pre><code>       plate p1 = new plate(new Apple());        plate p2 = new plate(new Banana());        p1 = p2;        /*1.0因为省略了泛型，默认泛型T为Object，        该plate盘子可以装所有Object及其子类，所以p1可以转化为p2*/         plate&lt;Food&gt; p3 = new plate&lt;&gt;(new Apple());        plate&lt;Food&gt; p4 = new plate&lt;&gt;(new Banana());        p3 = p4;        p4 = p3;        /*2.0表示该盘子plate可以装Food及其子类，因此可以相互转化*/         plate&lt;Furit&gt; p5 = new plate&lt;&gt;(new Apple());        plate&lt;Furit&gt; p6 = new plate&lt;&gt;(new Banana());        p5 = p6;        p6 = p5;        /*3.0表示盘子可以装Furit及其子类，因此也能相互转化*/         plate&lt;Apple&gt; p7 = new plate&lt;&gt;(new Apple());        /*4.0表示p7盘子只能装Apple及其子类，只有Apple及其子类的盘子可以相互转化*///        plate&lt;Apple&gt; p8 = new plate&lt;&gt;(new Banana());泛型确定为Apple，所以不能赋值Banana        plate&lt;Banana&gt; p8 = new plate&lt;&gt;(new Banana());//        p7 = p8;泛型不同不能相互转化        /*4.1表示p8盘子只能装Banana及其子类，只有Banana及其子类的盘子可以相互转化*/         /*************下面测试继承关系***********///        p3 = p5;//        p5 = p3;//        p5 = p7;//以上这种看似继承却不能转化，因为编译器不认同泛型有继承多态性        //即：类A&lt;父类&gt;和 类A&lt;子类&gt;是不能相互转化的        //要想实现这种转化，必须使用通配符? 利用上下边界通配符解决</code></pre><h1 id="实例化规律"><a href="#实例化规律" class="headerlink" title="实例化规律"></a>实例化规律</h1><pre><code>plate&lt;前面的泛型&gt; p = new plate&lt;后面的泛型&gt;(new 泛型对象);对于这样一个实例化语句，一般只有如下两种情况plate&lt;甲&gt; p = new plate&lt;甲&gt;(new 甲或甲的子类);plate&lt;甲&gt; p = new plate&lt;  &gt;(new 甲或甲的子类);//后面的泛型可以省略plate&lt;? extends 甲&gt; = new plate&lt;甲或甲的子类：记作乙&gt;(new 乙或乙的子类);//但如果使用了通配符？，那么后面的泛型必须先指定，不能省略</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>决策树/随机森林——用户流失预测的案例</title>
      <link href="/zjh/2022/01/01/%E5%86%B3%E7%AD%96%E6%A0%91-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E6%B5%81%E5%A4%B1%E9%A2%84%E6%B5%8B%E7%9A%84%E6%A1%88%E4%BE%8B/"/>
      <url>/zjh/2022/01/01/%E5%86%B3%E7%AD%96%E6%A0%91-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E6%B5%81%E5%A4%B1%E9%A2%84%E6%B5%8B%E7%9A%84%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p><strong>摘要</strong>：<br><br>从决策树的定义，优缺点等宏观角度入题，逐步从数学原理过渡到代码实现，最后总结</p><p><strong>关键词</strong>:<br><br>决策树、信息熵、基尼系数、ID3、CART</p><h2 id="决策树是什么"><a href="#决策树是什么" class="headerlink" title="决策树是什么"></a>决策树是什么</h2><blockquote><p>一个根节点，若干个内部节点和叶节点<br><br> 非参数学习算法<br><br> 天然的分类器<br></p></blockquote><h2 id="决策树的目标"><a href="#决策树的目标" class="headerlink" title="决策树的目标"></a>决策树的目标</h2><p>解决<strong>分类</strong>和<strong>回归</strong>问题</p><h2 id="决策树的优点"><a href="#决策树的优点" class="headerlink" title="决策树的优点"></a>决策树的优点</h2><blockquote><ul><li>决策树易于理解和实现，人们在在学习过程中不需要使用者了解很多的背景知识，这同时是它的能够直接体现数据的特点，只要通过解释后都有能力去理解决策树所表达的意义。</li><li>对于决策树，数据的准备往往是简单或者是不必要的，而且能够同时处理数据型和常规型属性，在相对短的时间内能够对大型数据源做出可行且效果良好的结果。</li><li>准确性高: 挖掘出来的分类规则准确性高, 便于理解, 决策树可以清晰的显示哪些字段比较重要, 即可以生成可以理解的规则.</li><li>适合处理有缺失属性的样本，对缺失值不敏感</li></ul></blockquote><h2 id="决策树的缺点"><a href="#决策树的缺点" class="headerlink" title="决策树的缺点"></a>决策树的缺点</h2><blockquote><ul><li>容易发生过拟合（剪枝 随机森林）</li><li>分类过程中每一步都依据单一特征，忽视了特征之间的关联性，在处理特征关联性强的数据时表现不好</li><li>对于样本不均衡的数据集表现不好，欠拟合。在特征选择时ID3算法偏好于选取可取值数目较多的属性,C4.5算法偏向选取可取值数目较少的属性（实际中是在算法中采用启发式原则，先从候选属性中选出信息增益高于平均水平的属性，再从中选择增益率最高的属性）</li></ul></blockquote><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>根据<strong>信息熵</strong>(entropy) or <strong>基尼系数</strong>(gini)的大小决定下一个节点怎么分枝，最后生成决策树，而<strong>随机森林</strong>就是多个决策树的组合</p><h2 id="信息熵entropy"><a href="#信息熵entropy" class="headerlink" title="信息熵entropy"></a>信息熵entropy</h2><p><a href="https://www.zhihu.com/search?q=yjango%E4%BF%A1%E6%81%AF%E7%86%B5&utm_content=search_suggestion&type=content">超链接：Yjango:什么是信息熵？</a></p><p><em>熵在信息论中代表随机变量的不确定性的度量</em></p><p>熵越小，数据不确定性越低<br>熵越大，数据不确定性越高</p><p>信息熵<br>H=$-\displaystyle \sum^{k}_{i = 1}{Pi}$${log_2{(Pi)}}$</p><h2 id="基尼系数"><a href="#基尼系数" class="headerlink" title="基尼系数"></a>基尼系数</h2><ul><li>基尼值<br>G = 1 $-\displaystyle \sum^{k}_{i = 1}{Pi^2}$</li></ul><p>以基尼指数为指标时，应该选择Gini指数最<strong>小</strong>的</p><p>CART决策树使用“基尼指数”来选择划分属性</p><ul><li>  基尼指数<br>G_index = $-\displaystyle \sum^{V}_{v = 1}{\frac{|D^v|}{|D|}Gini(D^v)}$</li></ul><p><strong>基尼指数到0时，即到叶节点，不能再往下划分</strong></p><h2 id="AUC-ROC-tpr-fpr"><a href="#AUC-ROC-tpr-fpr" class="headerlink" title="AUC ROC tpr fpr"></a>AUC ROC tpr fpr</h2><ul><li>tpr：Recall，召回率，即当前被分到正样本类别中，真实的正样本占所有正样本的比例，即召回率（召回了多少正样本比例）</li><li>fpr：Precision，正例率，即当前划分到正样本类别中，被正确分类的比例（即正式正样本所占比例），就是我们一般理解意义上所关心的正样本的分类准确率；</li><li>ROC：tpr和fpr决定的曲线</li><li>AUC：ROC曲线下包围的面积，最大值为1，越大拟合性能越好</li></ul><h2 id="过拟合的原因及如何防止"><a href="#过拟合的原因及如何防止" class="headerlink" title="过拟合的原因及如何防止"></a>过拟合的原因及如何防止</h2><p>对于过拟合现象产生的原因，有以下几个方面，</p><blockquote><ul><li>第一：在决策树构建的过程中，对决策树的生长没有进行合理的限制（<strong>剪枝</strong>）；</li><li>第二：在建模过程中使用了<strong>较多的输出变量</strong>，变量较多也容易产生过拟合；</li><li>第三：样本中有一些<strong>噪声数据</strong>，噪声数据对决策树的构建的干扰很多，没有对噪声数据进行有效的剔除。</li></ul></blockquote><p>对于过拟合现象的预防措施，有以下一些方法，</p><blockquote><ul><li>第一：选择合理的参数进行<strong>剪枝</strong>，可以分为预剪枝后剪枝，我们一般用后剪枝的方法来做；</li><li>第二：<strong>K-folds交叉验证</strong>，将训练集分为K份，然后进行K次的交叉验证，每次使用K-1份作为训练样本数据集，另外的一份作为测试集合（作者说反了，应该是份作为测试集，其余k-1份作为训练集）；</li><li>第三：减少特征，计算每一个特征和相应变量的<strong>相关性</strong>，常见的为皮尔逊相关系数，将相关性较小的变量剔除，当然还有一些其他的方法来进行特征筛选，比如基于决策树的特征筛选，通过正则化的方式来进行特征选取等。</li></ul></blockquote><h2 id="预剪枝：生成决策树的过程中剪枝"><a href="#预剪枝：生成决策树的过程中剪枝" class="headerlink" title="预剪枝：生成决策树的过程中剪枝"></a>预剪枝：生成决策树的过程中剪枝</h2><pre><code>基于“贪心”本质，能剪则剪。</code></pre><p>如果某个分支的存在并没有提高准确率，or降低了准确率，则剪掉</p><blockquote><p>降低了过拟合风险；<br><br>显著减少了决策树训练时间；<br><br>但带来了欠拟合的风险</p></blockquote><h2 id="后剪枝：生成决策树之后剪枝"><a href="#后剪枝：生成决策树之后剪枝" class="headerlink" title="后剪枝：生成决策树之后剪枝"></a>后剪枝：生成决策树之后剪枝</h2><pre><code>能不剪，则不剪，剪前后若准确率相等，则保留</code></pre><blockquote><p>同样的训练模型，后剪枝的决策树保留了更多的分支<br><br>后剪枝的欠拟合风险很小<br><br>泛化性能往往优于预剪枝(分的更细，在面对陌生数据时判断更准确)<br><br>训练时间长的多(生成决策树之后需要自底向上逐一考察，计算开销大)<br></p></blockquote><pre><code>“在有噪声的情况下，剪枝操作甚至能将泛化性能提高25%”</code></pre><h2 id="连续值：可取连续值的属性"><a href="#连续值：可取连续值的属性" class="headerlink" title="连续值：可取连续值的属性"></a>连续值：可取连续值的属性</h2><p>例如：脐部{凹陷，平坦，稍凹}这种是离散值；而密度，xx含量等很多属性值都是连续的</p><p>因此在划分分支的时候，需要有一个间断点</p><p>间断点的划分方法：二分法，例如有17个排序后的点集，两两之间算中位数，一共算16次，生成16个t值，组成一个t的集合T，用T中的划分点代入Gain算法，计算Gain(D，该属性，t为划分点)，取Gain最大值，对应的t即为最终确定的划分点<br>划分完t之后，如果子分支还需用到更细的判断， 可以使用t的子集：例如：一个节点判断“密度&lt;=0.381”那么后续的子节点可以使用任何”密度&lt;0.381”范围的判断依据</p><h2 id="缺失值：某些数据的其中某个数据缺失，若全部弃用则会很浪费"><a href="#缺失值：某些数据的其中某个数据缺失，若全部弃用则会很浪费" class="headerlink" title="缺失值：某些数据的其中某个数据缺失，若全部弃用则会很浪费"></a>缺失值：某些数据的其中某个数据缺失，若全部弃用则会很浪费</h2><p>属性a缺失值处理方法：</p><p>西瓜书上p88：跳过该属性a的判断，直接判断下一节点的所有可能性，但需要加上训练集中的比例权重</p><pre><code>(离散值)：众数填充、相关性最高的列(属性b总是与属性a的取值几乎一一对应)填充(连续值)：中位数、相关性最高的列(同上)做线性回归估计</code></pre><h2 id="多变量决策树：用线性关系替代多个变量"><a href="#多变量决策树：用线性关系替代多个变量" class="headerlink" title="多变量决策树：用线性关系替代多个变量"></a>多变量决策树：用线性关系替代多个变量</h2><p>有些属性之间有一定的线性关系，例如：密度和含糖量之间存在着线性关系，那么就把密度和含糖量分别乘上各自的权重系数，用他俩组成的一个式子&lt;=t 或 &gt;=t 作为分界点来判断</p><pre><code>多变量决策树算法：贪心寻找每个属性的最优权值，线性分类器的最小二乘法</code></pre><h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>擅长于解决数据不平衡的分类</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1，导包"><a href="#1，导包" class="headerlink" title="1，导包"></a>1，导包</h3><pre><code>import pandas as pdimport numpy as np</code></pre><h3 id="2，读取、初步查看分析数据"><a href="#2，读取、初步查看分析数据" class="headerlink" title="2，读取、初步查看分析数据"></a>2，读取、初步查看分析数据</h3><pre><code>df = pd.read_csv(&#39;broadband.csv&#39;)df.rename(str.lower, axis=&#39;columns&#39;, inplace=True)#列名全换小写，方便看print(df.head())#空参则显示前5行数据# broadband 即可：0-离开(否)，1-留存(是)df.info() #输出行列信息（总体数据特征）print(df.sample()) # 随机查看一个样本数据# 查看因变量 broadband 分布情况，看是否存在不平衡from collections import Counterprint(&#39;Broadband: &#39;, Counter(df[&#39;broadband&#39;]))     #输出结果是Broadband:  Counter(&#123;0: 131, 1: 49&#125;)，数据并不平衡</code></pre><p><img src="https://img-blog.csdnimg.cn/6a2b7fea48b04223b402fb145f80d793.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="前5行信息and随机查看样本数据"></p><p><img src="https://img-blog.csdnimg.cn/30820d3df1b24efb98664f1347d2109d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_19,color_FFFFFF,t_70,g_se,x_16" alt="info输出信息"></p><h3 id="3，划分训练集-测试集"><a href="#3，划分训练集-测试集" class="headerlink" title="3，划分训练集 测试集"></a>3，划分训练集 测试集</h3><p>由于步骤2中info()发现数据集的第一列是用户ID，最后一列是判断标准Broadband，故这两列都不用做数据分析</p><pre><code>y = df[&#39;broadband&#39;] # y就是标签(结果)X = df.iloc[:, 1:-1] # 客户 id 没有用，故丢弃 cust_id；标签y也要去掉，故1：-1#左边冒号左右端为空，表示所有行数据全部都取到X中from sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4, random_state=123)#40%划分为test集，# 这里的random_state就是为了保证程序每次运行都分割一样的训练集和测试集。# 否则，同样的算法模型在不同的训练集和测试集上的效果不一样。# 因此具体取值多少无所谓，但对结果有影响</code></pre><h3 id="4，决策树建模"><a href="#4，决策树建模" class="headerlink" title="4，决策树建模"></a>4，决策树建模</h3><h4 id="网格搜索："><a href="#网格搜索：" class="headerlink" title="网格搜索："></a>网格搜索：</h4><p>因为决策树算法是非参数学习算法，需要自行调参，利用网格搜索则可以自动调参，择优选取<br><br>把自己认为好的参数都扔进去，让网格搜索自己跑</p><pre><code>import sklearn.tree as tree# 1. 直接使用交叉网格搜索来优化决策树模型，边训练边优化from sklearn.model_selection import GridSearchCV# 2. 网格搜索参数，选择最优参数,该param_grid作为评价指标用于下面的训练模型param_grid = &#123;&#39;criterion&#39;: [&#39;entropy&#39;, &#39;gini&#39;], # 树的深度评估指标,信息熵or基尼            &#39;max_depth&#39;: [2, 3, 4, 5, 6, 7, 8], # 可选树的深度            &#39;min_samples_split&#39;: [4, 8, 12, 16, 20, 24, 28]&#125; # 可选最小拆分的叶子样本数</code></pre><h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><pre><code># 3. 定义一棵树对象clf = tree.DecisionTreeClassifier()  # 4. 传入模型，网格搜索的参数，评估指标，cv交叉验证的次数clfcv = GridSearchCV(estimator=clf, param_grid=param_grid, scoring=&#39;roc_auc&#39;,cv=4) # roc曲线和auc面积值作为评价标准（一般都用auc直接比较面积）# cv=？表示交叉验证的次数# 5. 训练模型clfcv.fit(X_train, y_train)# 6. 使用模型来对测试集进行预测test_result = clfcv.predict(X_test)</code></pre><h4 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h4><pre><code># 7. 模型评估import sklearn.metrics as metricsprint(&quot;决策树 AUC:&quot;)fpr_test, tpr_test, th_test = metrics.roc_curve(y_test, test_result)#主要是为了得到fpr，tpr，代入AUC计算公式print(&#39;AUC = %.4f&#39; %metrics.auc(fpr_test, tpr_test))#输出AUC的值print(&quot;决策树准确度:&quot;)print(metrics.classification_report(y_test,test_result))#输出准确度表格，参考价值不是很大，一般还是以AUC为准# 9. 求网格搜索后的最优参数print(clfcv.best_params_)#输出最优参数组合，但这个最优并非完全最优，可能还需要在开始的地方再重新调参，可能#算出的最后参数结果还不同#假设“最小样本设置&#123;4，5，6，7，8&#125;”，而最优结果是4 或 8，处于边缘，#就需要往边缘调参#因为该样本结果是：#&#123;&#39;criterion&#39;: &#39;entropy&#39;, &#39;max_depth&#39;: 3, &#39;min_samples_split&#39;: 12&#125;#都不是设置的边缘只，所以可以认为这些参数还不错，暂时不调参</code></pre><p><img src="https://img-blog.csdnimg.cn/16e8639fe87447e1b9f205219401708c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="决策树AUC" title="决策树AUC"></p><h3 id="5，决策树生成"><a href="#5，决策树生成" class="headerlink" title="5，决策树生成"></a>5，决策树生成</h3><h4 id="选择最优参数重新训练"><a href="#选择最优参数重新训练" class="headerlink" title="选择最优参数重新训练"></a>选择最优参数重新训练</h4><pre><code># 将最优参数代入到模型中，重新训练、预测#&#123;&#39;criterion&#39;: &#39;entropy&#39;, &#39;max_depth&#39;: 3, &#39;min_samples_split&#39;: 12&#125;clf2 = tree.DecisionTreeClassifier(criterion=&#39;entropy&#39;, max_depth=3, min_samples_split=12)clf2.fit(X_train, y_train)test_res2 = clf2.predict(X_test)</code></pre><h4 id="绘制决策树，在同目录下生成pdf"><a href="#绘制决策树，在同目录下生成pdf" class="headerlink" title="绘制决策树，在同目录下生成pdf"></a>绘制决策树，在同目录下生成pdf</h4><pre><code>#  绘制图形 pip3 install graphvizimport graphvizdot_data = tree.export_graphviz(clf2, out_file=None)graph = graphviz.Source(dot_data)graph.render(&#39;决策树&#39;)#生成文件名为决策树的pdf图片</code></pre><p><img src="https://img-blog.csdnimg.cn/bac26eaf8ba04751a8308ddf86301246.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="决策树生成" title="决策树生成"></p><h2 id="随机森林-1"><a href="#随机森林-1" class="headerlink" title="随机森林"></a>随机森林</h2><p>由于上述决策树生成的AUC值还不到0.7，认为拟合效果不够好，因此尝试使用随机森林算法</p><h3 id="1-网格搜索"><a href="#1-网格搜索" class="headerlink" title="1,网格搜索"></a>1,网格搜索</h3><pre><code>param_grid = &#123;    &#39;criterion&#39;:[&#39;entropy&#39;,&#39;gini&#39;],# 衡量标准    &#39;max_depth&#39;:[5, 6, 7, 8],    # 每棵决策树的深度    &#39;n_estimators&#39;:[11,13,15],  # 决策树个数 - 随机森林特有参数    &#39;max_features&#39;:[0.3,0.4,0.5], # 每棵决策树使用的变量占比 - 随机森林特有参数    &#39;min_samples_split&#39;:[4,8,12,16]  # 叶子的最小拆分样本量&#125;</code></pre><h3 id="2-集成学习：随机森林训练"><a href="#2-集成学习：随机森林训练" class="headerlink" title="2,集成学习：随机森林训练"></a>2,集成学习：随机森林训练</h3><pre><code>import sklearn.ensemble as ensemble # ensemble learning: 集成学习rfc = ensemble.RandomForestClassifier()rfc_cv = GridSearchCV(estimator=rfc, param_grid=param_grid,                    scoring=&#39;roc_auc&#39;, cv=4)rfc_cv.fit(X_train, y_train)</code></pre><h3 id="3-使用随机森林对结果预测，并求AUC（一般都高于决策树）"><a href="#3-使用随机森林对结果预测，并求AUC（一般都高于决策树）" class="headerlink" title="3,使用随机森林对结果预测，并求AUC（一般都高于决策树）"></a>3,使用随机森林对结果预测，并求AUC（一般都高于决策树）</h3><pre><code>predict_test = rfc_cv.predict(X_test)#训练，预测结束之后，方可查看最佳参数配置print(rfc_cv.best_params_)#输出AUC和精度表格print(&#39;随机森林 AUC...&#39;)fpr_test, tpr_test, th_test = metrics.roc_curve(predict_test, y_test) # 构造 roc 曲线print(&#39;AUC = %.4f&#39; %metrics.auc(fpr_test, tpr_test))print(&#39;随机森林精确度...&#39;)print(metrics.classification_report(predict_test, y_test))</code></pre><p><img src="https://img-blog.csdnimg.cn/f0a64f28f5004c82bc2914efde97415c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="随机森林AUC结果"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>调参的思想类似于高中生物实验探究题中的 <strong>“寻找最佳浓度”</strong></p><p>衡量决策树 or 随机森林 <strong>模型好坏的标准一般用AUC的值来判断</strong></p><p><strong>非参数学习一般都用网格搜索</strong><br><br>例如在进行网格搜索时，有很多参数，哪怕最优结果表明只需要调整一个参数，调整之后其他最优结果可能也会改变（牵一发动全身）<br><em>当然，如果电脑性能足够好，可以直接放很多参数去跑，省去了大量的调参花费的精力</em></p><p><strong>网格搜索的参数范围一开始要间隔比较大才好</strong></p><p>其他参数相同时，同一个 random_state=？保证了算出来的结果相同</p><h1 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h1><h2 id="树模型的参数"><a href="#树模型的参数" class="headerlink" title="树模型的参数"></a>树模型的参数</h2><pre><code># # -  1.criterion  gini  or  entropy# # -  2.splitter  best or random 前者是在所有特征中找最好的切分点 后者是在部分特征中（数据量大的时候）# # -  3.max_features  None（所有），log2，sqrt，N  特征小于50的时候一般使用所有的# # -  4.max_depth  数据少或者特征少的时候可以不管这个值，如果模型样本量多，特征也多的情况下，可以尝试限制下# # -  5.min_samples_split  如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。# # -  6.min_samples_leaf  这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝，如果样本量不大，不需要管这个值，大些如10W可是尝试下5# # -  7.min_weight_fraction_leaf 这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。# # -  8.max_leaf_nodes 通过限制最大叶子节点数，可以防止过拟合，默认是&quot;None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制具体的值可以通过交叉验证得到。# # -  9.class_weight 指定样本各类别的的权重，主要是为了防止训练集某些类别的样本过多导致训练的决策树过于偏向这些类别。这里可以自己指定各个样本的权重如果使用“balanced”，则算法会自己计算权重，样本量少的类别所对应的样本权重会高。# # - 10.min_impurity_split 这个值限制了决策树的增长，如果某节点的不纯度(基尼系数，信息增益，均方差，绝对差)小于这个阈值则该节点不再生成子节点。即为叶子节点 。# - n_estimators:要建立树的个数</code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA常用快捷键</title>
      <link href="/zjh/2021/12/25/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/zjh/2021/12/25/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>摘自： <a href="https://blog.csdn.net/cold___play/article/details/100178346?ops_request_misc=&request_id=&biz_id=102&utm_term=idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100178346.nonecase&spm=1018.2226.3001.4187" title="来自：CSDN"> IDEA常用命令 ,侵删</a></p><h3 id="1-自动代码"><a href="#1-自动代码" class="headerlink" title="1. 自动代码"></a>1. 自动代码</h3><p>常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。<br>例如要输入for(User user : users)只需输入user.for+Tab。</p><p>再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。代码标签输入完成后，按Tab，生成代码。</p><table><thead><tr><th align="center">快捷键</th><th align="center">指令</th></tr></thead><tbody><tr><td align="center">Ctrl+Alt+O</td><td align="center">优化导入的类和包</td></tr><tr><td align="center">Alt+Insert</td><td align="center">生成代码(如get,set方法,构造函数等) 或者右键（Generate）</td></tr><tr><td align="center">Ctrl+Alt+T</td><td align="center">生成try catch 或者 Alt+enter</td></tr><tr><td align="center">CTRL+ALT+T</td><td align="center">把选中的代码放在 TRY{} IF{} ELSE{} 里</td></tr><tr><td align="center">Ctrl + O</td><td align="center">重写方法</td></tr><tr><td align="center">Ctrl + I</td><td align="center">实现方法</td></tr><tr><td align="center">Ctr+shift+U</td><td align="center">大小写转化</td></tr><tr><td align="center">ALT+回车</td><td align="center">导入包,自动修正</td></tr><tr><td align="center">ALT+/</td><td align="center">代码提示</td></tr><tr><td align="center">CTRL+J</td><td align="center">自动代码</td></tr><tr><td align="center">Ctrl+Shift+J</td><td align="center">整合两行为一行</td></tr><tr><td align="center">CTRL+空格</td><td align="center">代码提示</td></tr><tr><td align="center">CTRL+SHIFT+SPACE</td><td align="center">自动补全代码</td></tr><tr><td align="center">CTRL+ALT+L</td><td align="center">格式化代码</td></tr><tr><td align="center">CTRL+ALT+I</td><td align="center">自动缩进</td></tr><tr><td align="center">CTRL+ALT+O</td><td align="center">优化导入的类和包</td></tr><tr><td align="center">ALT+INSERT</td><td align="center">生成代码(如GET,SET方法,构造函数等)</td></tr><tr><td align="center">CTRL+E</td><td align="center">最近更改的代码</td></tr><tr><td align="center">CTRL+ALT+SPACE</td><td align="center">类名或接口名提示</td></tr><tr><td align="center">CTRL+P</td><td align="center">方法参数提示</td></tr><tr><td align="center">CTRL+Q</td><td align="center">可以看到当前方法的声明</td></tr><tr><td align="center">Shift+F6</td><td align="center">重构-重命名 (包、类、方法、变量、甚至注释等)</td></tr><tr><td align="center">Ctrl+Alt+V</td><td align="center">提取变量</td></tr></tbody></table><h3 id="2-查询快捷键"><a href="#2-查询快捷键" class="headerlink" title="2. 查询快捷键"></a>2. 查询快捷键</h3><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Ctrl＋Shift＋Backspace</td><td align="center">可以跳转到上次编辑的地</td></tr><tr><td align="center">CTRL+ALT+ left/right</td><td align="center">前后导航编辑过的地方</td></tr><tr><td align="center">ALT+7</td><td align="center">靠左窗口显示当前文件的结构</td></tr><tr><td align="center">Ctrl+F12</td><td align="center">浮动显示当前文件的结构</td></tr><tr><td align="center">ALT+F7</td><td align="center">找到你的函数或者变量或者类的所有引用到的地方</td></tr><tr><td align="center">CTRL+ALT+F7</td><td align="center">找到你的函数或者变量或者类的所有引用到的地方</td></tr><tr><td align="center">Ctrl+Shift+Alt+N</td><td align="center">查找类中的方法或变量</td></tr><tr><td align="center">双击SHIFT</td><td align="center">在项目的所有目录查找文件</td></tr><tr><td align="center">Ctrl+N</td><td align="center">查找类</td></tr><tr><td align="center">Ctrl+Shift+N</td><td align="center">查找文件</td></tr><tr><td align="center">CTRL+G</td><td align="center">定位行</td></tr><tr><td align="center">CTRL+F</td><td align="center">在当前窗口查找文本</td></tr><tr><td align="center">CTRL+SHIFT+F</td><td align="center">在指定窗口查找文本</td></tr><tr><td align="center">CTRL+R</td><td align="center">在当前窗口替换文本</td></tr><tr><td align="center">CTRL+SHIFT+R</td><td align="center">在指定窗口替换文本</td></tr><tr><td align="center">ALT+SHIFT+C</td><td align="center">查找修改的文件</td></tr><tr><td align="center">CTRL+E</td><td align="center">最近打开的文件</td></tr><tr><td align="center">F3</td><td align="center">向下查找关键字出现位置</td></tr><tr><td align="center">SHIFT+F3</td><td align="center">向上一个关键字出现位置</td></tr><tr><td align="center">选中文本，按Alt+F3</td><td align="center">高亮相同文本，F3逐个往下查找相同文本</td></tr><tr><td align="center">F4</td><td align="center">查找变量来源</td></tr><tr><td align="center">CTRL+SHIFT+O</td><td align="center">弹出显示查找内容</td></tr><tr><td align="center">Ctrl+W</td><td align="center">选中代码，连续按会有其他效果</td></tr><tr><td align="center">F2 或Shift+F2</td><td align="center">高亮错误或警告快速定位</td></tr><tr><td align="center">Ctrl+Up/Down</td><td align="center">光标跳转到第一行或最后一行下</td></tr><tr><td align="center">Ctrl+B</td><td align="center">快速打开光标处的类或方法</td></tr><tr><td align="center">CTRL+ALT+B</td><td align="center">找所有的子类</td></tr><tr><td align="center">CTRL+SHIFT+B</td><td align="center">找变量的类</td></tr><tr><td align="center">Ctrl+Shift+上下键</td><td align="center">上下移动代码</td></tr><tr><td align="center">Ctrl+Alt+ left/right</td><td align="center">返回至上次浏览的位置</td></tr><tr><td align="center">Ctrl+X</td><td align="center">删除行</td></tr><tr><td align="center">Ctrl+D</td><td align="center">复制行</td></tr><tr><td align="center">Ctrl+/ 或 Ctrl+Shift+/</td><td align="center">注释（// 或者/…/ ）</td></tr><tr><td align="center">Ctrl+H</td><td align="center">显示类结构图</td></tr><tr><td align="center">Ctrl+Q</td><td align="center">显示注释文档</td></tr><tr><td align="center">Alt+F1</td><td align="center">查找代码所在位置</td></tr><tr><td align="center">Alt+1</td><td align="center">快速打开或隐藏工程面板</td></tr><tr><td align="center">Alt+ left/right</td><td align="center">切换代码视图</td></tr><tr><td align="center">ALT+ ↑/↓</td><td align="center">在方法间快速移动定位</td></tr><tr><td align="center">CTRL+ALT+ left/right</td><td align="center">前后导航编辑过的地方</td></tr><tr><td align="center">Ctrl＋Shift＋Backspace</td><td align="center">可以跳转到上次编辑的地</td></tr><tr><td align="center">Alt+6</td><td align="center">查找TODO</td></tr></tbody></table><h3 id="3-其它快捷键"><a href="#3-其它快捷键" class="headerlink" title="3. 其它快捷键"></a>3. 其它快捷键</h3><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SHIFT+ENTER</td><td align="center">另起一行</td></tr><tr><td align="center">CTRL+Z</td><td align="center">倒退(撤销)</td></tr><tr><td align="center">CTRL+SHIFT+Z</td><td align="center">向前(取消撤销)</td></tr><tr><td align="center">CTRL+ALT+F12</td><td align="center">资源管理器打开文件夹</td></tr><tr><td align="center">ALT+F1</td><td align="center">查找文件所在目录位置</td></tr><tr><td align="center">SHIFT+ALT+INSERT</td><td align="center">竖编辑模式</td></tr><tr><td align="center">CTRL+F4</td><td align="center">关闭当前窗口</td></tr><tr><td align="center">Ctrl+Alt+V</td><td align="center">可以引入变量。例如：new String(); 自动导入变量定义</td></tr><tr><td align="center">Ctrl+~</td><td align="center">快速切换方案（界面外观、代码风格、快捷键映射等菜单）</td></tr></tbody></table><h3 id="4-svn快捷键"><a href="#4-svn快捷键" class="headerlink" title="4. svn快捷键"></a>4. svn快捷键</h3><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ctrl+k</td><td align="center">提交代码到SVN</td></tr><tr><td align="center">ctrl+t</td><td align="center">更新代码</td></tr></tbody></table><h3 id="5-调试快捷键"><a href="#5-调试快捷键" class="headerlink" title="5. 调试快捷键"></a>5. 调试快捷键</h3><p>其实常用的 就是F8 F7 F9 最值得一提的 就是Drop Frame 可以让运行过的代码从头再来</p><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">alt+F8</td><td align="center">debug时选中查看值</td></tr><tr><td align="center">Alt+Shift+F9</td><td align="center">选择 Debug</td></tr><tr><td align="center">Alt+Shift+F10</td><td align="center">选择 Run</td></tr><tr><td align="center">Ctrl+Shift+F9</td><td align="center">编译</td></tr><tr><td align="center">Ctrl+Shift+F8</td><td align="center">查看断点</td></tr><tr><td align="center">F7</td><td align="center">步入</td></tr><tr><td align="center">Shift+F7</td><td align="center">智能步入</td></tr><tr><td align="center">Alt+Shift+F7</td><td align="center">强制步入</td></tr><tr><td align="center">F8</td><td align="center">步过</td></tr><tr><td align="center">Shift+F8</td><td align="center">步出</td></tr><tr><td align="center">Alt+Shift+F8</td><td align="center">强制步过</td></tr><tr><td align="center">Alt+F9</td><td align="center">运行至光标处</td></tr><tr><td align="center">Ctrl+Alt+F9</td><td align="center">强制运行至光标处</td></tr><tr><td align="center">F9</td><td align="center">恢复程序</td></tr><tr><td align="center">Alt+F10</td><td align="center">定位到断点</td></tr></tbody></table><h3 id="6-重构"><a href="#6-重构" class="headerlink" title="6. 重构"></a>6. 重构</h3><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Ctrl+Alt+Shift+T</td><td align="center">弹出重构菜单</td></tr><tr><td align="center">Shift+F6</td><td align="center">重命名</td></tr><tr><td align="center">F6</td><td align="center">移动</td></tr><tr><td align="center">F5</td><td align="center">复制</td></tr><tr><td align="center">Alt+Delete</td><td align="center">安全删除</td></tr><tr><td align="center">Ctrl+Alt+N</td><td align="center">内联</td></tr></tbody></table><h1 id="十大IntelliJ-IDEA快捷键"><a href="#十大IntelliJ-IDEA快捷键" class="headerlink" title="十大IntelliJ IDEA快捷键"></a>十大IntelliJ IDEA快捷键</h1><p>Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。<br>以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。</p><h3 id="智能提示："><a href="#智能提示：" class="headerlink" title="智能提示："></a>智能提示：</h3><p>Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。<br>最后要说一点，Intellij能够智能感知Spring、Hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。</p><h3 id="重构："><a href="#重构：" class="headerlink" title="重构："></a>重构：</h3><p>Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。<br>切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。</p><h3 id="代码生成："><a href="#代码生成：" class="headerlink" title="代码生成："></a>代码生成：</h3><p>这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。<br>另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。</p><h3 id="编辑："><a href="#编辑：" class="headerlink" title="编辑："></a>编辑：</h3><p>编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+&lt;/&gt;折叠代码就不多说了。<br>关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。</p><h3 id="查找打开："><a href="#查找打开：" class="headerlink" title="查找打开："></a>查找打开：</h3><p>类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。<br>类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。<br>要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。<br>Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。</p><h3 id="其他辅助："><a href="#其他辅助：" class="headerlink" title="其他辅助："></a>其他辅助：</h3><p>以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：</p><ul><li>命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。</li><li>新建：Alt+Insert可以新建类、方法等任何东西。</li><li>格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。</li><li>切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。</li><li>单元测试：Ctrl+Alt+T创建单元测试用例。</li><li>运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。</li><li>调试：F7/F8/F9分别对应Step into，Step over，Continue。</li></ul><p>此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。</p><ul><li>Top #10切来切去：Ctrl+Tab</li><li>Top #9选你所想：Ctrl+W</li><li>Top #8代码生成：Template/Postfix +Tab</li><li>Top #7发号施令：Ctrl+Shift+A</li><li>Top #6无处藏身：Shift+Shift</li><li>Top #5自动完成：Ctrl+Shift+Enter</li><li>Top #4创造万物：Alt+Insert</li><li>Top #1智能补全：Ctrl+Shift+Space</li><li>Top #1自我修复：Alt+Enter</li><li>Top #1重构一切：Ctrl+Shift+Alt+T</li></ul><p>CTRL+ALT+ left/right 前后导航编辑过的地方。<br>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回形针数字矩阵Java实现</title>
      <link href="/zjh/2021/12/25/%E5%9B%9E%E5%BD%A2%E9%92%88%E6%95%B0%E5%AD%97%E7%9F%A9%E9%98%B5Java%E5%AE%9E%E7%8E%B0/"/>
      <url>/zjh/2021/12/25/%E5%9B%9E%E5%BD%A2%E9%92%88%E6%95%B0%E5%AD%97%E7%9F%A9%E9%98%B5Java%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210726004539592.png"><br>我们发现这个回形数矩阵的逻辑是：→↓←↑四个为一个循环，故考虑框架为：一个外层for里面嵌套4个内层for</p><p>每个内层for的起点终点都随着外层的变化而变化</p><p>说实话这种问题只可意会不可言传，光看源码没什么用，你得逼着自己去思考，哪怕是一个下午，一天才做出来也比你直接看源码好啊<del>使劲想想现实逻辑怎么转化为for循环逻辑，一般看到那个→↓←↑就会感觉这四个地位等价，就尝试着把这四个for放到一个外层大for里面，一点一点试出来</del></p><pre><code>import java.util.Scanner;public class Test1 &#123;    public static void main(String[] args) &#123;        Scanner scan = new Scanner(System.in);        System.out.println(&quot;输入一个数，返回回形数矩阵&quot;);        int i = scan.nextInt();        // 键盘输入一个数        int[][] arr = new int[i][i];        int m = 1;//用于赋值        /*思考循环数的逻辑顺序，→↓←↑四个为一个循环，故考虑框架为一个外层for里面套4个内层for*/        /*每一个循环的→↓←↑内层for循环，其起点和终点都不断改变，所以起点终点必须表现出来这个联系，绝不能为常数*/        for (int j = 0; j &lt; i; j++) &#123;             for (int k = j; k &lt; i - j; k++) &#123;//k=j和k&lt;i-j都在不断的改变                        arr[j][k] = m;                m++;            &#125;             for (int l = j + 1; l &lt; i - j; l++) &#123;                arr[l][i - j - 1] = m;                m++;            &#125;            for (int p = i - j - 2; p &gt; j - 1; p--) &#123;                arr[i - j - 1][p] = m;                m++;            &#125;            for (int q = i - j - 2; q &gt; j; q--) &#123;                arr[q][j] = m;                m++;            &#125;        &#125;        // 输出矩阵        for (int a = 0; a &lt; arr.length; a++) &#123;            for (int b = 0; b &lt; arr[a].length; b++) &#123;                System.out.print(arr[a][b] + &quot;\t&quot;);             &#125;            System.out.println();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java四种next用法</title>
      <link href="/zjh/2021/12/25/Java%E5%9B%9B%E7%A7%8Dnext%E7%94%A8%E6%B3%95/"/>
      <url>/zjh/2021/12/25/Java%E5%9B%9B%E7%A7%8Dnext%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在查阅了大量网上相关资料都没有一个完整的解释，并且我查的几篇高赞回答都是错误的时候，我决定用一整天的时间来精细写下这篇文章，希望对你有帮助。</p><pre><code>大多数人对hasNext的印象停留在“判断是否有下一个值”上，而该方法还是一个阻塞式的方法</code></pre><h1 id="hasNext和hasNextLine的区别"><a href="#hasNext和hasNextLine的区别" class="headerlink" title="hasNext和hasNextLine的区别"></a>hasNext和hasNextLine的区别</h1><p>二者都是用于判断“有无键盘输入”的，有则返回true，没有则阻塞！一定记住是阻塞而不是返回false，很多人都说是返回false，但你查源码会发现是不会返回false的，他会让你一直阻塞在判断阶段，二者只是在细节上有不同</p><pre><code>hasNext()方法会判断接下来是否有非空字符.如果有,则返回true，没有则阻塞。例如一直敲回车相当于一直判断为空字符，但是不会返回false，而是一直阻塞在判断阶段，直到你输入了非空字符hasNextLine() 方法会根据行匹配模式去判断接下来是否有一行(包括空行),如果有,则返回true。这个没什么特别的，只要是你敲了回车那都是true并且不会阻塞</code></pre><p>例如像这种if语句是永远不可能执行到内部方法体的</p><pre><code>if(scan.hasNext()==false)&#123;    System.out.println(&quot;hasNext和hasNextLine不会返回false&quot;);&#125;</code></pre><p> 再举一个例子加深理解：</p><pre><code>Scanner scan = new Scanner(System.in);System.out.println(scan.hasNextLine());System.out.println(scan.hasNext());</code></pre><p> 运行该代码，一直不停敲回车键，第一次回车会直接输出true，而后面一直敲都会阻塞在hasNext语句上，运行如下图</p><p><img src="https://img-blog.csdnimg.cn/20211001130739982.png"></p><p>首先，在看用法和解释之前，有以下几个点必须时刻牢记</p><blockquote><p>next方法不能录入空格，在特定情况下会把空格当作回车，nextLine方法可以识录入空格<br>hasNext和hasNextLine的返回值都是boolean类型，但只有可能返回true，不可能返回false，并且都默认以回车键为结束（hasNext可以设置为任意符号为结束键，不在本文研究范围之内）<br>hasNext、next不能直接识别裸回车，而hasNextLine和nextLine都可以直接识别裸回车。换句话讲：对于不输入符号而直接裸敲一个回车的操作，只有后两个能识别<br>hasNext、hasNextLine在返回一个boolean类型结果true的同时，会在堆空间中开辟一块专门用于存放刚刚输入的字符串，用于下次next或者nextLine：即下次next或者nextLine不需要再从键盘输入，相当于系统自动把刚刚输入的字符串再原封不动的输入了一遍。同时这个存储寿命＝调用对象的寿命<br>对于hasNext来说，每次敲击回车都相当于在堆空间中开辟一行，敲几次回车就会直接给后续next、nextLine方法赋值几次<br>hasNext是线程阻塞的，对于hasNext来说，如果一直不输入字符，反而一直敲回车的话，整个线程会卡在这个输入的地方，直到有字符输入</p></blockquote><p>在知道 hasNext的方法用于判断和存储，next的方法用于输入之后，来做如下预备工作</p><blockquote><p>因为hasNext、hasNextLine与next、nextLine有2X2种组合方式，所以我们用4段代码做4次实验就可以大体上了解他们的特性</p></blockquote><p>以下4段代码希望看客们能亲自复制粘贴了试一试，以便更深理解</p><h2 id="hasNext-和-next组合"><a href="#hasNext-和-next组合" class="headerlink" title="hasNext 和 next组合"></a>hasNext 和 next组合</h2><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNext() ) &#123;    System.out.println(&quot;第一次&quot;+scan.next());    System.out.println(&quot;第二次&quot;+scan.next());    System.out.println(&quot;第三次&quot;+scan.next());&#125;</code></pre><p>尝试输入：空格aaa空格bbb空格ccc回车<br><img src="https://img-blog.csdnimg.cn/20211001131608748.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_18,color_FFFFFF,t_70,g_se,x_16"><br>解释：<br><img src="https://img-blog.csdnimg.cn/20211001125303907.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_15,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="hasNext-和-NextLine组合"><a href="#hasNext-和-NextLine组合" class="headerlink" title="hasNext 和 NextLine组合"></a>hasNext 和 NextLine组合</h2><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNext() ) &#123;    System.out.println(&quot;第一次&quot;+scan.nextLine());    System.out.println(&quot;第二次&quot;+scan.nextLine());    System.out.println(&quot;第三次&quot;+scan.nextLine());&#125;</code></pre><p>解释：光标仍然闪烁，证明堆空间中的  aaa bbb ccc只赋值给了第一个，这也验证了nextLine可以录入空格。此时线程正在等待用户输入第二个nextLine<br>hasNextLine 和 next组合</p><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNextLine() ) &#123;    System.out.println(&quot;第一次&quot;+scan.next());    System.out.println(&quot;第二次&quot;+scan.next());    System.out.println(&quot;第三次&quot;+scan.next());&#125;</code></pre><h2 id="hasNextLine-和-nextLine组合"><a href="#hasNextLine-和-nextLine组合" class="headerlink" title="hasNextLine 和 nextLine组合"></a>hasNextLine 和 nextLine组合</h2><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNextLine() ) &#123;    System.out.println(&quot;第一次&quot;+scan.nextLine());    System.out.println(&quot;第二次&quot;+scan.nextLine());    System.out.println(&quot;第三次&quot;+scan.nextLine());&#125;</code></pre><p>发现规律了吗<br><img src="https://img-blog.csdnimg.cn/20211001132037981.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_18,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>如果直接连续敲回车，那么hasNextLine会判断为true，同时进入if语句执行，并且输入了三个空行也会输出三个空行</strong></p><p>验证hasNext、hasNextLine对输入代码的存储寿命</p><p>hasNextLine在if语句内，我们将验证语句next放在if语句之外，输入aaa bbb ccc ddd测试</p><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNextLine() ) &#123;    System.out.println(&quot;第一次&quot;+scan.next());    System.out.println(&quot;第二次&quot;+scan.next());    System.out.println(&quot;第三次&quot;+scan.next());&#125;        System.out.println(&quot;验证存储寿命是否＝scan对象寿命&quot;+scan.next());</code></pre><p> <img src="https://img-blog.csdnimg.cn/20211001132824820.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_17,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>hasNext、hasNextLine不可能返回false，只有true和阻塞两种结果</p><p>hasNext、hasNextLine会判断有无输入，并且hasNext一直敲回车而不输入字符会导致线程阻塞</p><p>hasNext、hasNextLine也有存储功能，从“开始输入”到“判断结束”的过程中的所有输入都将储存，直到之后遇到需要键盘输入的next、nextLine，这些存储的字符串和空格会自动填写给后面的next、nextLine。而空格再next和nextLine上有不同的表现</p><p>查看API还有很多同类型的不同方法，按照这个思路可以一通百通<br><img src="https://img-blog.csdnimg.cn/2021100113530823.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/20211001135328579.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RLE算法的Java实现</title>
      <link href="/zjh/2021/12/25/RLE%E7%AE%97%E6%B3%95%E7%9A%84Java%E5%AE%9E%E7%8E%B0/"/>
      <url>/zjh/2021/12/25/RLE%E7%AE%97%E6%B3%95%E7%9A%84Java%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="针对字符的RLE压缩"><a href="#针对字符的RLE压缩" class="headerlink" title="针对字符的RLE压缩"></a>针对字符的RLE压缩</h1><pre><code>1. 针对纯字符的压缩2. 不考虑两位数及以上的循环例如：用1*2#5*3#表示：11555两个1三个5，即 数*重复次数#</code></pre><p>至于为什么只考虑一位数：多位数可以用包装类Integer表示，并且实际压缩中不会单纯压缩字符，一般都是整个对象一起压缩，所以没必要两位相连的数与后面判断</p><pre><code> public static StringBuffer RLE(char...chars)&#123;//行程编码方法，形参放char型数组        //因为频繁更改字符串，所以返回值不用String        StringBuffer dest = new StringBuffer();        //注意：StringBuffer必须用new，不然不分配空间        //StringBuffer dest = null;会空指针异常        for(int i = 0 ; i&lt;chars.length-1 ; i++)&#123;//chars数组遍历——————压缩            //每次轮到chars[i],都需要用if和屁股后面紧跟的元素判断是否相等            dest.append(chars[i]);            dest.append(&#39;*&#39;);            int count = 1;//相等元素计数器            boolean bo = true;            while(bo)&#123;//while循环直到碰不到一样的元素就break                if(i&lt;chars.length-1 &amp;&amp; chars[i]==chars[i+1])&#123;//必须要避免空指针异常                    //注意：此处对i的判断必须在前，否则角标越界                    //并且要用&amp;&amp; 不能用&amp;，否则仍角标越界                    count++;                    i++;                &#125;else&#123;                    bo = false;                &#125;            &#125;            //循环结束，统计相同的个数            dest.append(count);            dest.append(&#39;#&#39;);//标识符，#之后又开始新的判断        &#125;        return dest;        &#125;//main方法中实现 String s1 = &quot;1112233334455566777778889999&quot;;        StringBuffer s2 = RLE(s1.toCharArray());        System.out.println(s2.toString());</code></pre><p>输出结果：1<em>3#2</em>2#3<em>4#4</em>2#5<em>3#6</em>2#7<em>5#8</em>3#9*4#</p><p>含义为：1出现了3次，2出现了2次……</p><h1 id="针对一维对象的RLE压缩"><a href="#针对一维对象的RLE压缩" class="headerlink" title="针对一维对象的RLE压缩"></a>针对一维对象的RLE压缩</h1><pre><code>1. 对象具有一个属性值和一个坐标值2. 不考虑独立多属性值，因为很难重复</code></pre><p> 先定义像素点：</p><pre><code>public class PixelPoint &#123;//一维像素点       private int grayScale;//灰度值    private int x;//x坐标     public PixelPoint(int grayScale,int x)&#123;        this.grayScale = grayScale;        this.x = x;    &#125;     public int getX()&#123;        return this.x;    &#125;     public int getGrayScale() &#123;        return grayScale;    &#125;&#125;</code></pre><p> 定义像素点的压缩方法：</p><pre><code>    public static LinkedHashMap&lt;PixelPoint,Integer&gt; RLE(ArrayList&lt;PixelPoint&gt; px)&#123;        //形参放入ArryaList，返回值用LinkedHashMap存储键值对，并且LinkedHashMap可以按添加顺序遍历        LinkedHashMap&lt;ZJH.HJZ.PixelPoint,Integer&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();         for(int i = 0 ; i &lt; px.size() ; )&#123;//            int j = i;            boolean bo = true;            int count = 1;//计相同个数             while(bo)&#123;                if(i&lt;px.size()-1)&#123;                    if(px.get(i).getGrayScale() == px.get(i+1).getGrayScale())&#123;                        count++;                        i++;                    &#125;else&#123;                        i++;                        bo = false;                    &#125;                    &#125; else&#123;                    bo = false;                    i++;                &#125;            &#125;                 linkedHashMap.put(px.get(j), count);            &#125;            return linkedHashMap;    &#125;</code></pre><p>载入像素点：并使用上面定义好的压缩方法，最后迭代器遍历(完整源码如下)</p><pre><code>public class RLE_complex_one &#123;//对一维像素点的RLE算法测试    public static void main(String[] args) &#123;       //此例中所有像素点x坐标连续分布，故暂不考虑排序，用ArrayList效率更高        ArrayList&lt;ZJH.HJZ.PixelPoint&gt; arrayList = new ArrayList&lt;&gt;(20);//初始容量设为20(默认是10，每次扩大1.5X)        //以下模拟像素点的连续排布及灰度值情况        arrayList.add(new PixelPoint(1,1));        arrayList.add(new PixelPoint(1,2));        arrayList.add(new PixelPoint(1,3));        arrayList.add(new PixelPoint(1,4));        arrayList.add(new PixelPoint(1,5));        arrayList.add(new PixelPoint(50,6));        arrayList.add(new PixelPoint(50,7));        arrayList.add(new PixelPoint(50,8));        arrayList.add(new PixelPoint(50,9));        arrayList.add(new PixelPoint(255,10));        arrayList.add(new PixelPoint(255,11));        arrayList.add(new PixelPoint(255,12));        arrayList.add(new PixelPoint(255,13));        arrayList.add(new PixelPoint(255,14));        arrayList.add(new PixelPoint(255,15));        arrayList.add(new PixelPoint(255,16));        arrayList.add(new PixelPoint(255,17));        arrayList.add(new PixelPoint(255,18));           LinkedHashMap&lt;ZJH.HJZ.PixelPoint, Integer&gt; rleDest = RLE(arrayList);//返回编码结果        //以下用迭代器遍历        Set&lt;Map.Entry&lt;PixelPoint, Integer&gt;&gt; entries = rleDest.entrySet();        Iterator&lt;Map.Entry&lt;PixelPoint, Integer&gt;&gt; iterator = entries.iterator();            int i = 1;        while(iterator.hasNext())&#123;            Map.Entry&lt;PixelPoint, Integer&gt; nextentries = iterator.next();            System.out.println(&quot;第&quot;+i+&quot;位压缩后的元素的灰度值是：&quot;+nextentries.getKey().getGrayScale()+&quot;，且压缩了&quot;+nextentries.getValue()+&quot;个连续的像素点&quot;);            i++;        &#125;      &#125;     public static LinkedHashMap&lt;PixelPoint,Integer&gt; RLE(ArrayList&lt;PixelPoint&gt; px)&#123;        //形参放入ArryaList，返回值用LinkedHashMap存储键值对，并且LinkedHashMap可以按添加顺序遍历        LinkedHashMap&lt;ZJH.HJZ.PixelPoint,Integer&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();         for(int i = 0 ; i &lt; px.size() ; )&#123;//            int j = i;            boolean bo = true;            int count = 1;//计相同个数             while(bo)&#123;                if(i&lt;px.size()-1)&#123;                    if(px.get(i).getGrayScale() == px.get(i+1).getGrayScale())&#123;                        count++;                        i++;                    &#125;else&#123;                        i++;                        bo = false;                    &#125;                    &#125; else&#123;                    bo = false;                    i++;                &#125;            &#125;                 linkedHashMap.put(px.get(j), count);            &#125;            return linkedHashMap;    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/a131150dbf364cc0ada38ae815633039.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown常用语法</title>
      <link href="/zjh/2021/12/24/MarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/zjh/2021/12/24/MarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h1><p>一共支持6级标题，例如二级标题用“## 标题2”</p><h2 id="标题2示例"><a href="#标题2示例" class="headerlink" title="标题2示例"></a>标题2示例</h2><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p><strong>加粗</strong>：左右各2*</p><p><em>斜体</em>：左右各1*</p><p><em><strong>加粗斜体</strong></em>：左右各3*</p><p><del>删除横杠</del>：左右各2~</p><h1 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h1><p>&lt;br/&gt;<br>中间加上这个br<br/>就能换行了</p><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>\xxxx就能让命令原样显示</p><h1 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h1><pre><code>按tab   引用块和引用冲突，不可分层</code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>可以嵌套使用,原理同标题，&gt;表示第一层，&gt;&gt;表示内2层，&gt;后接空格</p><blockquote><p>第一层</p><blockquote><p>第二层</p><blockquote><p>第三层内容</p></blockquote></blockquote></blockquote><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><hr><p>3个或3个以上的<em>或者-，*<em>效果相同</em></em></p><hr><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p><a href="https://www.jianshu.com/p/ea1eb11db63f" title="图床">图床的应用</a></p><blockquote><p>格式<br/><br>![图片alt](图片地址 ‘’图片title’’)</p></blockquote><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</p><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>[超链接名]（超链接地址 “超链接title”）</p><p>title可加可不加</p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>表头|表头|表头</p><p>—|:–:|—:</p><p>内容|内容|内容</p><p>内容|内容|内容</p><table><thead><tr><th>表头111</th><th align="center">表头222</th><th align="right">表头333</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>默认居左</td><td align="center">设置居中</td><td align="right">设置居右</td></tr></tbody></table><p>第二行分割表头和内容。<br><br><strong>- 有一个就行，为了对齐，多加了几个</strong></p><blockquote><dl><dt>文字默认居左<br/><br>: 两边加：表示文字居中<br/></dt><dd>右边加：表示文字居右<br/><br>注：原生的语法两边都要用 | 包起来。此处省略</dd></dl></blockquote><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表用"><a href="#无序列表用" class="headerlink" title="无序列表用-+*"></a>无序列表用-+*</h2><p>- 举例1<br/>+ 举例2<br/>* 举例3<br/></p><ul><li>举例1</li></ul><ul><li>举例2</li></ul><ul><li>举例3<h2 id="有序列表用1-2-3"><a href="#有序列表用1-2-3" class="headerlink" title="有序列表用1. 2. 3."></a>有序列表用1. 2. 3.</h2></li></ul><ol><li>举例1</li><li>举例2</li></ol><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>反引号`是~号的半角模式</p><h2 id="单行代码-xxxx"><a href="#单行代码-xxxx" class="headerlink" title="单行代码`xxxx`"></a>单行代码`xxxx`</h2><p><code>System.out.println(&quot;Hello&quot;);</code><br><code>System.out.println(&quot;World&quot;);</code></p><h2 id="多行代码-39-‘’xxx-xxx’’’"><a href="#多行代码-39-‘’xxx-xxx’’’" class="headerlink" title="多行代码&#39;‘’xxx xxx’’’"></a>多行代码&#39;‘’xxx xxx’’’</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(iterators.hasNextLine)&#123;</span><br><span class="line">    iterators.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><pre><code class="flow">st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;```</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
