<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>手写双向链表+反转单向链表</title>
      <link href="/zjh/2022/03/07/%E6%89%8B%E5%86%99%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-%E5%8F%8D%E8%BD%AC%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/zjh/2022/03/07/%E6%89%8B%E5%86%99%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-%E5%8F%8D%E8%BD%AC%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h1><ul><li>因为.next可以移动指针，所以某些for循环条件不需用index</li><li>双向链表有双向指针，需要相互指定</li><li><strong>要巧用“假设索引为0”来进行微调代码</strong></li><li>因为LinkedList的设计是有first和last头尾节点，所以在根据index增删的时候需要对头尾节点先进行判断</li><li>因此在LinkeList<strong>源码中会事先定义addFirst addLast removeFirst removeLast方法以便调用</strong></li><li>因为有first和last头尾节点是否null的问题，<strong>所以在设计双向链表时需要考虑判断0个元素(remove报错)、1个元素(remove后将last=null)、是否为头尾节点</strong></li><li>last.pre.next = last，就是当前的Node对象，<strong>Node对象为null，那么上一个Node.next也为null</strong></li><li>如果要进行全表置空or删除操作，<strong>需要先拿到置空的Node对象赋值给中间变量temp，然后再把Node的三个属性pre next item全=null，再用temp复原，源码说“help GC”，这样多几步操作是为了帮助gc回收垃圾</strong></li></ul><h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><ul><li>一个Node节点类(pre next item) 一个双向链表(first last length)</li><li>初始化LikeLinkedList， first为头节点，不装item</li><li>注意length的变化对方法体的影响</li><li>长度length=10时，有10个元素，第一个索引是0，最后一个索引是9（同数组）</li></ul><p>基本结构：</p><pre><code>public class LikeLinkedList&lt;T&gt; &#123;    private Node first;    private Node last;    private int length;//1,初始化public LikeLinkedList()&#123;    first = new Node(null,null,null);    last = null;    length = 0;&#125;    //方法&#125;class Node&lt;T&gt;&#123;    public T item;    public Node pre;    public Node next;    public Node(T item , Node pre , Node next)&#123;        this.item = item;        this.pre = pre;        this.next = next;    &#125;&#125;</code></pre><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="add尾增"><a href="#add尾增" class="headerlink" title="add尾增"></a>add尾增</h2><ul><li><p>因为last节点要变化，所以把last先存储成preLast</p></li><li><p>然后再更新新的last = new Node</p><pre><code>  //2,add尾增  public boolean add(T t)&#123;      if(length == 0)&#123;          last = new Node(t,first,null);          first.next = last;      &#125;      else&#123;          Node preLast = last;          last = new Node(t, preLast, null);          preLast.next =last;          &#125;      length++;      return true;  &#125;</code></pre></li></ul><h2 id="add索引处增"><a href="#add索引处增" class="headerlink" title="add索引处增"></a>add索引处增</h2><ul><li>先判断指针越界，throw异常，索引可取0~length-1</li><li>新元素加到索引处，<strong>原索引处依次后移</strong></li><li><strong>要对“是否是尾增”进行判断</strong></li><li>先用for获取原索引处的节点Node</li><li>前后Node先保存为中间量</li><li>new Node(t,pre,next)只能拿到单向指针，指向前后</li><li>必须额外补全双向指针</li></ul><pre><code>    //3,add索引增    public boolean add(int index, T t) &#123;        if (index &gt;= length || index &lt; 0) &#123;            throw new IndexOutOfBoundsException(&quot;指针越界&quot;);        &#125; else &#123;            if (index &lt; length - 1) &#123;//如果index==length-1,那么需要处理last节点                Node theNext = first.next;                for (int i = 0; i &lt;= index; i++) &#123;                    //假设index=1，第一次拿到theNext是0号索引                    theNext = theNext.next;//拿到后一个节点                &#125;                Node thePre = theNext.pre;//拿到前一个节点                Node newNode = new Node(t, thePre, theNext);//新节点指向前后两节点                //补全双向指针                theNext.pre = newNode;                thePre.next = newNode;            &#125; else if (index == length - 1) &#123;                //调用尾增方法                add(t);            &#125;        &#125;        return true;    &#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/49d84236a26c4e4080d79a170ed461ba.png" alt="流程"></p><h2 id="clear置空-源码解读"><a href="#clear置空-源码解读" class="headerlink" title="clear置空+源码解读"></a>clear置空+源码解读</h2><p>查看LinkedList源码中的clear发现，需要把每个节点都置空，而不是单单置空首尾节点<br>源码解释：<strong>全部置空gc效率更高，也防止有迭代器能访问到</strong><img src="https://img-blog.csdnimg.cn/c74c4beefccd436d9b4baf704712ed1b.png"></p><pre><code>//4,clear链表置空public void clear()&#123;    //全体置空增加gc回收效率，防止已有的迭代器继续访问    for(Node x = first ; x != null ; )&#123;        Node next = x.next;//先拿到下一个节点        //再把当前节点全部置空        x.next = null;        x.pre = null;        x.item = null;        x = next;    &#125;    length = 0 ;    first = last = null;//首尾置空&#125;</code></pre><h2 id="removeLast尾删除"><a href="#removeLast尾删除" class="headerlink" title="removeLast尾删除"></a>removeLast尾删除</h2><ul><li><p>用于给其他方法调用</p><pre><code>  public void removeLast() &#123;      if (last == null || length == 0) &#123;          throw new NoSuchElementException(&quot;已经没有元素了&quot;);      &#125; else if (last.pre == first) &#123;//如果只有一个元素时          first.next = null;          last = null;          length = 0;      &#125; else &#123;//多个元素          final Node preLast = last.pre;          preLast.next = null;          last = preLast;          length--;      &#125;  &#125;</code></pre></li></ul><h2 id="remove删指定索引元素"><a href="#remove删指定索引元素" class="headerlink" title="remove删指定索引元素"></a>remove删指定索引元素</h2><ul><li><p>如果是删除尾节点，还需要处理last</p><pre><code>  //5,remove删除索引处的元素  public boolean remove(int index) &#123;      if (index &lt; 0 || index &gt;= length) &#123;          throw new IndexOutOfBoundsException(&quot;指针越界&quot;);      &#125; else if (index == length - 1) &#123;//删除尾节点          removeLast();      &#125; else &#123;          Node curr = first;//获取头节点用于迭代，不是索引0处          for (int i = 0; i &lt;= index; i++) &#123;//拿到待删除的节点curr              curr = curr.next;          &#125;          //1 前后节点的对象先拿到，以便删除中间节点后恢复链接           final Node preNode = curr.pre;           final Node nextNode = curr.next;          //2 help gc，所以3次置空          curr.pre = null;          curr.next = null;          curr.item = null;          //3 恢复链接          preNode.next = nextNode;          nextNode.pre = preNode;      &#125;          return true;  &#125;</code></pre></li></ul><h2 id="indexOf第一次出现的索引"><a href="#indexOf第一次出现的索引" class="headerlink" title="indexOf第一次出现的索引"></a>indexOf第一次出现的索引</h2><ul><li><strong>要巧用“假设索引为0”来进行微调代码</strong></li><li>因为.next可以移动指针，所以for循环条件不需用index</li></ul><pre><code>    //6,indexOf第一次出现索引    public int indexOf(T t) &#123;        //假设t出现的索引是0，推得index初始值应设置为-1        int index = -1;        if (t == null) &#123;            for (Node x = first; x != null; x = x.next) &#123;                if (x.item == null) &#123;                    return index;                &#125;                index++;            &#125;        &#125; else &#123;            for (Node x = first; x != null; x = x.next) &#123;                if (x.item.equals(t)) &#123;                    return index;                &#125;                index++;            &#125;        &#125;        return index;    &#125;</code></pre><h1 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h1><ul><li>LikeLinkedList类实现Iterable接口</li><li>重写iterator方法，返回迭代器对象</li><li>重写Iterator中的hasNext和next方法</li></ul><p>如下：</p><pre><code>public class LikeLinkedList&lt;T&gt; implements Iterable&lt;T&gt;&#123;    private Node first;    private Node last;    private int length;    @Override    public Iterator&lt;T&gt; iterator() &#123;        return new Iterator() &#123;            Node n = first;            @Override            public boolean hasNext() &#123;                return n.next!=null;            &#125;            @Override            public Object next() &#123;                return n=n.next;            &#125;        &#125;;    &#125;    &#125;</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><pre><code>LikeLinkedList&lt;Object&gt; lll = new LikeLinkedList&lt;&gt;();lll.add(new Object());lll.add(new Object());lll.add(new Object());lll.add(new Object());lll.add(new Object());lll.removeLast();lll.remove(2);Iterator&lt;Object&gt; iterator = lll.iterator();while(iterator.hasNext())&#123;    System.out.println(iterator.next());&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/2b95766d786f41289b105cb726debec8.png"></p><h1 id="链表反转-单向链表"><a href="#链表反转-单向链表" class="headerlink" title="链表反转(单向链表)"></a>链表反转(单向链表)</h1><pre><code>//7,链表反转public void reverseLink()&#123;    Node x = first.next;//获取索引0的节点    Node nextX = x.next;//索引1处节点    x.next = null;//索引0变尾节点    reverse(x,nextX);&#125;public void reverse(Node prev , Node curr)&#123;//第一次传入索引：0、1    if(curr.next == null)&#123;//处理尾节点        first.next = curr;        curr.next = prev;        return;    &#125;    Node next = curr.next;//索引2    curr.next = prev;//1指0    reverse(curr,next);//递归，传索引1、2&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IOC控制反转+DI</title>
      <link href="/zjh/2022/03/07/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-DI/"/>
      <url>/zjh/2022/03/07/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-DI/</url>
      
        <content type="html"><![CDATA[<h1 id="IOC概念"><a href="#IOC概念" class="headerlink" title="IOC概念"></a>IOC概念</h1><ul><li>定义：控制反转，把对象的创建和调用（传统方式是通过new之后直接使用对象），交给Spring进行管理（依靠对象工厂通过注入的方式获取对象）</li><li>降低耦合度</li><li>底层原理：xml解析、工厂模式、反射<br><img src="https://img-blog.csdnimg.cn/93796adad5bc44db823d3ae671b23153.png" alt="参考"></li></ul><h2 id="补：工厂模式和单例模式区别"><a href="#补：工厂模式和单例模式区别" class="headerlink" title="补：工厂模式和单例模式区别"></a>补：工厂模式和单例模式区别</h2><p>单例模式（懒汉式，饿汉式）都只能创建一个指定类的唯一对象<br>工厂模式（一个接口，多态性的体现）可以创建该接口的工厂下的所有类的唯一对象<br><a href="https://zhuanlan.zhihu.com/p/356221658">工厂模式和单例模式的区别</a></p><h1 id="IOC接口——实现IOC容器"><a href="#IOC接口——实现IOC容器" class="headerlink" title="IOC接口——实现IOC容器"></a>IOC接口——实现IOC容器</h1><p>IOC容器可以有多个，new几个就有几个IOC容器，一个容器绑定一个xml文件，一个xml中可以配置多个bean，容器可以关闭<br><img src="https://img-blog.csdnimg.cn/36821c1c6b9a4833b55b72ce69fe2fe0.png"></p><h2 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1.BeanFactory"></a>1.BeanFactory</h2><ul><li>Spring的内部接口，不建议开发者使用</li><li>懒汉式，加载配置文件的时候不创建对象</li></ul><h2 id="2-ApplicationContext"><a href="#2-ApplicationContext" class="headerlink" title="2.ApplicationContext"></a>2.ApplicationContext</h2><ul><li>BeanFactory的子接口</li><li>功能更强大，建议开发者使用</li><li>饿汉式，加载配置文件即创建对象</li><li><strong>由于创建对象会耗费时间和资源，因此饿汉式可以把时间开销放在项目启动时</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/2976fce69f49417a98a1eea59d9a3a19.png">第三个是基于注解的获取容器方式，利用反射而非解析xml配置</p><p><a href="https://blog.csdn.net/weixin_38361347/article/details/89304414">SpringBoot中获取ApplicationContext的三种方式</a></p><ol><li>@Autowired: 在任意被spring托管的类中注入</li><li>ApplicationContextAware接口：实现这个接口可以在普通类中获取Spring的IOC容器</li></ol><h1 id="IOC操作管理Bean"><a href="#IOC操作管理Bean" class="headerlink" title="IOC操作管理Bean"></a>IOC操作管理Bean</h1><h2 id="xml配置bean"><a href="#xml配置bean" class="headerlink" title="xml配置bean"></a>xml配置bean</h2><p><a href="https://blog.csdn.net/jeason_chan_zju/article/details/102230747">bean.xml中的参数</a></p><ul><li>在bean.xml中配置了bean的属性后，先解析xml得到IOC接口对象（IOC容器），然后通过容器来getBean，获得对象<br><img src="https://img-blog.csdnimg.cn/23cdc3ed929f40dba75d523b53646a41.png">同时，ApplicationContext也可以换成其父接口BeanFactory，结果不受影响</li></ul><h3 id="DI：依赖注入（注入属性）"><a href="#DI：依赖注入（注入属性）" class="headerlink" title="DI：依赖注入（注入属性）"></a>DI：依赖注入（注入属性）</h3><p>两种方法</p><ol><li>set方法+property<br><img src="https://img-blog.csdnimg.cn/2cc81150b834476197e64ec6157a15bd.png"></li><li>有参构造+constructor<br><img src="https://img-blog.csdnimg.cn/64b6af6e4a3a4db584814118b5defe04.png"></li></ol><h3 id="工厂Bean和普通Bean"><a href="#工厂Bean和普通Bean" class="headerlink" title="工厂Bean和普通Bean"></a>工厂Bean和普通Bean</h3><p><img src="https://img-blog.csdnimg.cn/7b1c382c6a2e4c0ab733bd068b4a2276.png"></p><h2 id="注解配置bean"><a href="#注解配置bean" class="headerlink" title="注解配置bean"></a>注解配置bean</h2><h3 id="注册Bean"><a href="#注册Bean" class="headerlink" title="注册Bean"></a>注册Bean</h3><p>以下5个注解都可以创建Bean对象交给Spring的IOC容器进行管理</p><ul><li>@Component：以下4个的元注解</li><li>@Service</li><li>@Controller</li><li>@Repository</li><li>@Configuration</li></ul><p>因为元注解Component可以指定<strong>value=”别名”<strong>，所以以上5种注册Bean的方式都可以起别名，</strong>一个接口多个实现类Bean的情况需要起别名，否则Spring无法判断获取哪个Bean</strong></p><h3 id="使用Bean"><a href="#使用Bean" class="headerlink" title="使用Bean"></a>使用Bean</h3><ul><li>@Autowired：根据<strong>类</strong>自动装配</li><li>@Qualifier：根据<strong>别名</strong>装配，要和@Autowired搭配使用</li><li>@Resource：即可根据类也可根据别名</li><li>@Value：注入普通类型<strong>属性</strong><br><a href="https://www.cnblogs.com/chubuyu/p/12091719.html">案例</a></li></ul><p><img src="https://img-blog.csdnimg.cn/b9ae3bf8f76a497ab5ab5bc9d1fed97b.png" alt="两个String实现Bean，起别名"></p><h1 id="Bean的配置"><a href="#Bean的配置" class="headerlink" title="Bean的配置"></a>Bean的配置</h1><h2 id="作用域：如何设置bean的单例or多例"><a href="#作用域：如何设置bean的单例or多例" class="headerlink" title="作用域：如何设置bean的单例or多例"></a>作用域：如何设置bean的单例or多例</h2><p>scope属性值:（常用singleton和prototype）</p><ul><li>singleton：默认值，单例对象，饿汉式</li><li>prototype：多实例对象，懒汉式</li><li>request请求、session会话：不常用</li></ul><p>在bean.xml中或者@Bean(scope=””）中配置</p><h2 id="生命周期：创建到销毁"><a href="#生命周期：创建到销毁" class="headerlink" title="生命周期：创建到销毁"></a>生命周期：创建到销毁</h2><ol><li>无参构造</li><li>调用set方法解析配置</li><li>调用bean的初始化方法<br>如果有配置了初始化方法，需要配置init-method=”初始化方法的名称”</li></ol><p>例如：在@Bean(initmethod=”xxx方法”)</p><ol start="4"><li><p> 获取bean并使用<br>注解方法可以直接@Autowired注入bean，配置xml的方式通过<br>new ClassPathXmlApplicationContext(xxxx.xml)解析并获取IOC容器之后getBean</p></li><li><p>bean的销毁与销毁时方法<br><a href="https://blog.csdn.net/qq_31226223/article/details/115867365?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-2-115867365.pc_agg_new_rank&utm_term=springboot%E6%89%8B%E5%8A%A8%E9%94%80%E6%AF%81bean&spm=1000.2123.3001.4430">springboot中的bean创建与销毁</a></p></li></ol><p>销毁方法的配置@Bean(destroyMethod = “xxxxx”)<br>如果是配置在xml中，则</p><pre><code>&lt;bean id=&quot;  &quot; class=&quot;   &quot; destroy-method=&quot;   &quot;&gt;&lt;/bean&gt;</code></pre><p>xml配置的Bean的关闭：关闭IOC容器即可<img src="https://img-blog.csdnimg.cn/4893907395ac4d78a2d320b6abd4e9cd.png"></p><h1 id="Bean扫描"><a href="#Bean扫描" class="headerlink" title="Bean扫描"></a>Bean扫描</h1><p>spring中xml配置<br><img src="https://img-blog.csdnimg.cn/52b6614d9fce4511915d2ff30fb34edb.png"><br>spring和springboot中的注解配置<br>@ComponentScan</p><p><img src="https://img-blog.csdnimg.cn/9fac528da3bd4bc6bb0f5abc0bebeb08.png"></p><ul><li>被Component及其子注解标注的Bean需要用ComponentScan扫描到才能使用</li><li>SpringBootApplication启动类包括了@ComponentScan</li><li>@ComponentScan默认扫描该类包下的所有Bean</li><li>@ComponentScan可以自定义basePackages、includeFilters、excludeFilters</li></ul><p><a href="https://blog.csdn.net/huangjhai/article/details/104600328">使用详情参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql事务和存储引擎</title>
      <link href="/zjh/2022/03/07/Mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/zjh/2022/03/07/Mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p><a href="https://www.jianshu.com/p/9b5eb43236cc">参考</a><br><a href="https://www.cnblogs.com/qlqwjy/p/8547999.html">参考</a></p><h2 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h2><p>方式一：set autocommit = 0</p><p>方式二：START TRANSACTION 或 BEGIN</p><p>都是手动提交commit，手动回滚rollback</p><h2 id="Springboot中事务控制"><a href="#Springboot中事务控制" class="headerlink" title="Springboot中事务控制"></a>Springboot中事务控制</h2><h3 id="Transactional注解："><a href="#Transactional注解：" class="headerlink" title="@Transactional注解："></a>@Transactional注解：</h3><p>在Spring Boot中推荐使用@Transactional注解来申明事务。</p><ul><li>首先需要导入JDBC依赖</li><li>在<strong>Service层</strong>中添加@Transactional注解</li><li>@Transactional注解<strong>既可以标注在类上也可以标注在方法上</strong></li></ul><h3 id="业务场景举例："><a href="#业务场景举例：" class="headerlink" title="业务场景举例："></a>业务场景举例：</h3><p>经典的银行转账问题，Dao层两个@update，一个增一个减，Service层中不光注入了转账的Dao，还注入了积分相关的Dao，这一系列操作是一个事务，所以需要在Service层or其下对应的方法使用注解@Transactional</p><h3 id="注解属性"><a href="#注解属性" class="headerlink" title="注解属性"></a>注解属性</h3><p><a href="https://blog.csdn.net/wkl305268748/article/details/77619367?spm=1001.2014.3001.5506">常用配置参考</a></p><ul><li>rollbackFor：触发回滚的异常类型设定</li><li>isolation：事务的隔离级别设定</li><li>timeout：超时回滚<br><img src="https://img-blog.csdnimg.cn/fadee28af9584631b86082be4046fd9a.png"></li></ul><p>举例：<br><img src="https://img-blog.csdnimg.cn/a0f3bbb6296b4e78851a6faf049c4788.png"></p><h3 id="Transactional失效"><a href="#Transactional失效" class="headerlink" title="@Transactional失效"></a>@Transactional失效</h3><p><a href="https://zhuanlan.zhihu.com/p/114461128">失效参考案例</a><br>最常见的失效是：<strong>在事务内部把异常给捕获了</strong>，举个例子</p><p><img src="https://img-blog.csdnimg.cn/57b35a827c5e4ea489fc87ea18af55d8.png">应该在最外层（控制层）进行异常捕获，保证事务的开启只有一条语句</p><h2 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h2><p><img src="https://img-blog.csdnimg.cn/62d285c60c0f4d4885ed8575657a0f9d.png"></p><h2 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h2><ul><li>赃读：一个事务读到另外一个事务<strong>还没有提交</strong>的数据</li><li>不可重复读：一个事务<strong>先后</strong>读取同一条记录，但两次读取的数据不同，称之为不可重复读</li><li>幻读：（<strong>读时没有，插时有</strong>）一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”。</li></ul><h2 id="事务的4个隔离级别"><a href="#事务的4个隔离级别" class="headerlink" title="事务的4个隔离级别"></a>事务的4个隔离级别</h2><p>事务隔离级别越高，数据越安全，但是性能越低</p><p><img src="https://img-blog.csdnimg.cn/bfa54d09e1ed476f8514fdfc13522988.png"></p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><ul><li>存储数据，建立索引，增删改查</li><li>基于表，而非基于库</li><li>Mysql默认引擎是InnoDB</li></ul><p>mysiam使用的常见被nosql：mongodb替代<br>memory也是一样被nosql：redis取代</p><p><img src="https://img-blog.csdnimg.cn/ebc4baf0cebf45c18b826440bcf5809f.png"></p><h2 id="查看设置引擎"><a href="#查看设置引擎" class="headerlink" title="查看设置引擎"></a>查看设置引擎</h2><p>查看：SHOW ENGINES<br>设置：CREATE TABLE xxx（）ENGIENS = MyISAM</p><h2 id="默认：InnoDB"><a href="#默认：InnoDB" class="headerlink" title="默认：InnoDB"></a>默认：InnoDB</h2><ul><li>可靠性(行锁+事务+外键)，高性能(B+树)</li><li>支持事务，DML操作遵循ACID模型</li><li>行级锁，<strong>提高并发访问性能</strong>    </li><li>支持外键，保证数据完整性和正确性</li></ul><h2 id="早期：MyISAM"><a href="#早期：MyISAM" class="headerlink" title="早期：MyISAM"></a>早期：MyISAM</h2><p>面试题：</p><p><img src="https://img-blog.csdnimg.cn/1a0de812895e4c64b62fc4fa410bc886.png"><br>足迹，评论，点赞这种非核心数据 可以用myisam，偶尔丢点数据也没事</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql(InnoDB)索引原理及的使用</title>
      <link href="/zjh/2022/03/07/Mysql-InnoDB-%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/zjh/2022/03/07/Mysql-InnoDB-%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h1><ul><li>正常的业务SELECT居多，而INSERT UPDATE DELETE偏少，所以使用索引， 用空间换时间；查询变快，增删改变慢。</li><li>可以选择给单个字段加索引，也可以联合几个字段加索引</li><li>主键和外键默认都有索引，没有主键会自动生成rowid<h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1>索引是存储引擎实现的，InnoDB的索引结构是B+树，<strong>大部分的引擎也都支持B+树索引</strong><br><img src="https://img-blog.csdnimg.cn/c678a3d3200c4c51bb94f79b353513bb.png"></li></ul><h2 id="B-树索引的优点"><a href="#B-树索引的优点" class="headerlink" title="B+树索引的优点"></a>B+树索引的优点</h2><p><img src="https://img-blog.csdnimg.cn/467a09b2cd70414dba064625da2053e5.png"></p><ul><li><strong>层级少</strong>，2200W的数据只有3层</li><li>叶子节点存数据+指针(<strong>利于排序</strong>)</li><li>支持<strong>范围查询</strong>    </li><li>支持<strong>排序(区间指针)</strong></li><li>索引全部出现在最下层，即便是他们作为了上层分支</li></ul><h2 id="InnoDB到底支持Hash索引吗？"><a href="#InnoDB到底支持Hash索引吗？" class="headerlink" title="InnoDB到底支持Hash索引吗？"></a>InnoDB到底支持Hash索引吗？</h2><p>InnoDB在特定条件下会<strong>自适应Hash索引，用户不能手动创建</strong>，可以理解为“索引的索引”，可以加快索引查询速度</p><p>关于这个问题，参考<a href="https://wenku.baidu.com/view/912836ffb5360b4c2e3f5727a5e9856a571226ef.html">https://wenku.baidu.com/view/912836ffb5360b4c2e3f5727a5e9856a571226ef.html</a></p><p>相比B+树的优缺点：</p><ul><li>不支持范围查询，但指定查询效率更高(一般只需一次检索)</li><li>哈希冲突问题使用链表解决</li><li><strong>无法排序</strong>，哈希值计算结果没有顺序关系</li></ul><p><a href="https://www.cnblogs.com/igoodful/p/9361500.html">参考</a></p><h1 id="索引4种分类"><a href="#索引4种分类" class="headerlink" title="索引4种分类"></a>索引4种分类</h1><p><img src="https://img-blog.csdnimg.cn/251aa1aa0c344c15a3fdc3d56e499f10.png"></p><h2 id="聚集索引and二级索引"><a href="#聚集索引and二级索引" class="headerlink" title="聚集索引and二级索引"></a>聚集索引and二级索引</h2><p>聚集索引：唯一；索引处叶子节点包括<strong>行数据</strong><br>二级索引：多个：索引处叶子节点包括<strong>数据+关联的聚集索引</strong></p><h3 id="聚类索引"><a href="#聚类索引" class="headerlink" title="聚类索引"></a>聚类索引</h3><ul><li><strong>主键</strong>就是聚类索引</li><li>没有主键就是<strong>UNIQUE</strong>作为聚类索引</li><li>都没有则InnoDB<strong>自动生成rowid</strong>作为隐藏的聚类索引</li></ul><h3 id="二级索引及回表查询"><a href="#二级索引及回表查询" class="headerlink" title="二级索引及回表查询"></a>二级索引及回表查询</h3><ul><li>每个叶子节点都包含<strong>对应行的聚类索引</strong></li><li><strong>回表查询</strong>：例如当SELECT * FROM时，这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式</li></ul><h1 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h1><p><a href="https://blog.csdn.net/qq_34698708/article/details/102529272?ops_request_misc=&request_id=&biz_id=102&utm_term=mysql%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-102529272.nonecase&spm=1018.2226.3001.4187">详细参考</a><br><img src="https://img-blog.csdnimg.cn/911a861364f3410c9527643a8754ad60.png"></p><h2 id="主键和外键"><a href="#主键和外键" class="headerlink" title="主键和外键"></a>主键和外键</h2><p>主键：ALTER TABLE nxbusers ADD PRIMARY KEY ( id );<br><img src="https://img-blog.csdnimg.cn/9e729dd490024ece8da2f08eb1ae5079.png"><br>外键：ALTER TABLE nxbinfolike ADD FOREIGN KEY ( infoid ) REFERENCES nxbpushinfo ( infoid );</p><p>也可以在设计表的时候直接添加。关于是否添加外键，可以参考<br><a href="https://www.cnblogs.com/jxl00125/p/12622969.html">https://www.cnblogs.com/jxl00125/p/12622969.html</a><br><a href="https://blog.csdn.net/bisal/article/details/50934304">https://blog.csdn.net/bisal/article/details/50934304</a></p><h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><p><strong>SHOW INDEX FROM</strong> nxbcomments<br>一般建立的索引都是普通类型，至于索引方法还可以选择Hash，但不建议<br><img src="https://img-blog.csdnimg.cn/a544a78407cf48cbb802c94efa04bfee.png"></p><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><h3 id="默认：普通索引"><a href="#默认：普通索引" class="headerlink" title="默认：普通索引"></a>默认：普通索引</h3><p><strong>CREATE INDEX</strong> idx_comment_infoid <strong>ON</strong> nxbcomments <strong>(</strong> infoid <strong>)</strong></p><h3 id="全文索引or唯一索引"><a href="#全文索引or唯一索引" class="headerlink" title="全文索引or唯一索引"></a>全文索引or唯一索引</h3><p>同理可以把FULLTEXT更换为UNIQUE<br>CREATE <strong>FULLTEXT</strong> INDEX idx_comment_infoid ON nxbcomments ( infoid );</p><p><img src="https://img-blog.csdnimg.cn/53e1a75bbcf5412fbe5118b890cc0c3f.png"></p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>注意索引命名方式，<strong>括号内顺序就是索引建立的顺序，关乎索引失效问题</strong><br>CREATE INDEX idx_pushinfo_topic_location ON nxbpushinfo ( topic, location );</p><p>这样一来就建立了“话题”和“定位”的索引，在查询的时候可以只查询话题（索引失效的应用）</p><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>DROP INDEX idx_comment_infoid ON nxbcomments;<br>或者</p><p>ALTER TABLE nxbcomments DROP INDEX idx_comment_infoid;</p><h1 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h1><p>1). 针对于<strong>数据量较大</strong>，且查询比较频繁的表建立索引。<br>2). 针对于常作为<strong>查询条件（where）、排序（order by）、分组（group by）</strong>操作的字段建立索引。<br>3). 尽量选择区分度高的列作为索引，<strong>尽量建立唯一索引，区分度越高，使用索引的效率越高。</strong><br>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。<br>5). <strong>尽量使用联合索引</strong>，减少单列索引，查询时，<strong>联合索引很多时候可以覆盖索引，节省存储空间</strong>，避免回表，提高查询效率。<br>6). <strong>要控制索引的数量</strong>，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，<strong>会影响增删改的效率</strong><br>7). <strong>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它</strong>。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p><h1 id="联合索引失效"><a href="#联合索引失效" class="headerlink" title="联合索引失效"></a>联合索引失效</h1><ul><li>索引失效会带来一些问题，同时也可以巧妙应用</li><li>索引的触发是通过where的，<strong>没有where则不触发索引</strong></li><li>where的条件的顺序没有影响，有影响的是<strong>定义索引时的顺序</strong></li><li><strong>总结</strong>：跳过了定义时的中间索引(后面的失效)；&lt;&gt;（后面的失效）；进行了运算（后面的失效）；字符串不加引号（后面的失效）；前缀%模糊查询（后面的失效）；or连接条件有的没索引(<strong>全失效</strong>)；查询已排序好的数据的边缘<h2 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h2>创建索引（topic , location , tag）即该索引在底层的建立顺序是从<strong>左到右</strong></li><li>如果where条件中出现了topic = “” 则触发索引机制</li><li>如果where条件中只写了topic = “” 和 tag = “” 而<strong>跳过了中间的location，则索引只对topic生效</strong></li><li>如果where tag = “” and loacation = “” and topic = “”这种顺序也是可以的，<strong>只要是出现了topic就能触发索引</strong></li></ul><p>我们可以利用该特性实现《只定义一个联合索引，达到多方式筛选的目的》</p><h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询<strong>右侧的列索引失效**。<br>当范围查询使用&gt;= 或 &lt;= 时，走联合索引了，所有的字段都是走索引<br>的。<br>**所以，在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt;</strong></p><h2 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h2><p>例如explain select * from tb_user where <strong>substring(phone,10,2) = ‘15’;</strong><br>会导致索引失效</p><p><img src="https://img-blog.csdnimg.cn/4f0a1723a4a94b0da4ca9415fccf7e2e.png"></p><h2 id="字符串不加引号"><a href="#字符串不加引号" class="headerlink" title="字符串不加引号"></a>字符串不加引号</h2><p>字符串类型的数据如果不加引号，对查询结果没有影响，但是不会触发索引</p><p>不触发：SELECT * FROM nxbpushinfo WHERE infoid = 1643877357315 ;</p><p>触发：SELECT * FROM nxbpushinfo WHERE infoid = ‘1643877357315’ ;</p><h2 id="头部模糊查询"><a href="#头部模糊查询" class="headerlink" title="头部模糊查询"></a>头部模糊查询</h2><p>尾模糊不失效，头模糊失效<br><img src="https://img-blog.csdnimg.cn/783740dede13460f8112d8de20b68e35.png"></p><h2 id="or连接条件"><a href="#or连接条件" class="headerlink" title="or连接条件"></a>or连接条件</h2><p><strong>or连接的条件必须都有索引，不然都会失效；开发中可以使用UNION进行优化</strong></p><p>where topic = “” or location = “”如果topic字段有索引（单独索引or联合索引）但是location没有索引，那么topic的索引也失效</p><h2 id="数据分布影响"><a href="#数据分布影响" class="headerlink" title="数据分布影响"></a>数据分布影响</h2><p>如果MySQL评估使用索引比全表更慢，则不使用索引。<br>例如：已经按排序字段数据，查询倒数第10到正数第一的所有数据，不走索引<br>例如：一个表中绝大多数都是null，那么WHERE 有索引的字段 is not null也不走索引</p><h1 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h1><p> 直接在select语句之前加上关键字 explain / desc<br>EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;</p><p>可以查询索引的使用情况</p><h1 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h1><p>SQL提示，是优化数据库的一个重要手段，可以指定查询<strong>走联合索引or指定索引</strong></p><h2 id="use-index建议"><a href="#use-index建议" class="headerlink" title="use index建议"></a>use index建议</h2><p>建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进行评估）</p><p> select * from 表 index(指定索引) where 条件；</p><h2 id="ignore-index忽略"><a href="#ignore-index忽略" class="headerlink" title="ignore index忽略"></a>ignore index忽略</h2><p>忽略指定的索引。<br>如果有其他包含的索引，则走其他索引。没有则不走索引</p><h2 id="force-index强制"><a href="#force-index强制" class="headerlink" title="force index强制"></a>force index强制</h2><p>放的位置也和use index 一样，强制使用索引，不听mysql评估</p><h1 id="索引覆盖-避免回表"><a href="#索引覆盖-避免回表" class="headerlink" title="索引覆盖(避免回表)"></a>索引覆盖(避免回表)</h1><p>概念：where中出现的字段都有索引，select的字段尽量是这些索引的字段，而非其他字段</p><p><strong>如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据（回表查询）</strong></p><h1 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h1><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。<strong>此时可以只将字符串的一部分前缀，建立索引</strong>，这样可以大大节约索引空间，从而提高索引效率。</p><p>例如：对江苏南京，四川绵阳这种location字段的省份建立索引(不考虑黑龙江是三个字)</p><p>create index idx_location_province on nxbpushinfo(location(2))</p><p>例如：手机号码的前缀决定了地域，也可以添加前缀索引</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>类自身嵌套(二叉树删除)栈堆分析</title>
      <link href="/zjh/2022/03/07/%E7%B1%BB%E8%87%AA%E8%BA%AB%E5%B5%8C%E5%A5%97-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A0%E9%99%A4-%E6%A0%88%E5%A0%86%E5%88%86%E6%9E%90/"/>
      <url>/zjh/2022/03/07/%E7%B1%BB%E8%87%AA%E8%BA%AB%E5%B5%8C%E5%A5%97-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A0%E9%99%A4-%E6%A0%88%E5%A0%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="类自嵌堆栈分析"><a href="#类自嵌堆栈分析" class="headerlink" title="类自嵌堆栈分析"></a>类自嵌堆栈分析</h1><pre><code>//节点类，构造器等方法省略    class MyNode &#123;        Key key;        Value value;        MyNode left;        MyNode right;&#125;</code></pre><h2 id="自身嵌套不创建栈空间"><a href="#自身嵌套不创建栈空间" class="headerlink" title="自身嵌套不创建栈空间"></a>自身嵌套不创建栈空间</h2><pre><code>@Test    public void test1()&#123;        MyNode node1 = new MyNode();//第一个节点    node1.left = new MyNode();    node1.left.left = new MyNode();    node1.left.left.left = new MyNode();    node1.left.left.left.left = new MyNode();    node1.left.left.left.left.left = new MyNode();    //栈地址：node2 ≠ node1.left    //栈值(堆地址)：node2 = node1.left    MyNode node2 = node1.left;    node2.left.left.left.left = null;//尾节点置空，修改堆的值，相当于node1.left.left.left.left.left=null;    //原node1之下的树：    System.out.println(node1.left.left.left.left);//tree.BinaryTree$MyNode@2d3fcdbd;但该节点的4个属性都为null    System.out.println(node1.left.left.left.left.left);//null&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/b19e546980ea41b7901bd9a23976beca.png"></p><p><img src="https://img-blog.csdnimg.cn/9039c0f58be8492189820eae8e716a47.png"><br><strong>因此对node2.left.left…的属性进行修改是会影响到node1.left.left…的</strong></p><h1 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h1><p>一个简陋版的删除方法，有一些小bug，但大题思路是这样</p><ul><li>开辟栈空间，用temp中间变量来进入树的内部，因为修改的是堆对象，所以这个新开辟的temp也能达到并修改</li><li>当删除的节点左右分支都存在时，右子树的最小节点将作为替换节点</li></ul><p><img src="https://img-blog.csdnimg.cn/b59481d64bea4f94bf00c048ea4c21d0.png" alt="在这里插入图片描述"></p><pre><code>public MyNode deleteFrom(MyNode x , Key key)&#123;    if(x==null)&#123;        return null;    &#125;    int cmp = key.compareTo(x.key);//递归    if(cmp&lt;0)&#123;        x.left = deleteFrom(x, key);    &#125;else if(cmp&gt;0)&#123;        x.right = deleteFrom(x,key);    &#125;else&#123;//当前节点就是需要删除的节点        //如果两边都有节点，那么要找出right子树的最小节点temp替代当前节点        if(x.right==null)&#123;            return x.left;        &#125;else if(x.left==null)&#123;            return x.right;        &#125;else&#123;            //1,找到右子树最小节点temp,并在原树中删除            MyNode temp = x.right;//开辟栈temp                      MyNode destTemp = null;//开辟栈destTemp            while(temp.left != null)&#123;                temp = temp.left;                if(temp.left.left == null)&#123;//temp.left就是该换位的节点，                    //1.1 destTemp拿到最终节点的地址值                    destTemp = temp.left;  //栈中destTemp拿到对象                    //1.2                    temp.left = null;     //堆中对象的left属性置空，但堆对象存在                    break;                &#125;            &#125;                        temp = destTemp; //栈中temp拿到了右子树最小节点的地址            //2,temp指向x.left和x.right            temp.left = x.left;            temp.right = x.right;            //3,temp替换x            x = temp;            &#125;            n--;        &#125;    return x;&#125;</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>匿名对象也不创建栈，只创建堆对象，即便是匿名对象被引用了，例如:<br>Thread t1 = new Thread(new MyRunable());</li><li>不显式声明的对象都没有栈</li><li>jvm栈中的内存在类结构确定时就知道了，随着方法结束或者线程消亡，内存自然而然被回收了，<strong>因此尽量不使用递归，递归的方法不结束会连续创建很多个栈空间，可能爆栈；而循环每循环一次都会入栈出栈</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java堆排序的过程到设计</title>
      <link href="/zjh/2022/03/07/Java%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B%E5%88%B0%E8%AE%BE%E8%AE%A1/"/>
      <url>/zjh/2022/03/07/Java%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%87%E7%A8%8B%E5%88%B0%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ul><li>堆的原理是顺序二叉树，但底层实现是数组</li><li>arr[i]是父节点，那么arr[2<em>i+1]是其左子节点，arr[2</em>i+2]是其右子节点</li><li>arr[i]的父节点是arr[ (i-1)/2 ]</li><li>arr[0]是根节点，并频繁用于和尾节点交换<br><img src="https://img-blog.csdn.net/20180908013007479?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MTg2Njkw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70#pic_center" alt="过程动图"></li></ul><p><a href="https://blog.csdn.net/u010452388/article/details/81283998?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164646575616781685311492%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164646575616781685311492&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81283998.pc_search_result_control_group&utm_term=%E5%A0%86%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187">参考1</a></p><p><a href="https://blog.csdn.net/qq_36186690/article/details/82505569?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164647017516780271519582%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164647017516780271519582&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82505569.pc_search_result_control_group&utm_term=%E5%A0%86%E6%8E%92%E5%BA%8Fjava&spm=1018.2226.3001.4187">参考2</a></p><ol><li>调用heapMaker方法，把arr变成大顶堆的顺序（会判断每个元素）</li><li>此时已有大顶堆，把根节点（大顶）和末尾交换并固定，size-1</li><li>再从新的根节点（之前的小节点）调用<strong>下沉算法</strong>sink，再把arr变为大顶堆的顺序（这次只操作部分元素）</li><li>循环，直至size = 1</li></ol><h1 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h1><h2 id="heapMaker构造大顶堆"><a href="#heapMaker构造大顶堆" class="headerlink" title="heapMaker构造大顶堆"></a>heapMaker构造大顶堆</h2><p>将无序数组构造成一个大根堆（升序用大根堆，降序就用小根堆）</p><pre><code>//创建堆：从arr[0]开始，每添加一个元素都和其父元素进行对比public static void heapMaker(int[] arr) &#123;    for (int i = 0; i &lt; arr.length; i++) &#123;        int currentIndex = i;        int fatherIndex = (i - 1) / 2;        //因为此逻辑并未判断左右子节点之间的大小关系，所以在sink方法中需要进行判断        while (arr[currentIndex] &gt; arr[fatherIndex]) &#123;            //1.交换            swap(arr, currentIndex, fatherIndex);            //2.子索引变父索引，继续向上判断            currentIndex = fatherIndex;            fatherIndex = (fatherIndex - 1) / 2;        &#125;    &#125;&#125;</code></pre><h2 id="交换固定"><a href="#交换固定" class="headerlink" title="交换固定"></a>交换固定</h2><pre><code>//交换public static void swap(int[] arr, int i, int j) &#123;    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;&#125;</code></pre><h2 id="下沉算法：修正大顶堆"><a href="#下沉算法：修正大顶堆" class="headerlink" title="下沉算法：修正大顶堆"></a>下沉算法：修正大顶堆</h2><pre><code>//大顶堆的修正(下沉算法)public static void sink(int[] arr, int index, int size) &#123;//size:最大范围    //1.左右子节点大小对比，    int left = index * 2 + 1;    int right = index * 2 + 2;    int maxValueIndex = 0;//父、左、右的最大值对应的索引    //2.right&lt;size即可保证指针不越界    while (left &lt; size) &#123;        //2.1找出最大值的索引        if (right &lt; size &amp;&amp; arr[right] &gt; arr[left]) &#123;            maxValueIndex = right;        &#125; else &#123;            maxValueIndex = left;        &#125;        if (arr[index] &gt; arr[maxValueIndex]) &#123;            maxValueIndex = index;        &#125;        //2.2判断是否大顶堆        if (index == maxValueIndex) &#123;            break;        &#125;        //2.3交换arr中的值        swap(arr, index, maxValueIndex);        //2.4下一轮        index = maxValueIndex;//一定是左or右        left = index * 2 + 1;        right = index * 2 + 2;    &#125;&#125;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>public static void main(String[] args) &#123;    int[] arr = new int[]&#123;1, 2, 4, 5, 1, 2, 4, 3, 2, 54, 23452, 543, 12, 4&#125;;    System.out.println(&quot;最初&quot;);    System.out.println(Arrays.toString(arr));    System.out.println(&quot;生成大顶堆&quot;);    heapMaker(arr);//生成大顶堆    System.out.println(Arrays.toString(arr));    System.out.println(&quot;循环固定，排序后&quot;);    int size = arr.length;    while (size &gt; 1) &#123;        //1,固定最大值        swap(arr, 0, size - 1);        size--;        //2,下沉：修正大顶堆        sink(arr, 0, size);    &#125;    System.out.println(Arrays.toString(arr));&#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/9ff6ff7f01284cafbc5222d7a9dc7481.png"></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><pre><code>public class heapSort &#123;public static void main(String[] args) &#123;    int[] arr = new int[]&#123;1, 2, 4, 5, 1, 2, 4, 3, 2, 54, 23452, 543, 12, 4&#125;;    System.out.println(&quot;最初&quot;);    System.out.println(Arrays.toString(arr));    System.out.println(&quot;生成大顶堆&quot;);    heapMaker(arr);//生成大顶堆    System.out.println(Arrays.toString(arr));    System.out.println(&quot;循环固定，排序后&quot;);    int size = arr.length;    while (size &gt; 1) &#123;        //1,固定最大值        swap(arr, 0, size - 1);        size--;        //2,下沉：修正大顶堆        sink(arr, 0, size);    &#125;    System.out.println(Arrays.toString(arr));&#125;//交换public static void swap(int[] arr, int i, int j) &#123;    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;&#125;//创建堆：从arr[0]开始，每添加一个元素都和其父元素进行对比public static void heapMaker(int[] arr) &#123;    for (int i = 0; i &lt; arr.length; i++) &#123;        int currentIndex = i;        int fatherIndex = (i - 1) / 2;        //因为此逻辑并未判断左右子节点之间的大小关系，所以在sink方法中需要进行判断        while (arr[currentIndex] &gt; arr[fatherIndex]) &#123;            //1.交换            swap(arr, currentIndex, fatherIndex);            //2.子索引变父索引，继续向上判断            currentIndex = fatherIndex;            fatherIndex = (fatherIndex - 1) / 2;        &#125;    &#125;&#125;//大顶堆的修正(下沉算法)public static void sink(int[] arr, int index, int size) &#123;//size:最大范围    //1.左右子节点大小对比，    int left = index * 2 + 1;    int right = index * 2 + 2;    int maxValueIndex = 0;//父、左、右的最大值对应的索引    //2.right&lt;size即可保证指针不越界    while (left &lt; size) &#123;        //2.1找出最大值的索引        if (right &lt; size &amp;&amp; arr[right] &gt; arr[left]) &#123;            maxValueIndex = right;        &#125; else &#123;            maxValueIndex = left;        &#125;        if (arr[index] &gt; arr[maxValueIndex]) &#123;            maxValueIndex = index;        &#125;        //2.2判断是否大顶堆        if (index == maxValueIndex) &#123;            break;        &#125;        //2.3交换arr中的值        swap(arr, index, maxValueIndex);        //2.4下一轮        index = maxValueIndex;//一定是左or右        left = index * 2 + 1;        right = index * 2 + 2;    &#125;&#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bean标签到Spring的IOC注解</title>
      <link href="/zjh/2022/03/07/Bean%E6%A0%87%E7%AD%BE%E5%88%B0Spring%E7%9A%84IOC%E6%B3%A8%E8%A7%A3/"/>
      <url>/zjh/2022/03/07/Bean%E6%A0%87%E7%AD%BE%E5%88%B0Spring%E7%9A%84IOC%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在xml中配置bean有如下配置，非常麻烦，在新spring和springboot中都是用注解开发<br><img src="https://img-blog.csdnimg.cn/3fca5187f2a44838b9f9a5922710a652.png"></p><h1 id="Spring原始注解"><a href="#Spring原始注解" class="headerlink" title="Spring原始注解"></a>Spring原始注解</h1><p><img src="https://img-blog.csdnimg.cn/ab6303cdf76a47a0b568fb93cb01612f.png"></p><h2 id="Component注入"><a href="#Component注入" class="headerlink" title="@Component注入"></a>@Component注入</h2><ul><li>@Repository @Service @Controller @Configuration都包含元注解@Component</li><li>@Component只需要在类上加注解，不用再去xml中配bean标签</li><li>@Autowired @Qualifier @Resource则是注入，替代了bean标签的ref功能</li><li><strong>@Repository是写在Dao层的，@Mapper是没有注入功能的</strong><h3 id="注入，交给Spring的IOC容器进行管理"><a href="#注入，交给Spring的IOC容器进行管理" class="headerlink" title="注入，交给Spring的IOC容器进行管理"></a>注入，交给Spring的IOC容器进行管理</h3></li></ul><ul><li>@Component可以设置一个value值，即id，可以搭配@Qualifier</li><li>交给Spring管理的类才可以调用Spring IOC的注解，换言之，例如：如果是一个普通类，则没办法@Autowired和被@Autowired</li><li>@Repository @Service @Controller @Configuration功能基本一致，但是为了解耦且易于分辨，在不同层用不同的注解</li></ul><h2 id="Autowired注入"><a href="#Autowired注入" class="headerlink" title="@Autowired注入"></a>@Autowired注入</h2><ul><li>像Dao层，Service层，这些 类名=id 的组件是唯一的，换言之不需要用@Qualifier来区分</li><li>像自定义的bean，在xml文件中进行配置的bean，可能存在同类不同bean（不同id）的情况，需要**@Qualifier+@Autowired来区分+注入**</li><li><strong>@Resource() = @Qualifier()+@Autowired</strong></li></ul><h2 id="Scope作用域"><a href="#Scope作用域" class="headerlink" title="@Scope作用域"></a>@Scope作用域</h2><p>可以写在@Bean上，也可以写在@Component上<br><img src="https://img-blog.csdnimg.cn/d0517c18fc0c401c977aa9e98b6e5322.png"></p><h2 id="关于-Bean和-Component"><a href="#关于-Bean和-Component" class="headerlink" title="关于@Bean和@Component"></a>关于@Bean和@Component</h2><ul><li>前者作用在方法上，细粒度；后者作用在类上，粗粒度。</li><li>都是注入到容器中，并且可以被使用<br><img src="https://img-blog.csdnimg.cn/42f4731b345b488aabadca7f364d46a7.png" alt="bean.xml中"></li></ul><p><img src="https://img-blog.csdnimg.cn/7bb4216bafee4e989f7642e54c0ac6cd.png" alt="@Bean读取并注入"></p><h2 id="Value获取值-spel表达式"><a href="#Value获取值-spel表达式" class="headerlink" title="@Value获取值+spel表达式"></a>@Value获取值+spel表达式</h2><p>同样，要使用这个注解，该类本身也必须是要被注入到容器中的<br><img src="https://img-blog.csdnimg.cn/93ec09f55c9146f489350694e222018d.png"></p><h2 id="PostConstruct和-PreDestroy"><a href="#PostConstruct和-PreDestroy" class="headerlink" title="@PostConstruct和@PreDestroy"></a>@PostConstruct和@PreDestroy</h2><p>前者相当于xml配置中的init-method，后者相当于destroy-method</p><pre><code>@PostConstructpublic void bean初始化的连带方法()&#123;&#125;</code></pre><h1 id="Spring新注解"><a href="#Spring新注解" class="headerlink" title="Spring新注解"></a>Spring新注解</h1><p><img src="https://img-blog.csdnimg.cn/4937250a89b8425ea14803ccb87c6b5c.png"></p><h2 id="Configuration核心配置类"><a href="#Configuration核心配置类" class="headerlink" title="@Configuration核心配置类"></a>@Configuration核心配置类</h2><ul><li><p>@Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。</p></li><li><p>@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的&lt;beans&gt;，作用为：配置spring容器(应用上下文)</p></li><li><p><em>类的方式代替文件，注解的方式代替标签</em>*</p></li><li><p><strong>核心配置类只有一个</strong>，要导入其他配置类中的bean则需要@Import({})导入其他非核心配置类</p></li></ul><h2 id="ComponentScan扫描包"><a href="#ComponentScan扫描包" class="headerlink" title="@ComponentScan扫描包"></a>@ComponentScan扫描包</h2><ul><li>默认当前类的包下，也可以自己配置</li><li>代替xml中的context:component-scan base-package = “”</li></ul><h2 id="PropertySource读取自定义配置"><a href="#PropertySource读取自定义配置" class="headerlink" title="@PropertySource读取自定义配置"></a>@PropertySource读取自定义配置</h2><p>@ConfigurationProperties会加载配置文件application.yml或application.properties配置中的属性;<br><strong>但是如果我们需要自己单独定义的属性文件的时候, 就要用到 自己指定属性源了: @PropertySource</strong></p><p><a href="https://segmentfault.com/a/1190000023512802">演示案例</a></p><h1 id="普通类使用IOC容器中的bean"><a href="#普通类使用IOC容器中的bean" class="headerlink" title="普通类使用IOC容器中的bean"></a>普通类使用IOC容器中的bean</h1><p>方式一：@Component注入Spring容器，交给Spring托管，可以使用Spring的注解例如@Autowired</p><p>方式二：实现ApplicationContextAware接口，写一个工具类</p><p><img src="https://img-blog.csdnimg.cn/5dd7ee63df3d4c68936eff7f7e9077aa.png" alt="工具类"></p><h2 id="为什么普通类不能直接-Autowired"><a href="#为什么普通类不能直接-Autowired" class="headerlink" title="为什么普通类不能直接@Autowired"></a>为什么普通类不能直接@Autowired</h2><p>spring基于注解的普通类怎么调用@Services注解的service方法，需要一些先决条件：  </p><p>1、<strong>如果你想用@autowired，那么这个类本身也应该是在spring的管理下的</strong>，即你的UserLogUtil也要标注为一个component（或Service），这样spring才知道要注入依赖；  </p><p>2、或者，不标注为@Component的话，此时不能通过@autowired来注入依赖，<strong>只能通过ApplicationContext来取得标注为Service的类：</strong>  </p><p>UserLogService service = ApplicationContext.getBean(UserLogService.class)。</p><h1 id="Configuration替代-lt-Beans-gt"><a href="#Configuration替代-lt-Beans-gt" class="headerlink" title="@Configuration替代&lt;Beans&gt;"></a>@Configuration替代&lt;Beans&gt;</h1><ul><li>@Configuration声明的类 相当于 bean.xml文件中的&lt;Beans&gt;标签</li><li>在该类中可以@Bean方法注入bean 相当于 &lt;Bean&gt;小标签</li><li>在该类上可以@ComponentScan()指定扫描路径，Springboot默认该包下扫描</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>注解PropertySource自定义配置文件的三种方法</title>
      <link href="/zjh/2022/03/07/%E6%B3%A8%E8%A7%A3PropertySource%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/zjh/2022/03/07/%E6%B3%A8%E8%A7%A3PropertySource%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="demo的结构"><a href="#demo的结构" class="headerlink" title="demo的结构"></a>demo的结构</h1><p>配置结构<br><img src="https://img-blog.csdnimg.cn/fa10ddbf952c4e6ca52fcedeba759724.png">这样是为了引出配置bean的3种方法</p><ol><li>单一bean上加@Component直接注入</li><li>一个核心配置类@Configuration + @Bean </li><li>一个核心配置类@Configuration+一个非核心配置类+@Bean<h1 id="自定义配置文件properties"><a href="#自定义配置文件properties" class="headerlink" title="自定义配置文件properties"></a>自定义配置文件properties</h1></li></ol><p>可以是properties后缀，也可以是yml后缀，都可以解析</p><p><img src="https://img-blog.csdnimg.cn/6a54e4c7caeb4475bd01694a64411215.png"></p><h1 id="PropertySource参数解析"><a href="#PropertySource参数解析" class="headerlink" title="@PropertySource参数解析"></a>@PropertySource参数解析</h1><ul><li>value = “classpath:users.properties” ——  <strong>classpath:后跟resource路径下的全名</strong></li><li>ignoreResourceNotFound = false  —— 开发中一般都是false，找不到资源会报错提醒</li><li>encoding = “UTF-8”  ——  解决中文乱码问题(同时可能需要设置idea的编码格式)</li></ul><h1 id="注意导入lombok包可能产生的问题"><a href="#注意导入lombok包可能产生的问题" class="headerlink" title="注意导入lombok包可能产生的问题"></a>注意导入lombok包可能产生的问题</h1><p><a href="https://blog.csdn.net/m0_56079407/article/details/123337448?spm=1001.2014.3001.5501">@Value Cannot find method ‘value‘(lombok冲突)</a></p><h1 id="一：直接使用-Component-PropertySource"><a href="#一：直接使用-Component-PropertySource" class="headerlink" title="一：直接使用@Component+@PropertySource"></a>一：直接使用@Component+@PropertySource</h1><p>导包，一定要加上springframework下的Value包，不然@Value会出问题</p><pre><code>import lombok.Data;import org.springframework.beans.factory.annotation.Value;</code></pre><p>直接读取后注入</p><pre><code>@Data//get set方法@Component@PropertySource(value = &quot;classpath:users.properties&quot;,        ignoreResourceNotFound = false,        encoding = &quot;UTF-8&quot;)//@ConfigurationProperties(prefix = &quot;user1.&quot;)public class Managers &#123;    @Value(&quot;$&#123;user1.name&#125;&quot;)    private String name;    @Value(&quot;$&#123;user1.sex&#125;&quot;)    private String sex;    @Value(&quot;$&#123;user1.age&#125;&quot;)    private int age;&#125;</code></pre><h2 id="使用-ConfigurationProperties-prefix-“user1”"><a href="#使用-ConfigurationProperties-prefix-“user1”" class="headerlink" title="使用@ConfigurationProperties(prefix = “user1”)"></a>使用@ConfigurationProperties(prefix = “user1”)</h2><p>使用了这个前缀绑定注解，就不能再使用spel表达式了</p><pre><code>@Data//get set方法@Component@PropertySource(value = &quot;classpath:users.properties&quot;,        ignoreResourceNotFound = false,encoding = &quot;UTF-8&quot;)@ConfigurationProperties(prefix = &quot;user1&quot;)public class Managers &#123;    private String name;    private String sex;    private int age;&#125;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>直接由Spring容器来getBean</li><li>本次测试没有使用id来getBean，而是直接通过字节码文件</li></ul><pre><code>    ConfigurableApplicationContext run = SpringApplication.run(BootAjaxtestApplication.class, args);        System.out.println(run.getBean(Managers.class).getName());    System.out.println(run.getBean(Managers.class).getAge());</code></pre><h1 id="二：使用一层配置类-解耦bean"><a href="#二：使用一层配置类-解耦bean" class="headerlink" title="二：使用一层配置类(解耦bean)"></a>二：使用一层配置类(解耦bean)</h1><ul><li>bean层的Managers类是一个不带额外功能的javaBean</li><li>BeanConfig类要@Configuration+@PropertySource+@Value+@Bean</li></ul><h2 id="JavaBean不进行注册"><a href="#JavaBean不进行注册" class="headerlink" title="JavaBean不进行注册"></a>JavaBean不进行注册</h2><pre><code>@Data//get set方法public class Managers &#123;    private String name;    private String sex;    private int age;&#125;</code></pre><h2 id="BeanConfig类中完成绑定"><a href="#BeanConfig类中完成绑定" class="headerlink" title="BeanConfig类中完成绑定"></a>BeanConfig类中完成绑定</h2><pre><code>@Configuration@PropertySource(value = &quot;classpath:users.properties&quot;,        ignoreResourceNotFound = false,        encoding = &quot;UTF-8&quot;)public class BeanConfig &#123;    @Value(&quot;$&#123;user1.name&#125;&quot;)    private String name;    @Value(&quot;$&#123;user1.sex&#125;&quot;)    private String sex;    @Value(&quot;$&#123;user1.age&#125;&quot;)    private int age;    @Bean(&quot;user1&quot;)    @Scope(&quot;singleton&quot;)    public Managers getManager()&#123;        Managers managers = new Managers();        managers.setAge(age);        managers.setName(name);        managers.setSex(sex);        return managers;    &#125;&#125;</code></pre><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><pre><code>        ConfigurableApplicationContext run = SpringApplication.run(BootAjaxtestApplication.class, args);//因为bean已经在容器中了，所以这样getBean始终成立        System.out.println(run.getBean(Managers.class).getName());        System.out.println(run.getBean(Managers.class).getAge());//获取 Spring上下文(该配置类容器)，从中getBean        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(BeanConfig.class);        Managers user1 = ac.getBean(&quot;user1&quot;, Managers.class);        System.out.println(user1.getName());        System.out.println(user1.getAge());</code></pre><h1 id="三：使用两层配置类-解耦配置与绑定"><a href="#三：使用两层配置类-解耦配置与绑定" class="headerlink" title="三：使用两层配置类(解耦配置与绑定)"></a>三：使用两层配置类(解耦配置与绑定)</h1><ul><li>BeanConfig是非核心配置类，不加@Configuration</li><li>AllBeansConfig是核心配置类，要加@Configuration</li><li><strong>配置@Value在非核心配置类中；而绑定配置文件@PropertySource在核心配置类中</strong></li></ul><h2 id="JavaBean不进行注册-1"><a href="#JavaBean不进行注册-1" class="headerlink" title="JavaBean不进行注册"></a>JavaBean不进行注册</h2><pre><code>@Data//get set方法public class Managers &#123;    private String name;    private String sex;    private int age;&#125;</code></pre><h2 id="BeanConfig非核心配置类：属性绑定"><a href="#BeanConfig非核心配置类：属性绑定" class="headerlink" title="BeanConfig非核心配置类：属性绑定"></a>BeanConfig非核心配置类：属性绑定</h2><pre><code>public class BeanConfig &#123;    @Value(&quot;$&#123;user1.name&#125;&quot;)    private String name;    @Value(&quot;$&#123;user1.sex&#125;&quot;)    private String sex;    @Value(&quot;$&#123;user1.age&#125;&quot;)    private int age;    @Bean(&quot;user1&quot;)    @Scope(&quot;singleton&quot;)    public Managers getManager()&#123;        Managers managers = new Managers();        managers.setAge(age);        managers.setName(name);        managers.setSex(sex);        return managers;    &#125;&#125;</code></pre><h2 id="AllBeanConfig核心配置类：文件绑定"><a href="#AllBeanConfig核心配置类：文件绑定" class="headerlink" title="AllBeanConfig核心配置类：文件绑定"></a>AllBeanConfig核心配置类：文件绑定</h2><ul><li>不光要绑定@PropertyResource</li><li>还要@Import({非核心配置类.class})</li></ul><p>绑定文件+导入非核心配置类：</p><pre><code>@Configuration@Import(BeanConfig.class)@PropertySource(value = &quot;classpath:users.properties&quot;,        ignoreResourceNotFound = false,        encoding = &quot;UTF-8&quot;)public class AllBeansConfig &#123;&#125;</code></pre><h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2><pre><code>//获取 Spring上下文(该配置类容器)，从中getBean        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AllBeansConfig.class);        Managers user1 = ac.getBean(&quot;user1&quot;, Managers.class);        System.out.println(user1.getName());        System.out.println(user1.getAge());</code></pre><h1 id="PropertySources和-PropertySource"><a href="#PropertySources和-PropertySource" class="headerlink" title="@PropertySources和@PropertySource"></a>@PropertySources和@PropertySource</h1><p>@PropertySources注解表示：可以在该配置类中绑定多个配置文件，同时这也说明了为什么可以用两层or三层配置类来配置Bean：</p><p>每层配置都像一个集合，大集合包括小集合，在配置信息繁多的情况下可读性更强<br><img src="https://img-blog.csdnimg.cn/1d0f2c1986f543a2b22b0f15e392ae47.png"></p><h1 id="补：-Value-spel表达式的两种方式"><a href="#补：-Value-spel表达式的两种方式" class="headerlink" title="补：@Value+spel表达式的两种方式"></a>补：@Value+spel表达式的两种方式</h1><h2 id="1-分开写"><a href="#1-分开写" class="headerlink" title="1.分开写"></a>1.分开写</h2><pre><code>@Value(&quot;$&#123;user1.name&#125;&quot;)private String name;@Value(&quot;$&#123;user1.sex&#125;&quot;)private String sex;@Value(&quot;$&#123;user1.age&#125;&quot;)private int age;</code></pre><h2 id="2-形参中耦合"><a href="#2-形参中耦合" class="headerlink" title="2.形参中耦合"></a>2.形参中耦合</h2><p><img src="https://img-blog.csdnimg.cn/80eee6c0d9924be8a503b4a5151b9d83.png"></p><h1 id="补：AnnotationConfigApplicationContext获得容器"><a href="#补：AnnotationConfigApplicationContext获得容器" class="headerlink" title="补：AnnotationConfigApplicationContext获得容器"></a>补：AnnotationConfigApplicationContext获得容器</h1><p>Spring的配置由基于XML，逐渐演变为基于注解，常用的应用程序上下文也由ClassPathXmlApplicationContext转为AnnotationConfigApplicationContext但基本流程都是一样的。</p><ul><li>一个应用上下文就是一个容器，每个容器有各自的Bean，但他们都能直接被Spring的容器直接获取</li><li>@Configuration注解正是代替的xml配置中的&lt;Beans&gt;标签，<strong>因此每个@Configuration配置类都是一个容器</strong></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>@PropertySource有4个参数value、 ignoreResourceNotFound 、encoding、name</li><li>1.在Bean类中直接 配置+注入，<strong>解耦了数据写死的情况</strong></li><li>2.用@Configuration+@Bean配置，可以在一个配置类中<strong>注入多个同类型的Bean</strong></li><li>3.非核心配置类+核心配置类，可以<strong>归类某几种类型相似的Bean</strong></li><li>@ConfigurationProperties(prefix = “user1”)使用后自动匹配属性，不能写spel表达式</li><li>@PropertySource总是在最外层，@PropertySources多配置注解，解释了为何可以进行配置类分层</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cannot find method ‘value‘(lombok冲突)</title>
      <link href="/zjh/2022/03/07/Cannot-find-method-%E2%80%98value%E2%80%98-lombok%E5%86%B2%E7%AA%81/"/>
      <url>/zjh/2022/03/07/Cannot-find-method-%E2%80%98value%E2%80%98-lombok%E5%86%B2%E7%AA%81/</url>
      
        <content type="html"><![CDATA[<p>@Value Cannot find method ‘value‘(lombok冲突)</p><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><p>Cannot find method ‘value’<br><img src="https://img-blog.csdnimg.cn/16024ccd73bd46c0adbc0a98256acdc5.png">因为一开始顺手@Data，idea自动导入了lombok.Data的包；<br>之后想使用@Value，idea自动导入了lombok下的Value包</p><p>但实际上我想使用的是@Value读取配置值，所以应该导入的是SpringFramework下的包</p><p><img src="https://img-blog.csdnimg.cn/6b54d7ee059641fcb7dc4ec0d4ebf24d.png"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>删除<br>import lombok.Data;<br>import lombok.Value;</p><p>重新利用idea导包</p><p><img src="https://img-blog.csdnimg.cn/c6249372e9d44ce0bef3aa88f4b1bd20.png" alt="导入这个包"><br>之后就可以正常使用了</p><p><img src="https://img-blog.csdnimg.cn/fcb228f8ebbf4822be8eb1f7c767327c.png"></p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList源码中为何大量出现final</title>
      <link href="/zjh/2022/02/21/LinkedList%E6%BA%90%E7%A0%81%E4%B8%AD%E4%B8%BA%E4%BD%95%E5%A4%A7%E9%87%8F%E5%87%BA%E7%8E%B0final/"/>
      <url>/zjh/2022/02/21/LinkedList%E6%BA%90%E7%A0%81%E4%B8%AD%E4%B8%BA%E4%BD%95%E5%A4%A7%E9%87%8F%E5%87%BA%E7%8E%B0final/</url>
      
        <content type="html"><![CDATA[<h1 id="源码中出现final的地方"><a href="#源码中出现final的地方" class="headerlink" title="源码中出现final的地方"></a>源码中出现final的地方</h1><ul><li>所有的link有关的方法（增删操作）add remove</li><li>需要保存中间变量的节点（prev和next指针需要修改的节点）</li><li>像clear get这种不涉及“更改指针指向”的方法不需要对中间变量定义final</li></ul><p><img src="https://img-blog.csdnimg.cn/8205fb2b21234a24a8f79d42bc9ca406.png" alt="linkFirst"><br><img src="https://img-blog.csdnimg.cn/e59b57429ad34923b07be9a51fda4c53.png" alt="unlink"></p><h1 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h1><p><a href="https://www.cnblogs.com/chhyan-dream/p/10685878.html">final关键字的作用</a><br><img src="https://img-blog.csdnimg.cn/1b4bfe04d9a54f7ba8de7ee622f9b5a7.png"></p><p>LinkedList中Node是一个对象，因此适用于第二条<strong>引用数据类型</strong>，举个例子：</p><h2 id="有无final修饰的浅拷贝"><a href="#有无final修饰的浅拷贝" class="headerlink" title="有无final修饰的浅拷贝"></a>有无final修饰的浅拷贝</h2><pre><code>People p1 = new People(18,&quot;张三&quot;);People p2 = p1;</code></pre><ol><li><p>当：p1 = null;或者p1 = new People(20,”李四”);<br>实际上是栈中的p1存储的地址改变，但堆空间中之前 new People(18,”张三”);的对象仍然存在。因此p2不受影响</p></li><li><p>当：p1.setAge(21); 此时操作的是堆空间中的唯一对象，p2会受到影响</p></li></ol><p>在源码中：</p><pre><code>    final E element = x.item;    final Node&lt;E&gt; next = x.next;    final Node&lt;E&gt; prev = x.prev;</code></pre><p>使得element  next    prev三个属性<strong>栈空间保存的地址不可再被重定向</strong>，但可以修改值，例如：next.prev = prev和prev.next=next <strong>可以对栈所指向的堆成员变量进行修改</strong></p><h1 id="使用final初始化的优点"><a href="#使用final初始化的优点" class="headerlink" title="使用final初始化的优点"></a>使用final初始化的优点</h1><p>参考链接：</p><p><a href="https://www.cnblogs.com/noteless/p/10416678.html">https://www.cnblogs.com/noteless/p/10416678.html</a><br><a href="https://www.cnblogs.com/noteless/p/10410368.html">https://www.cnblogs.com/noteless/p/10410368.html</a><br><a href="https://www.cnblogs.com/mianlaoshu/articles/3648403.html">https://www.cnblogs.com/mianlaoshu/articles/3648403.html</a><br><a href="https://www.cnblogs.com/maxiaopao/p/9212903.html">https://www.cnblogs.com/maxiaopao/p/9212903.html</a><br><a href="https://zhuanlan.zhihu.com/p/88775601">https://zhuanlan.zhihu.com/p/88775601</a><br><a href="https://www.zhihu.com/question/21762917/answer/19239387">https://www.zhihu.com/question/21762917/answer/19239387</a><br>第四条链接中讲final的优点很详细<br>第五条讲到了重排序<br>第六条是JVM对方法中的final变量性能调优</p><h2 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h2><ul><li>LinkedList本身是不安全，但这并不影响，因为每次事务初始化的都不是同一个Node对象，如果多线程并发并同时add，那么即便是源码定义了final，也可能会出现错误，因此LinkedList在并发场景下需要自行同步</li><li><strong>但多线程并发对于方法中局部变量是不存在冲突的</strong></li><li><strong>排除安全性的可能</strong></li></ul><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><ul><li><strong>在能够通过编译的前提下，无论局部变量声明时带不带final关键字修饰，对其访问的效率都一样。</strong></li><li>既然一样，那性能上没影响了。排除</li></ul><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>参考阿里巴巴的开发手册<br><img src="https://img-blog.csdnimg.cn/6039ed0d6c4c41f0b0dccf8451657ef2.png"><br>不允许修改的局部变量声明为final更多的是一种规范，在实质作用上加与不加没有区别，但他就是个规范。<strong>排除任何可能对这个变量进行修改的可能性</strong></p><p>本问题花了我14个小时，查阅了无数资料，问了无数的人，最后能总结出来的答案就是：规范<br>hhhh浪费了我一天的宝贵时间</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>方法内部初始化的final变量是局部变量</li><li>没有多线程冲突问题</li><li>局部静态基本数据变量定义final才有JVM优化，而引用类型则没有</li><li>final可以避免误操作可能带来的问题，因此对所有不会修改的局部变量都用final定义</li><li>LikedList仍然是线程不安全的，需要手动上锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LinkedList中clear和unlink方法为什么要多次置空</title>
      <link href="/zjh/2022/02/20/LinkedList%E4%B8%ADclear%E5%92%8Cunlink%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%9A%E6%AC%A1%E7%BD%AE%E7%A9%BA/"/>
      <url>/zjh/2022/02/20/LinkedList%E4%B8%ADclear%E5%92%8Cunlink%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%9A%E6%AC%A1%E7%BD%AE%E7%A9%BA/</url>
      
        <content type="html"><![CDATA[<p>今天在看LinkedList源码的时候发现clear和unlink源码都对Node的前后和itme进行了<strong>分别置空</strong>，我之前的想法是直接把所有的Node本身直接置空，x.prev=null和x.next=null，直接x = null也可以使得所有节点为空啊</p><p>但在参考了很多资料后发现，如果单纯的x=null而不x.prev=null和x.next=null，可能不会正常触发GC，事情远远没有那么简单……</p><p>阅读本文需要有JVM垃圾回收机制的知识储备</p><p>参考资料：<br><a href="https://www.iteye.com/problems/71569">https://www.iteye.com/problems/71569</a><br><a href="https://www.bilibili.com/video/BV1AE411E7uj?p=1">https://www.bilibili.com/video/BV1AE411E7uj?p=1</a><br><a href="https://www.bilibili.com/video/BV1yE411Z7AP?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1yE411Z7AP?spm_id_from=333.999.0.0</a><br><a href="https://www.cnblogs.com/chenpt/p/9803298.html">https://www.cnblogs.com/chenpt/p/9803298.html</a><br><a href="https://www.iteye.com/problems/71569">https://www.iteye.com/problems/71569</a><br><a href="https://codingdict.com/questions/113892">https://codingdict.com/questions/113892</a><br><a href="https://www.cnblogs.com/dmzna/archive/2020/05/18/12913458.html">https://www.cnblogs.com/dmzna/archive/2020/05/18/12913458.html</a><br><a href="https://www.cnblogs.com/shouyaya/p/13524476.html">https://www.cnblogs.com/shouyaya/p/13524476.html</a><br><a href="https://blog.csdn.net/mccand1234/article/details/52078645">https://blog.csdn.net/mccand1234/article/details/52078645</a><br><a href="https://blog.csdn.net/qq_41701956/article/details/81664921">https://blog.csdn.net/qq_41701956/article/details/81664921</a><br><a href="https://blog.csdn.net/yubujian_l/article/details/80804708">https://blog.csdn.net/yubujian_l/article/details/80804708</a></p><h1 id="例如clear的源码"><a href="#例如clear的源码" class="headerlink" title="例如clear的源码"></a>例如clear的源码</h1><p><img src="https://img-blog.csdnimg.cn/2569150ae8b14450b59c58678e2c33d1.png"><br>x.next = null，即表示下一个节点对象=null，为什么还要分成3步写来把属性=null呢？为什么不仅仅是把首尾节点=null让链表找不到入口呢？</p><h1 id="注释翻译："><a href="#注释翻译：" class="headerlink" title="注释翻译："></a>注释翻译：</h1><ul><li><pre><code>is sure to free memory even if there is a reachable Iterator 即便是有迭代器指针此时正在访问中间的节点，也会置空。</code></pre></li><li>helps a generational GC if the discarded nodes inhabit more than one generation有多个节点时，这样做有助于GC垃圾回收</li></ul><h2 id="注解解读："><a href="#注解解读：" class="headerlink" title="注解解读："></a>注解解读：</h2><h3 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h3><p>如果仅仅是把首尾置空，中间的链表虽然找不到首尾入口，但若此时：</p><ul><li>有迭代器正好访问到中间，取到了中间的node对象</li><li>中间的某个node已被<strong>强引用</strong></li></ul><h3 id="第二个"><a href="#第二个" class="headerlink" title="第二个"></a>第二个</h3><p>倘若JDK版本在8以上，可以忽略这一条，但老版本的gc机制，所用的垃圾收集器可能使用的算法是<strong>引用计数器算法</strong>，该算法不能解决相互引用情况下的垃圾回收</p><p>例如：没有迭代器访问，中间节点对象也没有被强引用，但是他们之间是互相调用的，引用计数器算法不能回收这样的对象，即便是他们没有入口</p><p>而在JDK的流行高版本中一般不使用引用计数器算法，而使用可达性分析算法，当他们都没有被强引用时，便没有了GC Roots根对象，因此会被垃圾回收，但引用计数器算法也并未被淘汰，在著名的单进程高并发缓存Redis中依然采用这种算法来进行内存回收</p><p>综上：第二个注释“<strong>help GC</strong>”所表达的含义是防止因为JDK版本低，垃圾回收算法所导致的“无法回收循环引用”的情况</p><p>同样 对于remove方法调用了unlink，注解也说了help GC<br><img src="https://img-blog.csdnimg.cn/b8137bccbd6943c69eaa21c3a5343348.png"></p>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gc垃圾回收机制</title>
      <link href="/zjh/2022/02/20/gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/zjh/2022/02/20/gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>参考链接：<br><a href="https://www.bilibili.com/video/BV1AE411E7uj?p=1">https://www.bilibili.com/video/BV1AE411E7uj?p=1</a><br><a href="https://www.bilibili.com/video/BV1yE411Z7AP?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1yE411Z7AP?spm_id_from=333.999.0.0</a><br><a href="https://www.cnblogs.com/chenpt/p/9803298.html">https://www.cnblogs.com/chenpt/p/9803298.html</a><br><a href="https://www.iteye.com/problems/71569">https://www.iteye.com/problems/71569</a><br><a href="https://codingdict.com/questions/113892">https://codingdict.com/questions/113892</a><br><a href="https://www.cnblogs.com/dmzna/archive/2020/05/18/12913458.html">https://www.cnblogs.com/dmzna/archive/2020/05/18/12913458.html</a><br><a href="https://www.cnblogs.com/shouyaya/p/13524476.html">https://www.cnblogs.com/shouyaya/p/13524476.html</a><br><a href="https://blog.csdn.net/mccand1234/article/details/52078645">https://blog.csdn.net/mccand1234/article/details/52078645</a><br><a href="https://blog.csdn.net/qq_41701956/article/details/81664921">https://blog.csdn.net/qq_41701956/article/details/81664921</a><br><a href="https://blog.csdn.net/yubujian_l/article/details/80804708">https://blog.csdn.net/yubujian_l/article/details/80804708</a></p><h1 id="补-运行时数据区"><a href="#补-运行时数据区" class="headerlink" title="补:运行时数据区"></a>补:运行时数据区</h1><p><img src="https://img-blog.csdnimg.cn/82bc155c3ade45cca26dbad5798bd46c.png"></p><h2 id="补-程序计数器"><a href="#补-程序计数器" class="headerlink" title="补:程序计数器"></a>补:程序计数器</h2><p>为了<strong>保证程序（在操作系统中理解为进程）能够连续地执行下去</strong>，处理器必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器。在程序开始执行前，必须将它的起始地址，即程序的第一条指令所在的内存单元地址送入程序计数器，因此程序计数器的内容即是从内存提取的一条指令的地址。当执行指令时，处理器将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。<br>但是，当遇到转移指令如JMP（跳转、外语全称：JUMP）指令时，后继指令的地址（即PC的内容）必须从指令寄存器中的地址字段取得。在这种情况下，下一条从内存取出的指令将由转移指令来规定，而不像通常一样按顺序来取得。因此程序计数器的结构应当是具有寄存信息和计数两种功能的结构。<br><strong>这一部分不会发生内存泄漏</strong>，程序计数器指令可以标记<strong>if for 多线程</strong>等“<strong>运行到哪里”</strong>  通常又称之为‘指令计数器’</p><h2 id="补-JVM堆空间（gc堆）"><a href="#补-JVM堆空间（gc堆）" class="headerlink" title="补:JVM堆空间（gc堆）"></a>补:JVM堆空间（gc堆）</h2><ul><li>存放: 对象实例 and  数组</li><li>每次new操作都是在堆中开辟空间，不一定是连续的空间，</li><li>堆空间的分配常用分代策略（新生代 老年代 永久代（现：元空间））</li></ul><h1 id="补-垃圾回收的流程"><a href="#补-垃圾回收的流程" class="headerlink" title="补:垃圾回收的流程"></a>补:垃圾回收的流程</h1><p>以分代机制+回收算法+G1垃圾收集器为例：</p><ul><li><strong>G1垃圾收集器</strong>决定了：垃圾回收的cpu资源调度方式是并发兼顾延迟和吞吐量，分堆；能结合多种算法策略，是一个监视者的角色。</li><li>回收算法决定了：xx对象在本轮回收中是否被回收，如强引用则不回收，其他引用回收策略不同</li><li>分代机制决定了：什么时候调用垃圾回收，如新生代区的Eden满后调用Minor GC</li><li>过程：不停的new，因为引用方式不同and对象大小不同，会导致不同的对象分在了元空间(相当于JDK8之前的永久代)、新生代(Eden满后Minor GC)、老年代(System.gc()或老年代区满后Full GC)<br>————因为垃圾回收器的区别，如G1会动态监控并标记GC Roots，调用回收算法<br>————进行可达性分析，决定对象的去留<br>————调用Full GC来进行垃圾回收，释放内存</li></ul><h1 id="JVM如何判定一个对象是否应该被回收"><a href="#JVM如何判定一个对象是否应该被回收" class="headerlink" title="JVM如何判定一个对象是否应该被回收?"></a>JVM如何判定一个对象是否应该被回收?</h1><h2 id="1-引用计数器算法×"><a href="#1-引用计数器算法×" class="headerlink" title="1.引用计数器算法×"></a>1.引用计数器算法×</h2><p>方法内容：<br>对象被引用一次，计数器+1；失效一次，计数器-1，计数器归零后失效</p><p><strong>不能解决互相引用</strong>情况下的垃圾回收问题，例如：LinkedList源码中clear方法和unLinked方法需要多步操作<strong>来消除循环引用</strong></p><h2 id="2-可达性分析算法√"><a href="#2-可达性分析算法√" class="headerlink" title="2.可达性分析算法√"></a>2.可达性分析算法√</h2><p>在Java C＃中的主流算法<br>算法思想：<br>通过一些列成为“GC Roots”的<strong>根对象</strong>作为起始点，如果一条引用链的起始点不是GC Roots，那么就会被垃圾回收（<strong>不是强引用就会被垃圾回收，只是时间问题</strong>）<br>GC Roots包括：</p><ol><li>虚拟机栈中引用的对象</li><li>方法区静态属性引用的对象</li><li>方法区常量引用的对象</li><li>本地方法引用的对象（底层是c或操作系统语言）<br><img src="https://img-blog.csdnimg.cn/dc4ad3fb230748bf8f14980cbcbf1449.png" alt="打圈的会被回收"><h3 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h3>这其实是一个相对的概念，在调用Minor GC的时候，老年代就是根对象<br>像上面的那4种是“即使Full GC”也不会回收的，就是绝对的根对象</li></ol><h2 id="补充：引用的四种方式："><a href="#补充：引用的四种方式：" class="headerlink" title="补充：引用的四种方式："></a>补充：引用的四种方式：</h2><p><a href="https://blog.csdn.net/linzhiqiang0316/article/details/88591907?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.pc_relevant_default&spm=1001.2101.3001.4242.1&utm_relevant_index=2">参考链接</a></p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>Object obj = new Object();强引用在，垃圾收集器就一直不会被回收该对象，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。</p><h3 id="软引用SoftReference"><a href="#软引用SoftReference" class="headerlink" title="软引用SoftReference"></a>软引用SoftReference</h3><p>SoftReference aSoftRef=new SoftReference(obj);如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；软引用可用来实现内存敏感的高速缓存，<strong>一旦垃圾线程回收该Java对象之 后，get()方法将返回null</strong></p><p><img src="https://img-blog.csdnimg.cn/5c02dfba92cc4a4ca626b50c48ea0369.png"></p><h3 id="弱引用WeakReference"><a href="#弱引用WeakReference" class="headerlink" title="弱引用WeakReference"></a>弱引用WeakReference</h3><p>创建方法和WeakReference 相同，但比SoftReference更弱，<strong>仅仅能生存到下次垃圾回收之前</strong>，无论内存是否足够 都会回收</p><pre><code>    People people=new People(&quot;zjh&quot;,21);      WeakReference&lt;People&gt;reference=new WeakReference&lt;People&gt;(people);    System.out.println(reference.get());  //zjh 21    System.gc();      System.out.println(reference.get()); //null</code></pre><h3 id="虚引用PhantomReference"><a href="#虚引用PhantomReference" class="headerlink" title="虚引用PhantomReference"></a>虚引用PhantomReference</h3><p>最弱的引用关系，虚引用主要用来<strong>跟踪</strong>对象被垃圾回收的活动，在回收之前通知系统，但<strong>不影响对象的生命周期</strong>。</p><h1 id="JVM垃圾回收算法有哪些？"><a href="#JVM垃圾回收算法有哪些？" class="headerlink" title="JVM垃圾回收算法有哪些？"></a>JVM垃圾回收算法有哪些？</h1><ul><li>以下三种方法，在实际的虚拟机中是组合使用，去其糟粕，取其精华</li><li>垃圾回收算法 和 回收机制不同</li></ul><h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><p>标记不连续，可用内存被分割，在申请连续大空间时可能没有可用的内存，资源浪费大<br><img src="https://img-blog.csdnimg.cn/592240b2bc514b7ea211e3fa194d9f16.png"></p><h2 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h2><p>标记的同时把可用对象整理在一起</p><p><img src="https://img-blog.csdnimg.cn/53fe5484d0554b6db22d524888041867.png"></p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>局限性很大，内存利用率很差，先复制可用存活对象复制到一块区域</p><p><img src="https://img-blog.csdnimg.cn/87e917f8d1b8489e8fcc834e22e1a41a.png">右边这块的内存都是不能使用的</p><p><a href="https://www.cnblogs.com/dmzna/archive/2020/05/18/12913458.html">参考链接</a></p><h1 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h1><ul><li>回收机制≠回收算法</li><li>常用的是<strong>分代回收策略</strong></li><li>一般是只要<strong>空间不足就触发</strong>垃圾回收机制<h2 id="代的划分"><a href="#代的划分" class="headerlink" title="代的划分"></a>代的划分</h2></li></ul><p><img src="https://img-blog.csdnimg.cn/3c26182da16a4119a79f012073d0e2d1.png"></p><p><a href="https://blog.csdn.net/mccand1234/article/details/52078645">参考链接1</a><br><a href="https://www.cnblogs.com/jichi/p/12580906.html">参考链接2</a></p><p>商用Java内存分配和回收的机制概括的说，就是：<strong>分代分配，分代回收</strong>。</p><ul><li>对象将根据<strong>存活的时间</strong>被分为：<br>年轻代（Young Generation）：<strong>回收频率快</strong><br>年老代（Old Generation）：<strong>回收频率慢</strong><br>永久代（Permanent Generation，也就是方法区，JDK1.8之后删除了永久代）</li><li>不同代有不同的算法，不同的处理机制</li><li>内存担保机制：新生代到老年代</li></ul><h3 id="新生代的三个分区8-1-1"><a href="#新生代的三个分区8-1-1" class="headerlink" title="新生代的三个分区8:1:1"></a>新生代的三个分区8:1:1</h3><p>Eden伊甸园:From幸存区:To幸存区=8：1：1<br>From是上一次幸存的对象<br>To是本次幸存的对象</p><ul><li>new一个对象，默认采用伊甸园的空间，<strong>大对象则直接到老年代</strong></li><li>一直new直到伊甸园空间放不够了就触发<strong>新生代垃圾回收Minor GC</strong></li><li>直到连老年代都快满了，触发<strong>老年代垃圾回收Full GC</strong></li></ul><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><ul><li><strong>触发</strong>了Minor GC之后就调用<strong>垃圾回收算法</strong>（标记清除、标记整理、复制算法）</li><li>例如调用了标记算法，就把标记存活的对象复制到幸存区To中，<strong>寿命计数器+1</strong>；而被标记回收的伊甸园对象则被回收</li><li>伊甸园再次空闲，直到下次满的时候<strong>触发第二次Minor GC</strong></li><li>寿命计数器&gt;15(4bit)时(可能因为新生代空间严重不足而提前晋升)，对象从新生代传入老年代，此后不会被Minor GC回收</li><li><strong>会触发STW，但耗时短</strong><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3></li><li>新生代老年代<strong>同时进行垃圾回收</strong></li><li><strong>会触发STW，且耗时长</strong></li><li>调用System.gc()</li></ul><h2 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h2><ul><li>stop thr world 当触发STW时，其他的所有线程都停止，直到垃圾回收完成</li><li>因此回收效率高，但会有停顿时间，适合在Client端使用，不适合在Sever端使用</li><li>Minor GC 和 Full GC都会触发STW</li></ul><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>JVM中的垃圾收集器主要包括7种，即Serial，Serial Old，ParNew，Parallel Scavenge，Parallel Old以及CMS，G1收集器。<br><img src="https://img-blog.csdnimg.cn/3107e1c7f6c44dc59dd32dba530ca563.png"></p><h2 id="G1——Garbage-one"><a href="#G1——Garbage-one" class="headerlink" title="G1——Garbage one"></a>G1——Garbage one</h2><ul><li><strong>取代CMS</strong>垃圾回收器</li><li>出自JDK7，JDK9之后成为<strong>默认</strong>的垃圾回收器</li><li><strong>并发</strong></li><li><strong>同时注重吞吐量和响应时间</strong></li><li>适合于超大内存场景，<strong>会将堆均匀分区以便并发</strong>，每个区都有独立的年轻代、老年代堆区域</li><li>CMS和G1都是<strong>Full GC</strong>(老年代垃圾回收机制)<br><img src="https://img-blog.csdnimg.cn/4038af9659a6445fb1f3391d9633622b.png"></li></ul><h2 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h2><ul><li>单线程</li><li>堆内存小，适合个人电脑</li></ul><h2 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h2><ul><li>多线程</li><li>堆内存大，需要多核CPU支持（真并发），适合服务器</li><li>一次大量回收，<strong>单位时间STW时间尽可能短</strong>，总时间更短</li></ul><h2 id="响应时间有限"><a href="#响应时间有限" class="headerlink" title="响应时间有限"></a>响应时间有限</h2><ul><li>多线程</li><li>堆内存大，需要多核CPU支持（真并发），适合服务器</li><li>单次少量回收，<strong>单次STW时间尽可能短</strong>，每次影响更小</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>外部jar包的引入和打包</title>
      <link href="/zjh/2022/02/15/%E5%A4%96%E9%83%A8jar%E5%8C%85%E7%9A%84%E5%BC%95%E5%85%A5%E5%92%8C%E6%89%93%E5%8C%85/"/>
      <url>/zjh/2022/02/15/%E5%A4%96%E9%83%A8jar%E5%8C%85%E7%9A%84%E5%BC%95%E5%85%A5%E5%92%8C%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="下载jar包并导入"><a href="#下载jar包并导入" class="headerlink" title="下载jar包并导入"></a>下载jar包并导入</h1><p>一般是在maven网站上直接搜索需要的jar包下载，并在pom中导入依赖</p><p><img src="https://img-blog.csdnimg.cn/3a4ff0af536445c0989a73a412a37678.png">有时候需要添加systemPath来指定jar包的位置，让springboot引用</p><p>fastjson，因为是maven中下载的包，<strong>所以要指定scope和systemPath</strong></p><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;        &lt;version&gt;1.2.75&lt;/version&gt;        &lt;scope&gt;system&lt;/scope&gt;        &lt;systemPath&gt;$&#123;pom.basedir&#125;/src/main/resources/lib/fastjson-1.2.75.jar&lt;/systemPath&gt;    &lt;/dependency&gt;</code></pre><p>pom.basedir还有project.basedir 也有直接basedir，具体出了问题搜bug就好<br><a href="https://blog.csdn.net/qq_39132177/article/details/109023743?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164491100016781685372508%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164491100016781685372508&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-109023743.pc_search_result_control_group&utm_term=pom.basedir%E5%92%8Cproject.basedir&spm=1018.2226.3001.4187">Maven: Maven的六类属性</a></p><p>下载好的jar包放在设置为resources的包下，一般是另外在下面建立一个lib表示外部导入<br><img src="https://img-blog.csdnimg.cn/9a2754b4c5b647c3a5b8a45ab1ed00c2.png" alt="下载好的jar"></p><h1 id="pom配置打包环境"><a href="#pom配置打包环境" class="headerlink" title="pom配置打包环境"></a>pom配置打包环境</h1><p>注意<strong>依赖和插件</strong>是加在不同地方的</p><h2 id="依赖-lt-dependencies-gt-中"><a href="#依赖-lt-dependencies-gt-中" class="headerlink" title="依赖&lt;dependencies&gt;中"></a>依赖&lt;dependencies&gt;中</h2><pre><code>&lt;!--maven打包插件--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;2.6.3&lt;/version&gt;        &lt;/dependency&gt;&lt;!--maven默认插件，用于编译源码--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;            &lt;version&gt;3.8.1&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h2 id="插件-lt-build-gt-中"><a href="#插件-lt-build-gt-中" class="headerlink" title="插件&lt;build&gt;中"></a>插件&lt;build&gt;中</h2><p>忽视lombok插件</p><pre><code>&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;                &lt;excludes&gt;                    &lt;exclude&gt;                        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                        &lt;artifactId&gt;lombok&lt;/artifactId&gt;                    &lt;/exclude&gt;                &lt;/excludes&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>解释：</p><ul><li><p>spring-boot-maven-plugin是打包插件，<strong>引入这个插件之后用maven打包出来的jar包才是可执行的完整jar包</strong></p></li><li><p>而includeSystemScope&gt;true&lt;/includeSystemScope是<strong>设置打包的时候是否包括外部引入的jar包</strong></p><pre><code>  &lt;build&gt;      &lt;plugins&gt;          &lt;plugin&gt;              &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;              &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;              &lt;configuration&gt;                  &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt;                  &lt;excludes&gt;                      &lt;exclude&gt;                          &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                          &lt;artifactId&gt;lombok&lt;/artifactId&gt;                      &lt;/exclude&gt;                  &lt;/excludes&gt;              &lt;/configuration&gt;          &lt;/plugin&gt;      &lt;/plugins&gt;  &lt;/build&gt;</code></pre></li></ul><h1 id="外部引入jar包"><a href="#外部引入jar包" class="headerlink" title="外部引入jar包"></a>外部引入jar包</h1><p>这里以阿里的fastJson为例<br><img src="https://img-blog.csdnimg.cn/e8289d1b669640ceb709e11c0cea7e2e.png"><br>同时，需要在pom中引入依赖</p><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;        &lt;version&gt;1.2.75&lt;/version&gt;        &lt;scope&gt;system&lt;/scope&gt;        &lt;systemPath&gt;$&#123;pom.basedir&#125;/src/main/resources/lib/fastjson-1.2.75.jar&lt;/systemPath&gt;    &lt;/dependency&gt;</code></pre><p>注意：</p><ul><li>scope&gt;system&lt;/scope必须设置system，这里和上面的includeSystemScope&gt;true&lt;/includeSystemScope呼应</li><li>systemPath&gt;${pom.basedir}/src/main/resources/lib/fastjson-1.2.75.jar&lt;/systemPath中的路径必须指明引入的jar包</li></ul><h1 id="clean-package"><a href="#clean-package" class="headerlink" title="clean package"></a>clean package</h1><p>打包之后，点开jar包<br><img src="https://img-blog.csdnimg.cn/3de292498eda49b18388da2934d0ec98.png" alt="打包之后"></p><p>搜索lib<br><img src="https://img-blog.csdnimg.cn/e3a21d2529674a099e53caf6a7a0f931.png" alt="在jar包中找到了fastJson包"></p>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bean的配置，注入，操作，校验</title>
      <link href="/zjh/2022/02/15/Bean%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%8C%E6%B3%A8%E5%85%A5%EF%BC%8C%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%A0%A1%E9%AA%8C/"/>
      <url>/zjh/2022/02/15/Bean%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%8C%E6%B3%A8%E5%85%A5%EF%BC%8C%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="配置的规则"><a href="#配置的规则" class="headerlink" title="配置的规则"></a>配置的规则</h1><ul><li>尽量全都小写</li><li>支持松散绑定(小写数字下划线)</li><li>@Value不支持松散绑定<br><img src="https://img-blog.csdnimg.cn/5a36be72159744ecbc5ced8e2381b893.png" alt="application.yml"></li></ul><h1 id="注入的三种方式"><a href="#注入的三种方式" class="headerlink" title="注入的三种方式"></a>注入的三种方式</h1><p>同一个Bean只能有一个注入，多次注入会报错（Bean是单例的）</p><h2 id="Component注入"><a href="#Component注入" class="headerlink" title="@Component注入"></a>@Component注入</h2><p>1，config类</p><pre><code>@Component//加载配置属性必须先要受spring管控，先注入bean@Data//加载配置属性必须要有set@ConfigurationProperties(prefix = &quot;aliyossphoto&quot;)public class OSSphotoConfig &#123;    private String endpoint;    private String accessKeyId;    private String accessKeySecret;    private String bucketName;&#125;</code></pre><p>2，启动类<br>可以直接 run.getBean(OSSphotoConfig.class)</p><pre><code>@SpringBootApplicationpublic class BootAjaxtestApplication &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext run = SpringApplication.run(BootAjaxtestApplication.class, args);        OSSphotoConfig bean = run.getBean(OSSphotoConfig.class);        System.out.println(bean);        &#125;</code></pre><h2 id="Bean-ConfigurationProperties"><a href="#Bean-ConfigurationProperties" class="headerlink" title="@Bean + @ConfigurationProperties"></a>@Bean + @ConfigurationProperties</h2><p>1,config类不能注入@Component</p><pre><code>@Data//加载配置属性必须要有setpublic class OSSphotoConfig &#123;    private String endpoint;    private String accessKeyId;    private String accessKeySecret;    private String bucketName;&#125;</code></pre><p>2，启动类中需要@Bean注入，至于@ConfigurationProperties(prefix = “”)<br>    写在哪都可以，只要在config类或者启动类中有绑定即可</p><pre><code>@SpringBootApplicationpublic class BootAjaxtestApplication &#123;    @Bean    @ConfigurationProperties(prefix = &quot;aliyossphoto&quot;)    public OSSphotoConfig getbean()&#123;        OSSphotoConfig osSphotoConfig = new OSSphotoConfig();        return osSphotoConfig;    &#125;public static void main(String[] args) &#123;    ConfigurableApplicationContext run = SpringApplication.run(BootAjaxtestApplication.class, args);        OSSphotoConfig bean = run.getBean(OSSphotoConfig.class);        System.out.println(bean);        &#125;</code></pre><h2 id="EnableConfigurationProperties-class-class"><a href="#EnableConfigurationProperties-class-class" class="headerlink" title="@EnableConfigurationProperties({class,class})"></a>@EnableConfigurationProperties({class,class})</h2><ul><li>这个注解可以清晰的看见到底注入了什么Bean，同时与@Component冲突，也与@Bean冲突；不过<strong>需要在config类中进行配置绑定</strong></li><li>{}中利用反射，可以同时注入多个Bean</li></ul><p>1，config类</p><pre><code>@ConfigurationProperties(prefix = &quot;aliyossphoto&quot;)@Data//加载配置属性必须要有setpublic class OSSphotoConfig &#123;    private String endpoint;    private String accessKeyId;    private String accessKeySecret;    private String bucketName;&#125;</code></pre><p>2，启动类中</p><pre><code>@EnableConfigurationProperties(&#123;OSSphotoConfig.class&#125;)@SpringBootApplicationpublic class BootAjaxtestApplication &#123;public static void main(String[] args) &#123;    ConfigurableApplicationContext run = SpringApplication.run(BootAjaxtestApplication.class, args);    OSSphotoConfig bean = run.getBean(OSSphotoConfig.class);    System.out.println(bean);        &#125;&#125;</code></pre><h1 id="Bean的操作"><a href="#Bean的操作" class="headerlink" title="Bean的操作"></a>Bean的操作</h1><ul><li>run.getBean(xxx.class)获得的对象由于@Data的存在可以调用get set方法</li><li>获取属性值除了用get方法还可以用@Value(“${xx.xx}”)</li><li>在主类，测试类，MVC层都可以直接@Autowired获取，但在<strong>普通类需要使用工具类</strong></li></ul><h1 id="工具类实现ApplicationContextAware接口"><a href="#工具类实现ApplicationContextAware接口" class="headerlink" title="工具类实现ApplicationContextAware接口"></a>工具类实现ApplicationContextAware接口</h1><ul><li>任意找一个包下创建一个工具类，这个工具类可以通过反射获取bean，不需要通过@Autowired或@Bean即可在普通类中使用bean</li><li>并且这个工具类是通用的</li><li>使用的时候直接SpringContext.getBean(xxx.class)获取bean即可</li></ul><pre><code>    @Component    public class SpringContextUtil implements ApplicationContextAware &#123;    private static ApplicationContext applicationContext;    @Override    public void setApplicationContext(ApplicationContext context) throws     BeansException &#123;        applicationContext = context;    &#125;    //静态加载applicationContext    public static ApplicationContext getApplicationContext() &#123;        return applicationContext;    &#125;    //通过反射获取Bean    public static &lt;T&gt; T getBean(Class&lt;T&gt; requiredType)&#123;        return getApplicationContext().getBean(requiredType);    &#125;    //通过id名获取bean    public static &lt;T&gt; T getBean(String name)&#123;        return (T) getApplicationContext().getBean(name);    &#125;    &#125;</code></pre><h1 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h1><h1 id="单位的配置"><a href="#单位的配置" class="headerlink" title="单位的配置"></a>单位的配置</h1><p>@XxxxxUnit</p><h1 id="属性校验validation-validator"><a href="#属性校验validation-validator" class="headerlink" title="属性校验validation+validator"></a>属性校验validation+validator</h1><p>1，maven坐标，二者缺一不可<br>1,1 JSR303规范</p><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;javax.validation&lt;/groupId&gt;        &lt;artifactId&gt;validation-api&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><p>1,2 Hibernate validator属性校验器</p><pre><code>    &lt;dependency&gt;        &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;        &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><p>2，开启属性注入校验@Validated+@Max等</p><pre><code>@ConfigurationProperties(prefix = &quot;aliyossphoto&quot;)@Data//加载配置属性必须要有set@Validatedpublic class OSSphotoConfig &#123;  @Max(value = 200, message = &quot;最大值不超过200&quot;)  @Min(value = 0 , message = &quot;最小值不能低于0&quot;)  private Integer age;&#125;</code></pre><p>校验规则有很多，有具体需要的时候搜一下就好</p>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>普通类中调用Bean</title>
      <link href="/zjh/2022/02/15/%E6%99%AE%E9%80%9A%E7%B1%BB%E4%B8%AD%E8%B0%83%E7%94%A8Bean/"/>
      <url>/zjh/2022/02/15/%E6%99%AE%E9%80%9A%E7%B1%BB%E4%B8%AD%E8%B0%83%E7%94%A8Bean/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>@Autowired @Bean注入但是空指针异常</li><li>测试类中能获取，但普通类中空指针</li><li>需要在普通类中调用bean</li></ul><h1 id="Bean结构"><a href="#Bean结构" class="headerlink" title="Bean结构"></a>Bean结构</h1><p><img src="https://img-blog.csdnimg.cn/4e11edb32c7143d29c9a24204b5cee88.png" alt="yml"><br><img src="https://img-blog.csdnimg.cn/6b0d4d06be02405aa1f62619fad020b9.png" alt="bean类"></p><h1 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h1><p>这样的结构可以直接在@Controller层 @Service层 @Mapper层  @SpringBootApplication启动类中 @SpringBootTest测试类中<br>直接通过</p><pre><code>@Autowired private OSSphotoConfig osspc;</code></pre><p>来获取bean的实例，并且可以正常调用，但是这些调用方的类都不是普通类，有时需要在普通类中调用bean，通过@Autowired @Bean等方法注入都会失效，运行会报空指针异常，以下使用工具类解决这个问题</p><h1 id="工具类实现ApplicationContextAware接口"><a href="#工具类实现ApplicationContextAware接口" class="headerlink" title="工具类实现ApplicationContextAware接口"></a>工具类实现ApplicationContextAware接口</h1><ul><li>任意找一个包下创建一个工具类，这个工具类可以通过反射获取bean，不需要通过@Autowired或@Bean即可在普通类中使用bean</li><li>并且这个工具类是通用的</li></ul><pre><code>    @Component    public class SpringContexUtil implements ApplicationContextAware &#123;    private static ApplicationContext applicationContext;    @Override    public void setApplicationContext(ApplicationContext context) throws     BeansException &#123;        applicationContext = context;    &#125;    //静态加载applicationContext    public static ApplicationContext getApplicationContext() &#123;        return applicationContext;    &#125;    //通过反射获取Bean    public static &lt;T&gt; T getBean(Class&lt;T&gt; requiredType)&#123;        return getApplicationContext().getBean(requiredType);    &#125;    //通过id名获取bean    public static &lt;T&gt; T getBean(String name)&#123;        return (T) getApplicationContext().getBean(name);    &#125;    &#125;</code></pre><h1 id="在普通类中调用接口的静态方法获取bean"><a href="#在普通类中调用接口的静态方法获取bean" class="headerlink" title="在普通类中调用接口的静态方法获取bean"></a>在普通类中调用接口的静态方法获取bean</h1><p><img src="https://img-blog.csdnimg.cn/19bb9798ee0c4dadb408bb93be858b10.png"></p><p>用这种方法就不会报错了</p><p>引用一句话——“如果说BeanFactory是Spring的心脏，那么ApplicationContext就是完整的身躯了。ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。”</p>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>连接阿里云OSS，url转存OSS</title>
      <link href="/zjh/2022/02/15/%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91OSS/"/>
      <url>/zjh/2022/02/15/%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91OSS/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/f2c9c126b17045689c3a6cbeb4756a8c.png"></p><h1 id="核心连接数据绑定"><a href="#核心连接数据绑定" class="headerlink" title="核心连接数据绑定"></a>核心连接数据绑定</h1><h2 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h2><pre><code>public class OSSnxbPhoto &#123;//以下配置也可以直接写进方法中，写这里算全局配置           public static String endpoint = &quot;https://oss-cn-shanghai.aliyuncs.com&quot;;           public static String accessKeyId = &quot;LTAI5tGTPZEjjs7pfMQsQXZ5&quot;;           public static String accessKeySecret = &quot;LxYKPs6m3EAQldJtopxWyQsJV4XSVA&quot;;           public static  String bucketName = &quot;nxb-photo&quot;;    //文件上传,返回一个url字符串    public String uploadfile(MultipartFile file,String destFileName)&#123;        String objectName = destFileName;        OSS ossClient = null;        try &#123;            // 创建OSSClient实例，用于跟阿里云交互:根据3个属性创建            ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);            //获取文件流            InputStream inputStream = file.getInputStream();            //上传：putObject            ossClient.putObject(bucketName, objectName,inputStream);        &#125; catch (Exception e)&#123;            e.printStackTrace();        &#125; finally &#123;            // 关闭OSSClient。            ossClient.shutdown();        &#125;//拼接url：        String url = &quot;https://&quot; + bucketName + &quot;.oss-cn-shanghai.aliyuncs.com/&quot;                + destFileName;        return url;    &#125;&#125;</code></pre><h2 id="解耦配置"><a href="#解耦配置" class="headerlink" title="解耦配置"></a>解耦配置</h2><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><pre><code>@Component//注入bean@ConfigurationProperties(prefix = &quot;aliyossphoto&quot;)@Data//加载配置属性必须要有set@Validatedpublic class OSSphotoConfig &#123;    private String endpoint;    private String accessKeyId;    private String accessKeySecret;    private String bucketName;&#125;</code></pre><h3 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h3><pre><code>aliyossphoto:endpoint: https://oss-cn-hangzhou.aliyuncs.com#同时，oss工具类中的链接也要改到hangzhouaccessKeyId: aaaaaaaaaaaLEbKyCYLVaccessKeySecret: bbbbbbbbbbkJVfjmH7XWxnvXCebucketName: sss233</code></pre><h1 id="OSS工具类"><a href="#OSS工具类" class="headerlink" title="OSS工具类"></a>OSS工具类</h1><p>全部按的解耦方式来的，这里因为在普通类中注入bean，所以用到了一个自定义的SpringContextUtil类，在其他文章中有</p><h2 id="传入url，保存图片在OSS，返回新的url"><a href="#传入url，保存图片在OSS，返回新的url" class="headerlink" title="传入url，保存图片在OSS，返回新的url"></a>传入url，保存图片在OSS，返回新的url</h2><pre><code>public class OSSUrlToUrl &#123;    //获取bean        OSSphotoConfig osspc = SpringContextUtil.getBean(OSSphotoConfig.class);    public String fromUrlToUrl(String srcUrl, String destFileName)  &#123;//获取url，返回一个存在OSS上的url        String endpoint = osspc.getEndpoint();        String accessKeyId = osspc.getAccessKeyId();        String accessKeySecret = osspc.getAccessKeySecret();        String bucketName = osspc.getBucketName();        String objectName = destFileName;        //1,获取输入流        InputStream is = null;        try &#123;            URL downloadUrl = new URL(srcUrl);            is = downloadUrl.openStream();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        //2,oss存储输入流的信息        OSS ossClient = null;        try &#123;            // 创建OSSClient实例，用于跟阿里云交互:根据3个属性创建            ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);            //上传：putObject            ossClient.putObject(bucketName, objectName, is);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            // 关闭OSSClient。            ossClient.shutdown();            //关闭is            try &#123;                is.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        //3，拼接url：杭州填hangzhou，上海填shanghai        String destUrl = &quot;https://&quot; + bucketName + &quot;.oss-cn-hangzhou.aliyuncs.com/&quot;                + destFileName;        return destUrl;    &#125;&#125;</code></pre><h2 id="文件流直接保存OSS，返回url"><a href="#文件流直接保存OSS，返回url" class="headerlink" title="文件流直接保存OSS，返回url"></a>文件流直接保存OSS，返回url</h2><pre><code>public class OSSuserRegister &#123;    //获取bean    OSSphotoConfig osspc = SpringContextUtil.getBean(OSSphotoConfig.class);    public String uploadPicture(MultipartFile picture, Integer id) &#123;        String endpoint = osspc.getEndpoint();    String accessKeyId = osspc.getAccessKeyId();    String accessKeySecret = osspc.getAccessKeySecret();    String bucketName = osspc.getBucketName();        String substring = picture.getOriginalFilename().                substring(picture.getOriginalFilename().lastIndexOf(&quot;.&quot;));//拿到后缀        String filename = id + substring;//最终存储的文件名        OSS build = null;        try &#123;            build = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);//oss实例            InputStream is = picture.getInputStream();            build.putObject(bucketName, filename, is);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            build.shutdown();        &#125;        String pictureurl = &quot;https://&quot; + bucketName + &quot;.oss-cn-hangzhou.aliyuncs.com/&quot;                + filename;        return pictureurl;    &#125;&#125;</code></pre><h1 id="控制层演示"><a href="#控制层演示" class="headerlink" title="控制层演示"></a>控制层演示</h1><h2 id="UrlToUrl"><a href="#UrlToUrl" class="headerlink" title="UrlToUrl"></a>UrlToUrl</h2><pre><code>//微信的头像都是png格式@PostMapping(&quot;&#123;id&#125;&quot;)public R userRegister(@PathVariable Integer id,                      Users user) &#123;    R r = new R();    //1,判断是否老用户    Users byId = impUsersRegisterService.getById(id);    if (byId != null) &#123;        r.setFlag(false);        r.setMsg(&quot;欢迎回来：&quot; + user.getUsername() + &quot;!&quot;);    &#125; else &#123;        //2，从url下载流，上传到oss，获取新url，保证用户微信修改头像不影响小程序的头像        //          一来方便管理，二来防止修改头像后url过期                //3，新用户注册        //3.1替换url，用存储在oss上的url        UrlToUrl uTu = new UrlToUrl();        try &#123;            String destUrl = uTu.getDestUrl(user.getPictureUrl(), id);        //3.2保存新的url        user.setPictureUrl(destUrl);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        r.setFlag(impUsersRegisterService.save(user));        r.setMsg(&quot;欢迎注册~！&quot;);        r.setData(user);    &#125;    return r;&#125;</code></pre><h2 id="文件流ToUrl"><a href="#文件流ToUrl" class="headerlink" title="文件流ToUrl"></a>文件流ToUrl</h2><pre><code>@PutMapping(&quot;/edit/&#123;id&#125;&quot;)//id，省份，城市，用户名，用户标签，头像urlpublic R userRegister1(@PathVariable Integer id,                       @RequestParam(&quot;picture&quot;) MultipartFile picture,                       Users user) &#123;    //@RequestParam存在的情况下 这里不能写@Requestbody    R r = new R();    //上传picture 获取url    //阿里云oss会自动覆盖同名文件    String picutreurl = new OSSuserRegister().uploadPicture(picture, id);    user.setPictureUrl(picutreurl);    impUsersRegisterService.updateById(user);    r.setFlag(true);    r.setMsg(&quot;修改成功&quot;);    r.setData(user);    return r;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>异常处理汇总</title>
      <link href="/zjh/2022/02/15/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B1%87%E6%80%BB/"/>
      <url>/zjh/2022/02/15/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="异常处理分类"><a href="#异常处理分类" class="headerlink" title="异常处理分类"></a>异常处理分类</h2><ul><li>Error错误<br>Java虚拟机无法解决的严重问题，如JVM系统内部错误、资源耗尽等严重情况。如：StackOverflowError栈溢出 和 OutOfMemoryError堆溢出OOM ，<strong>一般不编写针对性的代码进行处理（异常处理代码），而只是对原本代码进行改动</strong>。</li><li>Exception异常<br>其他编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理，<strong>不改动原有代码，只增加异常预处理</strong>：</li></ul><h2 id="Exception异常体系结构"><a href="#Exception异常体系结构" class="headerlink" title="Exception异常体系结构"></a>Exception异常体系结构</h2><h3 id="编译时异常checked"><a href="#编译时异常checked" class="headerlink" title="编译时异常checked"></a>编译时异常checked</h3><ul><li>运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</li><li>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，<strong>即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</strong></li></ul><h3 id="运行时异常unchecked"><a href="#运行时异常unchecked" class="headerlink" title="运行时异常unchecked"></a>运行时异常unchecked</h3><ul><li> 非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，</li><li><strong>一般情况下不自定义检查异常。</strong></li></ul><h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="3个异常处理语句"><a href="#3个异常处理语句" class="headerlink" title="3个异常处理语句"></a>3个异常处理语句</h3><p>printStackTrance是最常用的</p><pre><code>e.toString()：  获得异常种类和错误信息e.getMessage():获得错误信息e.printStackTrace()：在控制台打印出异常种类，错误信息和出错位置等</code></pre><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><ul><li>catch可以有多个，也可以把多个catch合并为一个父类的catch</li><li><strong>finally中不建议有return，但分情况</strong>，下面说明几种特殊的return的情况，注意区分基本数据类型和引用数据类型的差异</li></ul><table><thead><tr><th>try中</th><th>catch中</th><th>finally中</th><th>返回值情况(基本数据类型)</th><th>返回值情况(引用类型)</th></tr></thead><tbody><tr><td>有</td><td>无</td><td>有</td><td>返回finally中的入栈值</td><td>同左</td></tr><tr><td>有</td><td>有且异常(执行)</td><td>有</td><td>执行finally，但返回catch中入栈的return值</td><td>执行finally且返回finally</td></tr><tr><td>无</td><td>有</td><td>有</td><td>无异常则finally中，有异常则catch中</td><td>无条件执行且返回finally的值</td></tr></tbody></table><h3 id="throws抛异常"><a href="#throws抛异常" class="headerlink" title="throws抛异常"></a>throws抛异常</h3><p>这种处理方法并没有真正解决Exception，并且如果调用方法，throws会层层向上抛，一般引用别人定义好的方法时，可将其方法throws出来的Exception进行try-catch处理，这样可以更灵活</p><h3 id="throw主动抛异常"><a href="#throw主动抛异常" class="headerlink" title="throw主动抛异常"></a>throw主动抛异常</h3><p> throw new RuntimeException() ，有时候为了保证逻辑的完整性，需要抛异常来阻止操作，并返回throw异常交给拦截器来处理<br><img src="https://img-blog.csdnimg.cn/b1a0c367a4f540d09a1916d3f4ecbf4c.png"></p><ul><li>throw编译时异常(throw new Exception(“”))，其方法要throws对应的编译时异常</li><li>throw运行时异常(throw new RuntimeException(“”))，其方法不需要throws</li></ul><p>举个例子：throw运行时异常，不用thorws</p><pre><code>class Student &#123;    int id;    public Student(int id)&#123;        if(id&gt;0)&#123;        this.id = id;        &#125;        else&#123;            throw new RuntimeException(&quot;id不能为负数&quot;);    &#125;    &#125;&#125;</code></pre><p>再举个例子：throw编译时异常，需要throws</p><pre><code>class Student &#123;    int id;    public Student(int id) throws Exception&#123;        if(id&gt;0)&#123;        this.id = id;        &#125;        else&#123;            throw new Exception();        &#125;    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/74ea4db3474e465d8ac9b5556eef2d8c.png"></p><h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>自定义异常类需要满足</p><ul><li>继承于某一个异常类</li><li>空参构造和String msg构造</li><li>指定serialVersionUID(指定序列化版本)</li></ul><p>示例：</p><pre><code>class MyException extends RuntimeException&#123;    static final long serialVersionUID = -123456789L;        public MyException()&#123;&#125;        public MyException(String msg)&#123;        super(msg);    &#125;&#125;</code></pre><p>在使用上和普通异常类是完全一样的</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>池化思想</title>
      <link href="/zjh/2022/02/15/%E6%B1%A0%E5%8C%96%E6%80%9D%E6%83%B3/"/>
      <url>/zjh/2022/02/15/%E6%B1%A0%E5%8C%96%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="池化思想"><a href="#池化思想" class="headerlink" title="池化思想"></a>池化思想</h1><p>资源反复利用，用后归还，免去大量建立销毁浪费的时间和资源，建立和销毁占用的资源还是很多的</p><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><h3 id="常量池独立于栈和堆，以下两种创建方式区别"><a href="#常量池独立于栈和堆，以下两种创建方式区别" class="headerlink" title="常量池独立于栈和堆，以下两种创建方式区别"></a>常量池独立于栈和堆，以下两种创建方式区别</h3><p>1，直接保存常量池的内容<br>String s1 = “直接保存”</p><p>2，new String间接保存<br>String s2 = new String(“间接保存”)</p><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ul><li>直接保存，无论创建多少个都是相同的</li><li>间接保存实际上保存的是地址值，指向线程池，此方式会产生两个对象；如果多次间接保存，例如：<br>String s3 = new String(“间接保存”)<br>String s4 = new String(“间接保存”)<br>String s5 = new String(“间接保存”)</li></ul><p>实际上在常量池中只创建了一个”间接保存”的对象，而引用对象却创建了3次</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="与传统相比的优点"><a href="#与传统相比的优点" class="headerlink" title="与传统相比的优点"></a>与传统相比的优点</h3><ul><li>传统的线程实现方式有包含了线程创建 线程销毁 的时间，而线程是可以复用的，因此引入线程池，<strong>把线程创建和销毁 改为 用后归还，不销毁</strong>，重复利用资源，提高线程利用率，提高程序的响应速度</li><li><strong>便于统一管理线程对象</strong></li><li><strong>可以控制最大并发量</strong></li></ul><h3 id="线程池模型——银行"><a href="#线程池模型——银行" class="headerlink" title="线程池模型——银行"></a>线程池模型——银行</h3><p>柜台窗口：线程，且不销毁<br>等待区：等待队列<br>窗口不够用时：增加线程<br>等待区没有座位时：拒绝策略——报异常或交给某个线程去左<br>窗口空闲太多：减少线程</p><h3 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h3><p>JUC并发工具包提供了ThreadPoolExecutor创建线程池，ThreadPoolExecutor有8个参数，分别为：</p><ul><li>corePoolSize：核心线程数——永不关闭的柜台窗口数</li><li>maximumPoolSize：最大线程数——最多的窗口总数</li><li>keepAliveTime：线程存活时间——非核心线程过多长时间没有接到任务就销毁——需要设置单位unit</li><li>unit：TimeUnit.SECONDS  或TimeUnit.MICROSECONDS等等都可以</li><li> BlockingQueue<Runnable> ：等待队列，new ArrayBlockingQueue&lt;&gt;(capacity:10)这里capacity的值设为10</li><li>ThreadFactory：线程工厂——无需自己创建，直接调用Executors.defaultThreadFactory()</li><li>RejectedExecutionHandler：拒绝策略——new ThreadPoolExecutor.AbortPolicy()被拒绝的任务的处理程序，抛出一个 RejectedExecutionException </li></ul><p>创建好之后用ExecutorService类对象来接收，之后就可以直接调用了<br>例如：利用lambda表达式</p><pre><code>for()&#123;executorService.execute( ()-&gt;&#123; 线程业务逻辑 &#125; );&#125;//线程池会自动调整当前线程数executorService.shutdown();//关闭线程池</code></pre><p>参考：<br><img src="https://img-blog.csdnimg.cn/54b57105930740ba8eacad4690c0843d.png" alt="拒绝策略"><img src="https://img-blog.csdnimg.cn/8af4df5f8e154e68afbcb752262d9064.png" alt="实现步骤"></p><p><a href="https://blog.csdn.net/qq_43061290/article/details/106911277">线程池详解</a></p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>资源重用</li><li>更快的系统反应速度</li><li>新的资源分配手段</li><li>统一的连接管理，避免数据库连接泄漏</li></ul><p><a href="https://www.bilibili.com/video/BV1Gr4y1c7jd?spm_id_from=333.999.0.0">参考1</a></p><p><a href="https://blog.csdn.net/weixin_43520450/article/details/107231118?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164484874416780271532521%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164484874416780271532521&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-107231118.pc_search_insert_es_download&utm_term=%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0&spm=1018.2226.3001.4187">参考2</a><br><img src="https://img-blog.csdnimg.cn/6323c68d6d694d1fb8e62f6ae49cd152.png"></p><h3 id="优秀的开源数据库连接池代理"><a href="#优秀的开源数据库连接池代理" class="headerlink" title="优秀的开源数据库连接池代理"></a>优秀的开源数据库连接池代理</h3><p>（1）DBCP 是Apache提供的数据库连接池。tomcat服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。</p><p>（2）C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以，hibernate官方推荐使用。</p><p>（3）Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点.</p><p>（4）BoneCP 是一个开源组织提供的数据库连接池，速度快。</p><p>（5）Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool优点于一身的数据库连接池，但是速度不确定是否有BoneCP快。</p><h1 id="还有锁池，等待池"><a href="#还有锁池，等待池" class="headerlink" title="还有锁池，等待池"></a>还有锁池，等待池</h1><p>具体在线程同步的汇总中，wait和notify</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象汇总</title>
      <link href="/zjh/2022/02/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B1%87%E6%80%BB/"/>
      <url>/zjh/2022/02/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="深拷贝，浅拷贝"><a href="#深拷贝，浅拷贝" class="headerlink" title="深拷贝，浅拷贝"></a>深拷贝，浅拷贝</h2><ul><li>Person p2 = new Person(p1)是调用了构造器，对属性进行复制，并且new了一个新地址，p1 p2指向不同，互不影响，是深拷贝</li><li>而Person p2 = p1则是直接让p2指向p1，p1的改变影响p2，是浅拷贝</li></ul><h2 id="为何要封装"><a href="#为何要封装" class="headerlink" title="为何要封装"></a>为何要封装</h2><ul><li>有时候需要对属性进行crud操作，倘若有Animal类，有属性legsNumber，腿子的数量就不能是单数，通过自定义set方法可以解决逻辑问题</li><li>账户类中有余额属性，在set时也需要进行判断，可以自定义set，而把属性本身设为private，防止直接访问修改（当然你要说用反射那当我没说）</li></ul><h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><ul><li>用完一次之后就等垃圾回收</li><li>如果Person p1 = new Person(“zhangsan”,15, new Pet(“年年”))这样new出来的Pet对象是不会被回收的</li></ul><h2 id="什么是javaben"><a href="#什么是javaben" class="headerlink" title="什么是javaben"></a>什么是javaben</h2><ul><li>public类</li><li>private属性</li><li>有get set方法</li><li>有public无参构造器</li></ul><h2 id="this关键字和super关键字"><a href="#this关键字和super关键字" class="headerlink" title="this关键字和super关键字"></a>this关键字和super关键字</h2><ul><li>this就是本类，super就是上一级父类</li><li>this.可以调属性：this.name = name;</li><li>this.可以调方法：在参数多的构造器中this.参数少的构造器</li><li>当子类定义有参的构造方法时，super（形参列表）必须与父类构造一致</li><li>this（）和super（）都是构造方法，并且都要求放在第一行，但是this（）和super（）只会同时出现其中一个，一般用this（形参）针对父类构造，super（形参）针对子类构造</li></ul><p>示例：</p><pre><code>class Person&#123;    private String name;    private int age;        public Person(String name, int age) &#123;        super();        this.name = name;        this.age = age;    &#125;    &#125;class Student extends Person&#123;    private int id;        public Student(String name, int age, int id) &#123;        //形参要求齐全        super(name, age);//先super（）构造        this.id = id;    &#125;&#125;</code></pre><h2 id="继承的权限"><a href="#继承的权限" class="headerlink" title="继承的权限"></a>继承的权限</h2><ul><li> 权限大小：public&gt;protected&gt;缺省&gt;private</li><li>每“出一层”，可见范围少一个</li></ul><p>同包建立任意类（子类，普通类）：private不可见了</p><p>跨包建立子类：缺省也不可见了</p><p>跨包建立普通类（非子类）：protected也不可见了</p><p>实际开发中一般只用public和private</p><h2 id="重载和重写-覆写"><a href="#重载和重写-覆写" class="headerlink" title="重载和重写(覆写)"></a>重载和重写(覆写)</h2><ul><li>重载：形参<strong>类型or数量</strong>不同，构造器就是重载</li><li>重写：保证子父类<strong>结构一致</strong>，给与子类方法独特的个性</li><li>属性也是可以重写的，参数名相同，可以更改类型</li></ul><h3 id="重写后如何调用父类方法？"><a href="#重写后如何调用父类方法？" class="headerlink" title="重写后如何调用父类方法？"></a>重写后如何调用父类方法？</h3><pre><code>class Super&#123;    public void tell()&#123;        System.out.println(&quot;我是你爹&quot;);    &#125;&#125; class Sub extends Super&#123;    public void tell()&#123;//覆写        System.out.println(&quot;***********&quot;);        super.tell();//调用父类的被覆写的方法        super.tell();//可以调用多次，并且位置不限        System.out.println(&quot;我是你儿子&quot;);    &#125;&#125; public class Test &#123;public static void main(String[] args) &#123;    Sub A = new Sub();    A.tell();&#125;&#125;</code></pre><h2 id="编译看左，运行看右-虚拟方法调用"><a href="#编译看左，运行看右-虚拟方法调用" class="headerlink" title="编译看左，运行看右(虚拟方法调用)"></a>编译看左，运行看右(虚拟方法调用)</h2><ul><li><p>编译看左，运行看右：（虚拟方法调用）</p></li><li><p>Person A = new Man();  左边决定能用什么属性or方法，右边决定用谁的属性or方法</p></li><li><p>在编译期只能调用父类中声明的方法，但在执行期实际执行的是子类重写的方法</p></li><li><p>多态性是一个运行期行为，编译器看不出来</p></li></ul><h2 id="instanceof方法"><a href="#instanceof方法" class="headerlink" title="instanceof方法"></a>instanceof方法</h2><p>如果 对象属于xx类，那么对象 instansof XX就返回ture</p><pre><code>System.out.println(new AllComments() instanceof Object);//trueSystem.out.println(new Father() instanceof Son);//false</code></pre><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>例如：Object.Number.Integer </p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><ul><li>可传String和boolean</li><li>忽略大小写<pre><code>  System.out.println(new Boolean(&quot;sadasd&quot;));//fanlse  System.out.println(new Boolean(&quot;&quot;));//fanlse  System.out.println(new Boolean(&quot;TrUe&quot;));//true  System.out.println(new Boolean(true));//true</code></pre></li></ul><h3 id="Float"><a href="#Float" class="headerlink" title="Float"></a>Float</h3><ul><li>可传double float String</li></ul><p>示例：</p><pre><code>Float A = new Float(12.3);//double自动转成floatFloat A2 = new Float(12.3f);Float B = new Float(&quot;12.3&quot;);//String自动转成floatFloat C = new Float(&quot;12.3aaa&quot;);//编译正常，运行报错，Float没有定义怎么处理字母</code></pre><h3 id="默认值问题"><a href="#默认值问题" class="headerlink" title="默认值问题"></a>默认值问题</h3><p>包装类的默认值是null 如Integer：null，普通类的默认值如int：0  </p><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><p>可以直接把基本数据类型赋值给包装类</p><pre><code>Integer A = 1;相当于Integer A = new Integer(1);</code></pre><h3 id="自动拆箱"><a href="#自动拆箱" class="headerlink" title="自动拆箱"></a>自动拆箱</h3><pre><code>Integer A = 1; int a = A;相当于Integer A = new Integer(1);int a = A.intValue();</code></pre><h3 id="String到包装类or普通数据类型-parse"><a href="#String到包装类or普通数据类型-parse" class="headerlink" title="String到包装类or普通数据类型(parse)"></a>String到包装类or普通数据类型(parse)</h3><ul><li><p>为什么不能直接Integer A = (Integer)(new String(“1111”)呢</p></li><li><p><strong>因为Integer和String两个类没有子父类关系</strong></p></li><li><p>应该使用parseXxx方法来解析</p><pre><code>  Integer A = Integer.parseInt((new String(&quot;111&quot;)));//111  Double B = Double.parseDouble(A.toString());//111.0  Float C = Float.parseFloat(&quot;111&quot;);//111.0  Boolean D = Boolean.parseBoolean(&quot;true&quot;);//D就是true</code></pre></li></ul><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><ul><li>Object中的默认toString是输出地址值</li><li>自定义类需要重写toString</li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li>不用new就可以用，随类的加载而加载</li><li>static属性：既可以<strong>类</strong>调用，也可以<strong>对象</strong>调用</li><li>static方法：只能调用static属性和方法，不能访问普通方法；不能使用this和super</li></ul><h2 id="final和abstract"><a href="#final和abstract" class="headerlink" title="final和abstract"></a>final和abstract</h2><p>final</p><ul><li><p>定义不能继承的类</p></li><li><p>定义不能重写的方法</p></li><li><p>定义常量属性</p></li><li><p>final和abstract不相同</p></li><li><p>可以先声明后定义</p><pre><code>  public final class NoInherit&#123; &#125;  //不能继承的类  public static final void tell()&#123;&#125;  //不能重写的方法  public static final int a;  //静态常量，final一般都是跟static连用        final a;  a = 1;  //此后a就不能变了  //a=1之前不能调用，会报错</code></pre></li></ul><p>abstract</p><ul><li>abstract不能修饰private方法、static方法、final方法</li><li>抽象类的抽象方法更多是一种规范</li><li><strong>new 抽象类 or  接口</strong> 的时候要用代码块包裹所有需要重写的abstract类，如：<br><img src="https://img-blog.csdnimg.cn/deb895d901bc487ab2ee40625b907dc2.png"></li></ul><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul><li>执行顺序：静态代码块—&gt;普通代码块—&gt;构造器</li><li>且静态代码块只随类加载一次</li><li>有继承关系时，先调用父类的静态代码块</li></ul><p>示例：</p><pre><code>public class PersonTest&#123;public static void main(String[] args) &#123;new Person();new Person();&#125;&#125;class Person&#123;        public Person()&#123;        System.out.println(&quot;构造器&quot;);    &#125;    &#123;        System.out.println(&quot;代码块&quot;);    &#125;    static&#123;        System.out.println(&quot;静态代码块&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/9dd637bc1fdc43749c44f26582a4b350.png"></p><h2 id="内部类和JVM类的加载规则"><a href="#内部类和JVM类的加载规则" class="headerlink" title="内部类和JVM类的加载规则"></a>内部类和JVM类的加载规则</h2><p>在定义类的时候可以把另一个类作为class类型的属性</p><p>JVM的类加载规则 ：</p><ul><li>  static类型的属性和方法，在类加载的时候就会存在于内存中。</li><li>  要想使用某个类的static属性和方法，那么这个类必须要加载到JAVA虚拟机中。</li><li>   非静态内部类不能有静态成员变量或静态方法</li></ul><p>静态属性or方法不用new就加载，而非静态的内部类需要new才能实例化，显然是矛盾的，所以非静态内部类不能有静态成员变量或静态方法</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程和线程同步汇总</title>
      <link href="/zjh/2022/02/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%B1%87%E6%80%BB/"/>
      <url>/zjh/2022/02/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="程序-进程-线程"><a href="#程序-进程-线程" class="headerlink" title="程序 进程 线程"></a>程序 进程 线程</h2><ul><li><p>程序：静态的代码，没有运行起来的才叫程序<br>eg：文件夹中的所有文件<br>整个文件夹内包括的所有静态代码的集合就是程序</p></li><li><p>进程：是程序的一次运行or正在运行的一个程序，是一个动态的过程，并且有自身的产生、存在、消亡的过程——生命周期<br>eg：运行中的QQ、运行中的LOL、运行中的360安全卫士</p></li><li><p>线程：进程可以细分为线程，是程序内部的一条执行路径。如果一个进程可以同时并行执行多个线程，就是支持多线程的。<br>线程是调度和执行的单位，有独立的运行栈和程序计数器，线程切换的开销小<br>一个进程中多个线程共享相同的资源，因此可以进程间通信更高效，但也带来了安全隐患<br>eg：同时扫漏洞、扫毒、清理垃圾就是多线程，多线程增加了cpu利用率<br>eg：图形化界面的基本都是多线程<br>eg：QQ同时有很多人互相发消息</p></li></ul><ul><li>一个java应用程序java.exe<strong>至少</strong>有三个线程：main()主线程、gc()垃圾回收线程、异常处理线程，还可以有内存监控 操作日志</li></ul><h2 id="CPU的单核和多核"><a href="#CPU的单核和多核" class="headerlink" title="CPU的单核和多核"></a>CPU的单核和多核</h2><ul><li>单核CPU：实际上是一种假的多线程，表象的多线程实际上是快速在不同线程之间切换（<strong>时分复用</strong>），是一种并发</li></ul><p>eg：同一个进程，使用单核cpu，单线程比多线程更快，<strong>因为没有线程切换时间</strong></p><ul><li>多核CPU：可以实现并行，且</li></ul><p>eg：现在的很多手机都是8核心，但这8核并不是完全相同，当手机写备忘录时，<strong>调用功耗小功能更弱的核</strong>，玩游戏时调用更强但功耗大的核</p><h2 id="并发、并行"><a href="#并发、并行" class="headerlink" title="并发、并行"></a>并发、并行</h2><p>并发：一个CPU同时执行多个线程</p><p>并行：多个CPU同时执行多个线程</p><h1 id="多线程的创建和使用"><a href="#多线程的创建和使用" class="headerlink" title="多线程的创建和使用"></a>多线程的创建和使用</h1><h2 id="传统多线程"><a href="#传统多线程" class="headerlink" title="传统多线程"></a>传统多线程</h2><ul><li>线程具有优先级1~10，且是一个统计学上的优先级，满足大数定律</li><li>Thread类实现了Runnable接口，可以创建线程</li><li>开发中常用的是线程池，线程池减少了线程的创建和销毁的用时</li><li>在自己手写多线程时，可能出现逻辑正确，但有几个输出特例不符合多线程，这可能是由于多线程运行到屏幕输出的不稳定时间差造成的</li></ul><h3 id="Thread类的常用方法"><a href="#Thread类的常用方法" class="headerlink" title="Thread类的常用方法"></a>Thread类的常用方法</h3><ul><li>void start(): 启动线程，并执行对象的run()方法</li><li>void run(): 线程在被调度时执行的操作</li><li>String getName(): 返回线程的名称</li><li>void setName(String name):设置该线程名称</li><li>static Thread currentThread(): 返回当前线程对象。在Thread子类中就 是this，通常用于主线程和Runnable Callable实现类</li><li>static void yield()：线程让步。暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程 若队列中没有同优先级的线程，忽略此方法。</li><li>join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将 被阻塞，直到 join() 方法加入的 join 线程执行完为止，低优先级的线程也可以获得执行。该方法需要try-catch</li><li>static void sleep(long millis)：(指定时间:毫秒) 令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。 抛出* InterruptedException异常。该方法需要try-catch</li><li>stop(): 强制线程生命期结束，不推荐使用</li><li>boolean isAlive()：返回boolean，判断线程是否还活着</li></ul><h3 id="sleep-yield-join-wait-notify的区别放在后面的线程同步中"><a href="#sleep-yield-join-wait-notify的区别放在后面的线程同步中" class="headerlink" title="sleep yield join wait notify的区别放在后面的线程同步中"></a>sleep yield join wait notify的区别放在后面的线程同步中</h3><h3 id="Runnable接口：作为Thread对象的构造形参"><a href="#Runnable接口：作为Thread对象的构造形参" class="headerlink" title="Runnable接口：作为Thread对象的构造形参"></a>Runnable接口：作为Thread对象的构造形参</h3><ol><li>相比直接使用Thread，可以实现“多继承”</li><li>线程的开启仍需要实现Thread类</li><li>new Thread( new MyThread() ) .start来启动</li></ol><p>示例：</p><pre><code>class MyrunThread implements Runnable &#123;     public void run() &#123;        for (int i = 1; i &lt; 100; i++) &#123;            System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);        &#125;    &#125;&#125;public class RunnableTest &#123;    public static void main(String[] args) &#123;     //一步写法        new Thread(new MyrunThread()).start();        //两步写法        MyrunThread m1 = new MyrunThread();        Thread M1 = new Thread(m1);        //M1可以调用Thread类的所有方法        M1.start();    &#125;&#125;</code></pre><h3 id="Callable接口：借助FutureTask解耦合"><a href="#Callable接口：借助FutureTask解耦合" class="headerlink" title="Callable接口：借助FutureTask解耦合"></a>Callable接口：借助FutureTask解耦合</h3><ol><li>与Runnable相比，Callable功能更强大，可以有返回值，可以抛异常</li><li>Runnable是重写run()方法，Callable是重写call()方法</li><li>返回值的功能需要借助FutureTask类，并且从FutureTask类对象.get()获取返回值</li><li><strong>因为即便是用Callable接口实现，也存在不需要返回值的情况，因此引入FutureTask类来解耦合</strong></li><li>new Thread( new FutureTask( new MyThread() ) ).start来启动</li></ol><p>实现Callable接口，重写call()方法</p><pre><code>class Mythread implements Callable&lt;Integer&gt;&#123;     @Override    public Integer call() throws Exception &#123;int  sum = 0;        for (int  i = 1 ; i&lt;100 ; i++)&#123;            if(i%4==0)&#123;                System.out.println(i);                sum+=i;            &#125;        &#125;        return sum;        //这里的返回值是不能通过Thread直接获取的        //需要利用FutureTask    &#125;&#125;</code></pre><p>借助FutureTask，实现Thread</p><pre><code>public class CallableTest &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;       Mythread M1 = new Mythread();//实现Callable接口实例       FutureTask F1 = new FutureTask(M1);//传入FutureTask中       Thread T1 = new Thread(F1);//传入Thread中        T1.start();//启动        System.out.println(F1.get());         //start运行call方法，但是不一定必须接收返回值    &#125;&#125;</code></pre><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="与传统相比的优点"><a href="#与传统相比的优点" class="headerlink" title="与传统相比的优点"></a>与传统相比的优点</h3><ul><li>传统的线程实现方式有包含了线程创建 线程销毁 的时间，而线程是可以复用的，因此引入线程池，<strong>把线程创建和销毁 改为 用后归还，不销毁</strong>，重复利用资源，提高线程利用率，提高程序的响应速度</li><li><strong>便于统一管理线程对象</strong></li><li><strong>可以控制最大并发量</strong></li></ul><h3 id="线程池模型——银行"><a href="#线程池模型——银行" class="headerlink" title="线程池模型——银行"></a>线程池模型——银行</h3><p>柜台窗口：线程，且不销毁<br>等待区：等待队列<br>窗口不够用时：增加线程<br>等待区没有座位时：拒绝策略——报异常或交给某个线程去左<br>窗口空闲太多：减少线程</p><h3 id="线程池创建"><a href="#线程池创建" class="headerlink" title="线程池创建"></a>线程池创建</h3><p>JUC并发工具包提供了ThreadPoolExecutor创建线程池，ThreadPoolExecutor有8个参数，分别为：</p><ul><li>corePoolSize：核心线程数——永不关闭的柜台窗口数</li><li>maximumPoolSize：最大线程数——最多的窗口总数</li><li>keepAliveTime：线程存活时间——非核心线程过多长时间没有接到任务就销毁——需要设置单位unit</li><li>unit：TimeUnit.SECONDS  或TimeUnit.MICROSECONDS等等都可以</li><li> BlockingQueue<Runnable> ：等待队列，new ArrayBlockingQueue&lt;&gt;(capacity:10)这里capacity的值设为10</li><li>ThreadFactory：线程工厂——无需自己创建，直接调用Executors.defaultThreadFactory()</li><li>RejectedExecutionHandler：拒绝策略——new ThreadPoolExecutor.AbortPolicy()被拒绝的任务的处理程序，抛出一个 RejectedExecutionException </li></ul><p>创建好之后用ExecutorService类对象来接收，之后就可以直接调用了<br>例如：利用lambda表达式</p><pre><code>for()&#123;executorService.execute( ()-&gt;&#123; 线程业务逻辑 &#125; );&#125;//线程池会自动调整当前线程数executorService.shutdown();//关闭线程池</code></pre><p>参考：<br><img src="https://img-blog.csdnimg.cn/54b57105930740ba8eacad4690c0843d.png" alt="拒绝策略"><img src="https://img-blog.csdnimg.cn/8af4df5f8e154e68afbcb752262d9064.png" alt="实现步骤"></p><p><a href="https://blog.csdn.net/qq_43061290/article/details/106911277">线程池详解</a></p><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>线程同步的同步意为：协同步调，按预定的先后次序进行运行<br>防止因为并发导致的数据读写错误</p><p><img src="https://img-blog.csdnimg.cn/b28c427c630846fb8d84743a19e996f6.png" alt="线程的生命周期"></p><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>同步的实现离不开锁机制，以下几种常见的锁<br><a href="https://blog.csdn.net/weixin_37601506/article/details/114320658?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164488362516780265434774%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164488362516780265434774&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-114320658.pc_search_insert_es_download&utm_term=%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%81&spm=1018.2226.3001.4187">参考资料</a></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><a href="https://blog.csdn.net/hd12370/article/details/82814348">参考：死锁的预防</a><br>死锁的预防一般有：<br><img src="https://img-blog.csdnimg.cn/992ffc3a82944aaf96230eb56d7e9c04.png" alt="hashCode指定顺序"><img src="https://img-blog.csdnimg.cn/063a05a7b2fe4e0eabfa85767eb51f8f.png" alt="Lock接口超时放弃"></p><p>手写死锁：</p><pre><code>class Mythread implements Runnable&#123;public void run()&#123;......synchronized(锁A)&#123;//A锁套B锁    synchronized(锁B)&#123;     ......    &#125;&#125;......&#125;&#125; class Youthread implements Runnable&#123;public void run()&#123;......synchronized(锁B)&#123;//B锁套A锁    synchronized(锁A)&#123;     ......    &#125;&#125;......&#125;&#125;</code></pre><p><strong>如果是锁进行了递归调用，一个锁也是可能产生死锁的</strong></p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><ul><li>认为总有线程会操作自己正在操作的数据</li><li>使用场景：频繁写入；保证安全性</li><li>锁实现：synchronized关键字、Lock接口</li></ul><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><ul><li>认为没有线程会操作自己正在操作的数据</li><li>使用场景：多读少写；保证效率高</li><li>锁实现：CAS算法</li></ul><h3 id="读锁-S锁-共享锁"><a href="#读锁-S锁-共享锁" class="headerlink" title="读锁(S锁)(共享锁)"></a>读锁(S锁)(共享锁)</h3><ul><li>只读，例如SELECT</li><li>加S锁后，别的事务只能再加S锁而不能加X锁，但加锁者本身可以再加X锁</li></ul><p>若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p><h3 id="写锁-X锁-排他锁"><a href="#写锁-X锁-排他锁" class="headerlink" title="写锁(X锁)(排他锁)"></a>写锁(X锁)(排他锁)</h3><ul><li>写，例如INSERT、UPDATE 或 DELETE</li><li>加X锁后，其他任何事务不能再加任何S锁和X锁</li></ul><p>若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><ul><li>多个共用同一把锁的线程有序排队，并按排队顺序上锁</li><li>private  ReentrantLock lockkk = new ReentrantLock(true);叫公平锁</li></ul><p>手写公平锁：</p><pre><code>private  ReentrantLock lockkk = new ReentrantLock(true);//公平锁。。。。。。。。。    public void run()&#123;        for(int i = 1;i&lt;=100;i++)&#123;            lockkk.lock();//上公平锁lockkk            System.out.print(Thread.currentThread().getName());            Depot(this.account,1000);            //输出内容            try &#123;            Thread.sleep(100);        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;//加上sleep效果更明显，防止因为屏幕输出时间差造成的误导             lockkk.unlock();//释放公平锁lockkk//此后该调用lock的线程进入排队的末尾，不与其他线程争抢资源        &#125;&#125;</code></pre><h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><ul><li>多个共用同一把锁的线程有序排队，但不按顺序上锁，仍像synchronized一样靠抢</li><li>private  ReentrantLock lockkk = new ReentrantLock(false);<br>private  ReentrantLock lockkk = new ReentrantLock();都是非公平锁</li></ul><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html">参考资料</a></p><ul><li>只能修饰变量，如：private volatile static int phoneNumber = 0;</li><li><strong>对变量的写操作不依赖于当前值</strong>，若是++i , i+=5这种依赖于原有值的操作则可能仍然会有错误</li><li><strong>该变量是独立的</strong>：该变量没有包含在具有其他变量的不变式中</li><li>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程</li><li>synchronized既能保证可见性，又能保证原子性，<strong>而volatile只能保证可见性，无法保证原子性</strong>。</li></ul><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>为什么用对象来充当监视器？：<br> 由于java的<strong>每个对象都有一个内置锁</strong>，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，要获取内置锁，否则处于阻塞状态。</p><h3 id="同步方法-粗粒度锁"><a href="#同步方法-粗粒度锁" class="headerlink" title="同步方法(粗粒度锁)"></a>同步方法(粗粒度锁)</h3><ul><li>比同步代码块更笨重，开销更大</li><li>用this上锁，因此也有潜在的风险</li><li>同步方法(粗粒度锁)：<br>  A、修饰一般方法: public <strong>synchronized</strong> void method(){…}，获取的是当前调用对象 this 上的锁；<br>  B、修饰静态方法: public <strong>static synchronized</strong> void method (){…}，获取当前类的字节码对象上的锁。</li></ul><h3 id="同步代码块-细粒度锁"><a href="#同步代码块-细粒度锁" class="headerlink" title="同步代码块(细粒度锁)"></a>同步代码块(细粒度锁)</h3><ul><li>对象监视器：同一个对象同一把锁，处于同一个同步机制里</li><li>监视器用<strong>this</strong>指的是当前类对象，<br>例如：用Runnable接口实现的线程，run()方法写为synchronized，那么这个锁就是Runnable的对象，如果用这一个对象作为形参创建了多个线程，就是线程同步的<br>例如：用extends直接继承Thread，run()方法写为synchronized，那么new几个线程就加了几把锁，失去了同步功能</li></ul><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p>Lock接口可以主动在任意位置lock和unlock，所以更加灵活</p><h3 id="ReentrantLock接口"><a href="#ReentrantLock接口" class="headerlink" title="ReentrantLock接口"></a>ReentrantLock接口</h3><p>public class ReentrantLock implements <strong>Lock</strong>, java.io.Serializable </p><ul><li>提供公平锁机制，而synchronized是非公平的</li><li>boolean tryLock() 方法：如果拿不到锁就返回false，不会像synchronized一直等待</li><li>void lock()  上锁，且需要void unlock()  主动解锁</li><li>当发生异常时，synchronized会自动释放锁，而Lock接口需要在try-catch-<strong>finally中手动释放锁，防止死锁</strong></li><li>在性能上来说，如果线程竞争资源不激烈时，两者的性能是差不多的，而<strong>当竞争资源非常激烈时（即有大量线程同时竞争），此时 Lock 的性能要远远优于 synchronized</strong></li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code>private  ReentrantLock locker = new ReentrantLock(true);//公平锁。。。。。。。。。    public void run()&#123;        for(int i = 1;i&lt;=100;i++)&#123;//模拟多线程            locker.lock();//上公平锁lockkk          try&#123;执行的可能出错的代码          &#125;catch(Exception e)&#123;             e.printStackTrace();        &#125;finally&#123;            locker.unlock()        &#125;        &#125;    &#125;</code></pre><h1 id="sleep-yield-join-wait-notify"><a href="#sleep-yield-join-wait-notify" class="headerlink" title="sleep yield join wait notify"></a>sleep yield join wait notify</h1><p>首先确定一点，CPU资源调度和线程同步不是同一个概念，即便是没有监视器(没有锁)，也存在CPU资源调度问题(也有sleep和yield方法)；<br>而只有加锁之后才有wait和notify来操作线程的执行</p><h2 id="CPU资源角度"><a href="#CPU资源角度" class="headerlink" title="CPU资源角度"></a>CPU资源角度</h2><ul><li>sleep和yield<strong>都不释放锁，因此影响的是cpu资源调度</strong></li><li>都是静态方法，因此可以<strong>无关监视器，无关同步</strong></li></ul><h3 id="sleep线程休眠"><a href="#sleep线程休眠" class="headerlink" title="sleep线程休眠"></a>sleep线程休眠</h3><ul><li><strong>不释放锁</strong>，同监视器的线程仍然阻塞</li><li>稳定让渡cpu资源，不同监视器的线程可以执行</li><li>静态方法，Thread.sleep(123123)随处可用</li></ul><h3 id="yield线程让步"><a href="#yield线程让步" class="headerlink" title="yield线程让步"></a>yield线程让步</h3><ul><li><strong>不释放锁</strong>，同监视器的线程仍然阻塞</li><li>不稳定让渡cpu资源，重新争夺cpu资源，可能没有明显效果</li><li>其他监视器的线程需：<strong>优先级&gt;=调用yield的线程</strong>，才能争夺cpu资源</li></ul><h2 id="线程同步角度"><a href="#线程同步角度" class="headerlink" title="线程同步角度"></a>线程同步角度</h2><ul><li><p>wait notify notifyAll 都是需要写在同步代码块之中的，针对已经获取了Obj锁进行操作，<strong>都不是静态方法</strong></p></li><li><p>从语法角度来说就是<strong>Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。</strong></p></li><li><p>从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁</p><h2 id="wati"><a href="#wati" class="headerlink" title="wati"></a>wati</h2></li><li><p>释放CPU的同时释放锁</p></li><li><p>进入<strong>等待池</strong>，等待其他线程使用obj.notify()唤醒</p></li><li><p>调用obj.wait()后直接释放资源</p></li><li><p>因为是写在synchronized代码块中，所以调用obj.wait()之后还需等其他线程obj.notifyAll()之后<strong>才执行wait之后剩余的代码</strong></p></li></ul><h2 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify notifyAll"></a>notify notifyAll</h2><ul><li>在相同监视器下(相同锁下)，前者是随机唤醒一个线程，后者是唤醒所有线程</li><li>notify和notifyAll的最终效果都是从等待池唤醒一个，但notify可能会导致两个线程都挂起，造成阻塞（所有线程都wait进入了等待池，没有线程再执行唤醒）</li></ul><h3 id="对象内部锁"><a href="#对象内部锁" class="headerlink" title="对象内部锁"></a>对象内部锁</h3><p>其实，每个对象都拥有两个池，分别为锁池(EntrySet)和(WaitSet)等待池。</p><ul><li>锁池：假如已经有线程A获取到了锁，这时候又有线程B需要获取这把锁(比如需要调用synchronized修饰的方法或者需要执行synchronized修饰的代码块)，由于该锁已经被占用，所以线程B只能等待这把锁，这时候线程B将会进入这把锁的锁池。</li><li>等待池：假设线程A获取到锁之后，由于一些条件的不满足(例如生产者消费者模式中生产者获取到锁，然后判断队列为满)，此时需要调用对象锁的wait方法，那么线程A将放弃这把锁，并进入这把锁的等待池。</li></ul><p>如果有其他线程调用了锁的notify方法，则会根据一定的算法从等待池中选取一个线程，将此线程放入锁池。<br>如果有其他线程调用了锁的notifyAll方法，则会将等待池中所有线程全部放入锁池，并争抢锁。</p><p>锁池与等待池的区别：等待池中的线程不能获取锁，而是需要被唤醒进入锁池，才有获取到锁的机会。</p><p><a href="https://blog.csdn.net/liuzhixiong_521/article/details/86677057">参考资料1</a></p><p><a href="https://www.zhihu.com/question/37601861/answer/145545371">参考资料2</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实现朋友圈下拉刷新拼接的思路</title>
      <link href="/zjh/2022/02/09/%E5%AE%9E%E7%8E%B0%E6%9C%8B%E5%8F%8B%E5%9C%88%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E6%8B%BC%E6%8E%A5%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
      <url>/zjh/2022/02/09/%E5%AE%9E%E7%8E%B0%E6%9C%8B%E5%8F%8B%E5%9C%88%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E6%8B%BC%E6%8E%A5%E7%9A%84%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="规定"><a href="#规定" class="headerlink" title="规定"></a>规定</h1><p>规定每次下拉刷新size个，该案例中默认10个</p><h1 id="1，前端"><a href="#1，前端" class="headerlink" title="1，前端"></a>1，前端</h1><h2 id="全局变量index-0"><a href="#全局变量index-0" class="headerlink" title="全局变量index=0"></a>全局变量index=0</h2><h2 id="初次打开朋友圈"><a href="#初次打开朋友圈" class="headerlink" title="初次打开朋友圈"></a>初次打开朋友圈</h2><p>设置一个全局变量index作为索引，初始值为0，打开朋友圈动态的时候，将这个x传给后端，后端取出索引 [ 0 , 10) 的所有数据，返回一个list给前端</p><h2 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h2><p>下拉绑定一个事件，index+=10 , 且把新的x值传给后端，后端取出索引 <br>[ 10，20 ) 的所有数据，返回一个list给前端</p><h2 id="拼接list"><a href="#拼接list" class="headerlink" title="拼接list"></a>拼接list</h2><p>前端展示用的list1，用list2来取后端的list    this.list2 = res.data.data，然后把list2拼接在list1上用于展示</p><h1 id="2，后端"><a href="#2，后端" class="headerlink" title="2，后端"></a>2，后端</h1><p>springboot整合mybatis，该案例下使用注解开发</p><h2 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h2><p><img src="https://img-blog.csdnimg.cn/2cf9e6e5c97541ca85164f91450bddd5.png"></p><h2 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h2><p><img src="https://img-blog.csdnimg.cn/9cc4507a1fa041eab18678961adf56a9.png"></p><h2 id="控制层"><a href="#控制层" class="headerlink" title="控制层"></a>控制层</h2><p><img src="https://img-blog.csdnimg.cn/8725b71e5c954b6e92844f47c6637360.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO传输图片能打开但花屏</title>
      <link href="/zjh/2022/02/09/IO%E4%BC%A0%E8%BE%93%E5%9B%BE%E7%89%87%E8%83%BD%E6%89%93%E5%BC%80%E4%BD%86%E8%8A%B1%E5%B1%8F/"/>
      <url>/zjh/2022/02/09/IO%E4%BC%A0%E8%BE%93%E5%9B%BE%E7%89%87%E8%83%BD%E6%89%93%E5%BC%80%E4%BD%86%E8%8A%B1%E5%B1%8F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/a4e0f644e65c4015ba90bdf5f5f6f987.png" alt="破损图片"></p><h1 id="错误源码"><a href="#错误源码" class="headerlink" title="错误源码"></a>错误源码</h1><pre><code>    URL url = new URL(&quot;https://img-blog.csdn.net/2018070322420927?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIyMDc2MzQ1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;);    System.out.println(url.getFile());    InputStream is = url.openStream();    File file = new File(&quot;D:\\yeb\\test1.jpg&quot;);    FileOutputStream fos = new FileOutputStream(file);    byte[] bbuf = new byte[1024];    int len;    while((len=is.read(bbuf)) != -1)&#123;        //每从bis读一次，就往bos写一次        fos.write(bbuf);    &#125;    fos.flush();    fos.close();    is.close();</code></pre><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>设置偏移量offset=0  长度=len</p><pre><code>  while((len=is.read(bbuf)) != -1)&#123;        //每从bis读一次，就往bos写一次        fos.write(bbuf,0,len);    &#125;</code></pre><h1 id="分析错误"><a href="#分析错误" class="headerlink" title="分析错误"></a>分析错误</h1><p><img src="https://img-blog.csdnimg.cn/6e7b8e101d5543109866da5cc6dc40ae.png"></p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NXB成员管理系统单页crud</title>
      <link href="/zjh/2022/01/30/NXB%E6%88%90%E5%91%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%8D%95%E9%A1%B5crud/"/>
      <url>/zjh/2022/01/30/NXB%E6%88%90%E5%91%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%8D%95%E9%A1%B5crud/</url>
      
        <content type="html"><![CDATA[<h1 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h1><p>springboot+mybatisplus+lombok+vue+element+axios</p><p><img src="https://img-blog.csdnimg.cn/fd601084dd4d45dba2b44154bef09135.png" alt="案例结构"></p><h1 id="数据属性绑定层面"><a href="#数据属性绑定层面" class="headerlink" title="数据属性绑定层面"></a>数据属性绑定层面</h1><h2 id="数据库与domain绑定"><a href="#数据库与domain绑定" class="headerlink" title="数据库与domain绑定"></a>数据库与domain绑定</h2><p><img src="https://img-blog.csdnimg.cn/e349e9ec3b33419285906d31207d40fa.png" alt="设置自动填充当前时间"><br><img src="https://img-blog.csdnimg.cn/b360980ee55d40f7a55e735ae652a267.png" alt="domain"></p><h2 id="前端属性和domain统一"><a href="#前端属性和domain统一" class="headerlink" title="前端属性和domain统一"></a>前端属性和domain统一</h2><p><img src="https://img-blog.csdnimg.cn/3ec59c343c7240a8bf243366e53c334c.png" alt="名字和domain统一"></p><h1 id="R类的前后端交互"><a href="#R类的前后端交互" class="headerlink" title="R类的前后端交互"></a>R类的前后端交互</h1><p>后端传给前端的是一个R对象，并且需要前端对R对象进行判断解析<br>R类属性：flag\data\msg<br><img src="https://img-blog.csdnimg.cn/d4cb960282f7478d9820fb5011226d18.png"></p><h2 id="后端控制层"><a href="#后端控制层" class="headerlink" title="后端控制层"></a>后端控制层</h2><p><img src="https://img-blog.csdnimg.cn/50f9b0eda19248cab1ab5452454bcd9e.png" alt="返回R对象，设置属性"></p><h2 id="前端视图层"><a href="#前端视图层" class="headerlink" title="前端视图层"></a>前端视图层</h2><p><img src="https://img-blog.csdnimg.cn/5ec3daf8ec704312b30e1795ec3ef397.png" alt="res.data==R"></p><h1 id="异常处理拦截器"><a href="#异常处理拦截器" class="headerlink" title="异常处理拦截器"></a>异常处理拦截器</h1><p><img src="https://img-blog.csdnimg.cn/ad91f2d27bd1457996f435d8420ca2b6.png" alt="返回一个只设置msg的R对象"></p><h1 id="MybatisPlus：持久层-业务层"><a href="#MybatisPlus：持久层-业务层" class="headerlink" title="MybatisPlus：持久层+业务层"></a>MybatisPlus：持久层+业务层</h1><p><img src="https://img-blog.csdnimg.cn/42143a6991b0403f86e14b54cd9c0ec7.png"><br><img src="https://img-blog.csdnimg.cn/61b77d74244b4bebb2b3d0a9c5175094.png"></p><p><img src="https://img-blog.csdnimg.cn/0f5493531971421580cad3a082dac698.png" alt="业务层需要重写分页查询"></p><h1 id="控制层调用业务层接口"><a href="#控制层调用业务层接口" class="headerlink" title="控制层调用业务层接口"></a>控制层调用业务层接口</h1><p><img src="https://img-blog.csdnimg.cn/dcb50e6e5ef442e18cf07411c7277c0e.png" alt="调用业务层接口的方法间接操作数据库"></p><h1 id="前后端对应交互"><a href="#前后端对应交互" class="headerlink" title="前后端对应交互"></a>前后端对应交互</h1><h2 id="分页查询Get"><a href="#分页查询Get" class="headerlink" title="分页查询Get"></a>分页查询Get</h2><p>一个页面要么不分页，要么分页，分页也只能使用同一个分页组件，即便是后面的条件查询，也必须在分页的基础上<br><strong>像下面这种查完不分页的话，在前端是展示不出来的</strong><br><img src="https://img-blog.csdnimg.cn/ff8960944c3e47e88e646afe63d7c4a3.png" alt="错误示例"></p><h3 id="后端-GetMapping-“-currentPage-pageSize-”"><a href="#后端-GetMapping-“-currentPage-pageSize-”" class="headerlink" title="后端@GetMapping(“{currentPage}/{pageSize}”)"></a>后端@GetMapping(“{currentPage}/{pageSize}”)</h3><p><img src="https://img-blog.csdnimg.cn/0f92033ffb954be6a7d2bba187804ebc.png"></p><h3 id="前端钩子函数"><a href="#前端钩子函数" class="headerlink" title="前端钩子函数"></a>前端钩子函数</h3><p><img src="https://img-blog.csdnimg.cn/3c0a0cb658bb49319193dae27ccffdeb.png"></p><h3 id="前端分页查-条件查"><a href="#前端分页查-条件查" class="headerlink" title="前端分页查+条件查"></a>前端分页查+条件查</h3><p><img src="https://img-blog.csdnimg.cn/76f3aa44f3f947c790aa4c8bc62c739b.png" alt="可查id可全查">前端data中定义的是一个变量，而不是对象，所以后端使用@PathVariable来接受<img src="https://img-blog.csdnimg.cn/456e9a2bb20547f6b7f11a3c6778d6b6.png"></p><h3 id="条件查询传路径变量or对象？"><a href="#条件查询传路径变量or对象？" class="headerlink" title="条件查询传路径变量or对象？"></a>条件查询传路径变量or对象？</h3><p>因为这个案例的查询需求是“只要求从ID查询”，所以这里get的第三个参数可以只传一个路径变量this.searchById，后端通过@PathVariable Integer id来接受参数</p><p>如果是需要多条件查，可以通过多个路径变量@PathVariable<br><strong>多条件查如果条件过多，最好直接传一个对象，让后端处理</strong></p><p><strong>但是get方法是不能搭配@RequestBody的，后端直接不要用@RequestBody</strong></p><h2 id="增Post"><a href="#增Post" class="headerlink" title="增Post"></a>增Post</h2><h3 id="后端-RequestBody"><a href="#后端-RequestBody" class="headerlink" title="后端@RequestBody"></a>后端@RequestBody</h3><p><img src="https://img-blog.csdnimg.cn/a1b3590853c5478593ac78014f190673.png"></p><h3 id="前端formData-传对象"><a href="#前端formData-传对象" class="headerlink" title="前端formData:{}传对象"></a>前端formData:{}传对象</h3><p><img src="https://img-blog.csdnimg.cn/472856aa87bb4414b4f56608af9bbf49.png" alt="formData是对象"></p><p><img src="https://img-blog.csdnimg.cn/3e3293406a864102b233ae51c4f4e53c.png"></p><h2 id="删Delete"><a href="#删Delete" class="headerlink" title="删Delete"></a>删Delete</h2><h3 id="后端-删只能通过ID删"><a href="#后端-删只能通过ID删" class="headerlink" title="后端:删只能通过ID删"></a>后端:删只能通过ID删</h3><p><img src="https://img-blog.csdnimg.cn/f523f55642e042a0bb65927913b2cc18.png" alt="不允许删除开发者"></p><h3 id="前端只管传id路径变量"><a href="#前端只管传id路径变量" class="headerlink" title="前端只管传id路径变量"></a>前端只管传id路径变量</h3><p><img src="https://img-blog.csdnimg.cn/30450590f5ca46589a799125d0f81b36.png"></p><h2 id="改Put"><a href="#改Put" class="headerlink" title="改Put"></a>改Put</h2><h3 id="后端：接受对象-RequestBody"><a href="#后端：接受对象-RequestBody" class="headerlink" title="后端：接受对象@RequestBody"></a>后端：接受对象@RequestBody</h3><p><img src="https://img-blog.csdnimg.cn/babc5941f8e249b5921200b2e3e267c2.png"></p><p>前端获取待编辑的数据是不需要分页查询的，因此下面的“非分页条件查询id”是必不可少的</p><p><img src="https://img-blog.csdnimg.cn/93e30f19236b41aeac3b840b6fd6695e.png"></p><h3 id="前端：对于改的逻辑比后端复杂"><a href="#前端：对于改的逻辑比后端复杂" class="headerlink" title="前端：对于改的逻辑比后端复杂"></a>前端：对于改的逻辑比后端复杂</h3><p><img src="https://img-blog.csdnimg.cn/f4cbae77004541c389335095c4bd4b2e.png" alt="绑定点击事件"><br><img src="https://img-blog.csdnimg.cn/7abe1a128d6744eda2ac95753013d829.png" alt="重置表单，清除原有数据"></p><p><img src="https://img-blog.csdnimg.cn/e20417070e1243fa8b6c82c445b87247.png" alt="交互：先读后改"><br>dialogFormVisible4Edit = true后弹出表单，并读取数据<br><img src="https://img-blog.csdnimg.cn/c79b5ed9bcf94d16bc63dbab0088841a.png"><br><img src="https://img-blog.csdnimg.cn/bef7b71f403945d9918ae075545d6552.png" alt="跳转到修改put方法"></p>]]></content>
      
      
      <categories>
          
          <category> Demo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>axios时间交互报400</title>
      <link href="/zjh/2022/01/28/axios%E6%97%B6%E9%97%B4%E4%BA%A4%E4%BA%92%E6%8A%A5400/"/>
      <url>/zjh/2022/01/28/axios%E6%97%B6%E9%97%B4%E4%BA%A4%E4%BA%92%E6%8A%A5400/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>使用axios修改，向后台put请求时，报错400</p><p><img src="https://img-blog.csdnimg.cn/8e7d21bd4b3544999cd3f40238cae5cc.png"></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>后端controller<br><img src="https://img-blog.csdnimg.cn/27c3a5f3a5124714ad1ca6a64fc811cb.png"><br>前端axios.put<br><img src="https://img-blog.csdnimg.cn/5c2f284297a440fa8bff70f950341e4d.png"><br>查看前端控制台</p><p><img src="https://img-blog.csdnimg.cn/68f4c407446f4306a9525bcaefefe288.png" alt="确实PUT请求发出了"></p><p>那么问题就很可能出在了后端</p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>postman测试，仍然报错</p><p><img src="https://img-blog.csdnimg.cn/c1cb6a840e364747af03749e66f4d876.png"></p><p>那么问题基本锁定在后端控制层了<br>查看后端控制台</p><p>postman点击一次put，后台就输出如下内容，仔细阅读后发现</p><p>2022-01-28 14:38:55.920  WARN 17460 — [nio-8080-exec-7] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type <code>java.time.LocalDateTime</code> from String “2022-01-28”: Failed to deserialize java.time.LocalDateTime: (java.time.format.DateTimeParseException) Text ‘2022-01-28’ could not be parsed: <strong>Unable to obtain LocalDateTime from TemporalAccessor: {},ISO,Asia/Shanghai resolved to 2022-01-28 of type</strong> <strong>java.time.format.Parsed</strong>; nested exception is com.fasterxml.jackson.databind.exc.InvalidFormatException: Cannot deserialize value of type <code>java.time.LocalDateTime</code> from String “2022-01-28”: Failed to deserialize java.time.LocalDateTime: (java.time.format.DateTimeParseException) Text ‘2022-01-28’ could not be <strong>parsed: Unable to obtain LocalDateTime from TemporalAccessor</strong>: {},ISO,Asia/Shanghai resolved to 2022-01-28 of type java.time.format.Parsed<EOL> at [Source: (PushbackInputStream); line: 1, column: 75] (through reference chain: com.bootadmin1.bootajaxtest.domain.NXBMembers[“createDate”])]</p><p>指向了时间格式问题，仔细观察发现，后端的数据是这样<br><img src="https://img-blog.csdnimg.cn/29b1ec75b1b54a5fad357a009230e2b7.png" alt="数据库中"><br>而前端的数据是这样<br><img src="https://img-blog.csdnimg.cn/20ab6c6452be4daca14eb6ffc34c75e7.png" alt="页面的格式"></p><p>然后使用postman补全数据，发现还是报错，根据上面的信息考虑是不是前端将数据转为了String，从而无法解析</p><p><img src="https://img-blog.csdnimg.cn/e04aa8c07efe477a80ce9ea3d376db3b.png" alt="仍然报错">结果发现是controller层少写了时间hh:mm:ss<br><img src="https://img-blog.csdnimg.cn/fdedd334f6c74bbbad5eda58543da559.png" alt="添加上"></p><p>重新运行后修改操作还是报错400</p><p>因为时间不需要修改，在此尝试直接不传日期数据（属于是掩耳盗铃，不过没办法）<br>把this.formData = res.data直接list赋值改为属性赋值<br><img src="https://img-blog.csdnimg.cn/2ecddf31edb94b368c36120b0696b3d6.png" alt="但是不能三个属性都双向绑定，否则都不能修改"></p><p><img src="https://img-blog.csdnimg.cn/17d0d8c481704f72a817164e1d0111ad.png" alt="不要绑定position"></p><pre><code>      //弹出编辑窗口        handleUpdate(row) &#123;            axios.get(&quot;/nxbmem/&quot;+row.memberid).then((res)=&gt;&#123;                // if(res.data.flag &amp;&amp; res.data != null )&#123;                    this.dialogFormVisible4Edit = true;                    this.formData.username = res.data.username;                    this.formData.memberid = res.data.memberid;                    // this.formData.position = res.data.position;                //我们希望不能修改id和name，可以修改position                //因此position不要动态双向绑定                //一定要一个属性一个属性的挨个赋值，否则会把不想重传的属性给赋值重传了                //并且可以防止有些属性不便于修改所带来的问题                // &#125;else&#123;                //     this.$message.error(&quot;数据同步失败，自动刷新&quot;);                // &#125;            &#125;).finally(()=&gt;&#123;                //2.重新加载数据                this.getAll();            &#125;);        &#125;,        //修改        handleEdit() &#123;            axios.put(&quot;/nxbmem&quot;,this.formData).then((res)=&gt;&#123;                //判断当前操作是否成功                    //1.关闭弹层                    this.dialogFormVisible4Edit = false;                    this.$message.success(&quot;自动刷新&quot;);                    // this.$message.error(&quot;修改失败&quot;);            &#125;).finally(()=&gt;&#123;                //2.重新加载数据                this.getAll();            &#125;);        &#125;,</code></pre><p>这样后台就成这样了~<br><img src="https://img-blog.csdnimg.cn/06b27812b6c54529b80bf880c7b2cdde.png" alt="可以正常修改"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>由于前端对数据类型并不会区分，后端传的啥前端就显示啥，所以DateTime的前端显示和后端输出不一致，需要指定@JsonFormat</p><pre><code>  @TableField(value = &quot;creatDate&quot;)  @JsonFormat(pattern = &quot;yyyy-MM-dd hh:mm:ss&quot;, timezone = &quot;Asia/Shanghai&quot;)  private LocalDateTime createDate;</code></pre></li></ul><ul><li>并且即便是格式相同，也只能一定保证前端正确接受，而前端如果设置时间post给后端，后端可能需要额外重写业务层的post逻辑</li></ul>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BindingException: Invalid bound statement (not found)</title>
      <link href="/zjh/2022/01/28/BindingException-Invalid-bound-statement-not-found/"/>
      <url>/zjh/2022/01/28/BindingException-Invalid-bound-statement-not-found/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>springboot+mybatisplus<br>报错：未绑定<br>只是对ID(主键)进行操作的时候会有这个绑定的错误</p><p><img src="https://img-blog.csdnimg.cn/d7ea186d0d07478cb52840670e3154f6.png"></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ul><li>springboot不是配置地狱，既然其他与ID无关的操作都能跑，那问题基本是出在了主键绑定上了</li><li>而mybatis plus+springboot会自动扫描，扫描等配置问题可以不考虑</li><li>而主键，属性的绑定是在domain层，所以去找这个对应的Bean</li></ul><p><img src="https://img-blog.csdnimg.cn/66271f245f8048a6b4c0d73222153575.png" alt="定位到pojo层"><br>将@TableField改为@TableID，绑定主键</p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合SSM</title>
      <link href="/zjh/2022/01/28/springboot%E6%95%B4%E5%90%88SSM/"/>
      <url>/zjh/2022/01/28/springboot%E6%95%B4%E5%90%88SSM/</url>
      
        <content type="html"><![CDATA[<h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><h2 id="整合JUnit"><a href="#整合JUnit" class="headerlink" title="整合JUnit"></a>整合JUnit</h2><ul><li><p>@SpringBootTest支持@Autowired注入</p></li><li><p>Test依赖会自动生成</p><p>  @SpringBootTest//表示这是一个测试类<br>  class BootAjaxtestApplicationTests {</p><p>  //1,@Autowired注入要测试的对象</p><p>  @Test//各个Test方法<br>  void contextLoads() {<br>  //2，Test方法体中调用注入对象的方法或属性</p><p>  }</p><p>  @Test<br>  void contextLoads2() {<br>  }}    </p></li></ul><h3 id="任意位置test-设置引导类"><a href="#任意位置test-设置引导类" class="headerlink" title="任意位置test(设置引导类)"></a>任意位置test(设置引导类)</h3><p>如果更改了测试类的位置，那么需要修改为<br>@SpringBootTest(classes = 主类名.class)<br><strong>即指明测试集的配置类是主类下的 or 这个测试类是主类的测试类</strong></p><h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><h3 id="配置yml"><a href="#配置yml" class="headerlink" title="配置yml"></a>配置yml</h3><pre><code>spring:  datasource:    username: 账号(通常为root)    password: 密码    url: jdbc:mysql://localhost:3306/数据库名    driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><ul><li>url后可以接时区，utf-8等设置</li><li>mysql5.0驱动名去掉cj</li></ul><h3 id="Mybatis测试"><a href="#Mybatis测试" class="headerlink" title="Mybatis测试"></a>Mybatis测试</h3><h4 id="dao层的使用"><a href="#dao层的使用" class="headerlink" title="dao层的使用"></a>dao层的使用</h4><p><strong>DAO层定义的接口可以添加一些方法，并且可以直接注入使用，如果不进行前后端交互，仅仅使用接口就可以了</strong></p><p><a href="https://blog.csdn.net/mn_kw/article/details/80985392">链接：domain和dao层</a><br><strong>domain类就是bean类</strong><br><strong>有dao和domain才能从数据库拿出来的数据编程bean，bean又可以通过ajax技术转为json和前端交互</strong></p><p>@Mapper使其被容器识别到<br>@Mapper的作用是可以给mapper接口自动生成一个实现类,让spring对mapper接口的bean进行管理,并且可以省略去写复杂的xml文件<br>    <img src="https://img-blog.csdnimg.cn/f7620aa9c03d4632bac0c875a2be71b7.png" alt="定义Dao接口"></p><pre><code>@Mapperpublic interface YebDao &#123;    @Select(&quot;select * from t_joblevel where id = #&#123;id&#125;&quot;)    public JobLevel getById(Integer id);&#125;</code></pre><p>需要注入<br><img src="https://img-blog.csdnimg.cn/3fd0cdc8cc904e24a1e49a41041499fa.png" alt="注入，测试"></p><pre><code>@SpringBootTest//表示这是一个测试类class BootAjaxtestApplicationTests &#123;    //1,@Autowired注入要测试的对象,Dao接口也可以注入@Autowiredprivate YebDao yebDao;//可能会假报错，能正常运行    //注入了Dao接口，可以使用Dao定义的@Select    @Test    void sql1() &#123;        System.out.println(yebDao.getById(1));    &#125;&#125;</code></pre><h2 id="整合MyBatis-Plus"><a href="#整合MyBatis-Plus" class="headerlink" title="整合MyBatis-Plus"></a>整合MyBatis-Plus</h2><p>这玩意是真的叼~<br><strong>extends BaseMapper&lt;&gt;之后连sql都可以不用写了</strong></p><h3 id="1，添加坐标依赖"><a href="#1，添加坐标依赖" class="headerlink" title="1，添加坐标依赖"></a>1，添加坐标依赖</h3><p>MyBatis-Plus是国内开发的，只能通过手动在pom.xml添加依赖</p><pre><code>        &lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;3.5.0&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>坐标查询方式在上面的两个大标题中</p><h3 id="2，定义数据层接口于映射配置"><a href="#2，定义数据层接口于映射配置" class="headerlink" title="2，定义数据层接口于映射配置"></a>2，定义数据层接口于映射配置</h3><pre><code>@Mapperpublic interface YebDao extends BaseMapper&lt;JobLevel&gt; &#123;   //继承BaseMapper，作用于JobLevel的Bean&#125;</code></pre><h3 id="3，MyBatisPlus可用的CRUD方法"><a href="#3，MyBatisPlus可用的CRUD方法" class="headerlink" title="3，MyBatisPlus可用的CRUD方法"></a>3，MyBatisPlus可用的CRUD方法</h3><p><img src="https://img-blog.csdnimg.cn/0ef764fe9ad74536ba802e2d7e161b2f.png" alt="包含了太多方法了，CRUD啥都有"><a href="https://www.jianshu.com/p/ceb1df475021">链接：方法使用示例</a></p><h4 id="一定要关闭驼峰命名"><a href="#一定要关闭驼峰命名" class="headerlink" title="一定要关闭驼峰命名"></a>一定要关闭驼峰命名</h4><pre><code>mybatis-plus:  configuration:    # 是否开启自动驼峰命名规则（camel case）映射，#    即从经典数据库列名 A_COLUMN（下划线命名） #    到经典 Java 属性名 aColumn（驼峰命名） 的类似映射    map-underscore-to-camel-case: false</code></pre><h2 id="整合Druid"><a href="#整合Druid" class="headerlink" title="整合Druid"></a>整合Druid</h2><p>同样，德鲁伊是阿里开发的数据源（数据连接池）框架，需要在maven repository找坐标<br>    <img src="https://img-blog.csdnimg.cn/ea0773633f974665bb8ef656987ea1b9.png" alt="选择启动器"></p><pre><code>&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt; /****************application.yml************/#spring:#  datasource:#    username: root#    password: zjh521418#    url: jdbc:mysql://localhost:3306/yeb#    driver-class-name: com.mysql.cj.jdbc.Driver##    type: com.alibaba.druid.pool.DruidDataSource在标准配置下加这句，或下面整合配置：spring:   datasource:    druid:      username: root      password: zjh521418      url: jdbc:mysql://localhost:3306/yeb      driver-class-name: com.mysql.cj.jdbc.Driver#德鲁伊专用配置法</code></pre><h2 id="整合总结"><a href="#整合总结" class="headerlink" title="整合总结"></a>整合总结</h2><ul><li>导入对应的starter依赖</li><li>对非默认值的项进行配置</li></ul><h1 id="postman测试接口"><a href="#postman测试接口" class="headerlink" title="postman测试接口"></a>postman测试接口</h1><p><a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a><br><a href="https://www.jianshu.com/p/d3eaed7b876a">教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot注意点1</title>
      <link href="/zjh/2022/01/28/springboot%E6%B3%A8%E6%84%8F%E7%82%B91/"/>
      <url>/zjh/2022/01/28/springboot%E6%B3%A8%E6%84%8F%E7%82%B91/</url>
      
        <content type="html"><![CDATA[<h1 id="边缘知识"><a href="#边缘知识" class="headerlink" title="边缘知识"></a>边缘知识</h1><h2 id="tomcat服务器"><a href="#tomcat服务器" class="headerlink" title="tomcat服务器"></a>tomcat服务器</h2><p>tomcat是用java编写的服务器，在springboot中把tomcat的内容全部托管，因此可以使用tomcat服务器。但需要导入依赖tomcat-embed-core和spring-boot-starter-tomcat</p><p>同时tomcat也可以被其他的技术所替换，例如Jetty:spring-boot-starter-Jetty<br>例如:undertow<br><strong>轻量级的项目可以尝试使用以下配置，tomcat负载能力较强！</strong><br><img src="https://img-blog.csdnimg.cn/234a6f7d00104eeea27db83136fc8ac7.png" alt="剔除tomcat依赖，导入jetty依赖"></p><p><strong>springboot封装了这些技术，如果发现哪个技术不好用，直接改依赖就好了~~</strong></p><h2 id="REST风格开发-风格不是规范"><a href="#REST风格开发-风格不是规范" class="headerlink" title="REST风格开发(风格不是规范)"></a>REST风格开发(风格不是规范)</h2><p>Representational State Transfer:表现形式状态转换——一种访问网络资源的格式</p><p><img src="https://img-blog.csdnimg.cn/de6261b1d72545b284a66cc97906b243.png" alt="定义"><br><img src="https://img-blog.csdnimg.cn/95326a9abe5d4c978b145b90545219a4.png" alt="常见访问行为"></p><h3 id="哪些不同？"><a href="#哪些不同？" class="headerlink" title="哪些不同？"></a>哪些不同？</h3><p>例如：</p><ul><li>在controller包下的UserController类中，@RequestMapping有8种提交方式method,通过不同的提交方式来区分上图种的不同访问行为</li><li>路径变量@PathVariable的格式要注意</li></ul><p><img src="https://img-blog.csdnimg.cn/71710de3e6bb477f813fa3f288927c42.png" alt="简化操作"></p><pre><code>//Rest模式@RestController@RequestMapping(&quot;该BookController下的跟访问路径&quot;)public class BookController &#123;    @GetMapping//可以带路径参数，没有可以不写    public String getById()&#123;        System.out.println(&quot;springboot is running...&quot;);        return &quot;springboot is running...&quot;;    &#125;&#125;</code></pre><h2 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h2><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/">springboot——application-properties官方文档</a></p><p><strong>“每一个配置对应的都是一种技术”</strong></p><h3 id="同时出现properties-yml-yaml时"><a href="#同时出现properties-yml-yaml时" class="headerlink" title="同时出现properties.yml.yaml时"></a>同时出现properties.yml.yaml时</h3><ul><li>不同属性相互叠加</li><li>相同属性优先级：properties&gt;yml&gt;yaml</li></ul><h3 id="yml-yaml没有自动提示"><a href="#yml-yaml没有自动提示" class="headerlink" title="yml yaml没有自动提示"></a>yml yaml没有自动提示</h3><p>弹提示的功能是springboot提供的，而不是idea提供的<br><a href="https://www.bilibili.com/video/BV15b4y1a7yG?p=20&spm_id_from=pageDriver">链接：解决属性提示消失</a></p><p><img src="https://img-blog.csdnimg.cn/dd67d73d9653432abbcb2c05ab4b111e.png" alt="yaml为什么优秀">注：</p><ul><li>IDEA处理yml文件可以使用tab</li><li>不用加引号</li></ul><h3 id="单一取值-Value-SpEL"><a href="#单一取值-Value-SpEL" class="headerlink" title="单一取值@Value + SpEL"></a>单一取值@Value + SpEL</h3><ul><li>只能在注册类中使用，例如@RestController下</li><li>可能跟Lombok下的@value冲突</li></ul><p>已经在application.yml文件中配置了</p><pre><code>user1:  name: 张家豪users3: [&#123;name:zhangsan,age:18&#125;,&#123;name:lisi,age:17&#125;]users2:  -    name: zhangsan    age: 18  -    name: lisi    age: 17</code></pre><p>那么可以在任意位置按如下操作取值</p><pre><code>@Value(&quot;$&#123;name2[1].name&#125;&quot;)//取出1号索引位的lisiprivate String namexxx;//赋值给namexxx</code></pre><h3 id="在配置中引用配置"><a href="#在配置中引用配置" class="headerlink" title="在配置中引用配置"></a>在配置中引用配置</h3><pre><code>yml文件中baseDir: d:/spring/springboottempDir: $&#123;baseDir&#125;/temp</code></pre><h3 id="转义解析"><a href="#转义解析" class="headerlink" title="转义解析"></a>转义解析</h3><p>yml文件不需要加引号“” 如果加了引号，内容将被解析，比如</p><pre><code>tempDir: &quot;$&#123;baseDir&#125;/temp&quot;会被转义出一个/t制表符</code></pre><h2 id="自动装配Environment"><a href="#自动装配Environment" class="headerlink" title="自动装配Environment"></a>自动装配Environment</h2><pre><code>@Autowiredprivate Environment environment;</code></pre><p>这样一来，所有配置信息都封装了，引用的时候用getProperties就可以取出</p><h2 id="Spring的取数据方式：Bean绑定"><a href="#Spring的取数据方式：Bean绑定" class="headerlink" title="Spring的取数据方式：Bean绑定"></a>Spring的取数据方式：Bean绑定</h2><p>Bean包下</p><pre><code>@Component//注入容器，让这个bean成为spring管控的bean@ConfigurationProperties(prefix = &quot;user1&quot;)//前缀//因为配置了// user1://  name: 张家豪//  age: 21@Data//lombok下的的注解，提供get set等方法public class UserBean &#123;    private String name;    private int age;&#125;</code></pre><p>controller包下</p><pre><code>@AutowiredUserBean userBean;//实例化bean@GetMapping(&quot;/test&quot;)    public void beantest()&#123;        System.out.println(userBean);//当页面访问时，控制台输出    &#125;</code></pre><h3 id="Autowired和Bean注意点"><a href="#Autowired和Bean注意点" class="headerlink" title="Autowired和Bean注意点"></a>Autowired和Bean注意点</h3><p>这两个都是配套使用，Bean代表只有这一个单例并绑定配置文件的哪个前缀；Autowired是注入Bean实例<br>这个userBean实例只能在当前的controller层读取，不能在其他地方使用</p>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>axios+element+vue的前端数据交互框架</title>
      <link href="/zjh/2022/01/26/axios-element-vue%E7%9A%84%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E6%A1%86%E6%9E%B6/"/>
      <url>/zjh/2022/01/26/axios-element-vue%E7%9A%84%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Element基本结构"><a href="#Element基本结构" class="headerlink" title="Element基本结构"></a>Element基本结构</h1><p>一个网页组件库，需要调用导入的库，语法比较特别，不同于前端语法</p><p><strong>固定的几个引入链接，位置千万不能弄错</strong>，链接的作用是在线引入渲染文件，可以不用下载到本地<br>添加组件和修改功能只再body中的div  和 script中的new Vue代码块中进行，并且要注意绑定~~<br><a href="https://element.eleme.cn/#/zh-CN/component/button">Element官网</a><br>Element给出的代码是一整块，需要自己区分哪个是组件，哪个是依赖，哪个是控制，分别放入哪个位置<br><img src="https://img-blog.csdnimg.cn/3050347e2d1a48f589b657ce16f9156e.png"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;后台管理&lt;/title&gt;&lt;!--Style相当于CSS--&gt;&lt;!-- 引入样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui/lib/theme-chalk/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;对应模块名&quot;&gt;    &lt;!--这里放入组件--&gt;  &lt;/div&gt;&lt;/body&gt;&lt;!-- import Vue before Element --&gt;&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;!-- import JavaScript --&gt;&lt;script src=&quot;https://unpkg.com/element-ui/lib/index.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    &lt;!--Vue的核心对象相当于js--&gt;    new Vue(&#123;        el:&quot;#对应模块名&quot;    &#125;)&lt;/script&gt;&lt;/html&gt;</code></pre><h1 id="组件布局：表格"><a href="#组件布局：表格" class="headerlink" title="组件布局：表格"></a>组件布局：表格</h1><h2 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h2><pre><code>&lt;template&gt;引入&lt;body&gt;&lt;style&gt;引入&lt;head&gt;&lt;script&gt;引入new Vue(&#123;    el:&quot;#对应模块名&quot;,    )&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/66c55d2e4e754dd2afa82bbcf6a7f3da.png"></p><h3 id="修改表的结构，内容"><a href="#修改表的结构，内容" class="headerlink" title="修改表的结构，内容"></a>修改表的结构，内容</h3><ul><li><p>要把templeate和@data()中return的tableData:[{ ]}对应都修改了</p></li><li><p>align=”center”</p></li><li><p>注意配置要被左&lt;&gt;包裹</p><h3 id="添加数据无关列-操作按钮"><a href="#添加数据无关列-操作按钮" class="headerlink" title="添加数据无关列(操作按钮)"></a>添加数据无关列(操作按钮)</h3></li><li><p>先添加一个操作列operate</p></li><li><p>这个列不需要属性prop</p></li><li><p>这个列都需要操作按钮，所以把按钮放在列中</p><pre><code>  &lt;template&gt;  &lt;el-table&gt;      ......略      &lt;el-table-column                  align=&quot;center&quot;                  label=&quot;操作&quot;&gt;  &lt;!--这个列不需要属性，所以不加prop--&gt;          &lt;el-row&gt;              &lt;el-button type=&quot;primary&quot; icon=&quot;el-icon-edit&quot; circle&gt;&lt;/el-button&gt;              &lt;el-button type=&quot;danger&quot; icon=&quot;el-icon-delete&quot; circle&gt;&lt;/el-button&gt;          &lt;/el-row&gt;  &lt;!--按钮放在table-column列中，每列都有--&gt;      &lt;/el-table-column&gt;      &lt;/el-table&gt;  &lt;/template&gt;</code></pre></li></ul><h3 id="数字编号"><a href="#数字编号" class="headerlink" title="数字编号"></a>数字编号</h3><p><img src="https://img-blog.csdnimg.cn/503071d83ceb4d418a41994a4c04a1a5.png" alt="找到了有数字编号的(不同于id)">这个数字编号是第一列，所以去源码中找第一列  直接扔进去</p><pre><code>   &lt;el-table-column  type=&quot;index&quot;  width=&quot;50&quot;&gt;&lt;/el-table-column&gt;</code></pre><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>同理，找到有复选框的源码，选择第一列</p><h3 id="复选取对象：可以批量操作"><a href="#复选取对象：可以批量操作" class="headerlink" title="复选取对象：可以批量操作"></a>复选取对象：可以批量操作</h3><ul><li>表头属性加@selection-change=”handleSelectionChange”</li><li>在method屁股后面 handleSelectionChange(val) {<pre><code>  this.multipleSelection = val;  可以添加具体执行方法&#125;，</code></pre></li><li>在data()return{}中添加multipleSelection: []，注意不要加到tabledata中了</li></ul><h3 id="批量删除、新增按钮"><a href="#批量删除、新增按钮" class="headerlink" title="批量删除、新增按钮"></a>批量删除、新增按钮</h3><ul><li>添加<strong>按钮</strong>，绑定@click事件，点击后弹出对话框<br><img src="https://img-blog.csdnimg.cn/bd023d9dd3ef415c9318d3059b5c760b.png" alt="官方文档解析"></li></ul><h3 id="对话框-表单：查询和新增"><a href="#对话框-表单：查询和新增" class="headerlink" title="对话框+表单：查询和新增"></a>对话框+表单：查询和新增</h3><p>当点击“新增”按钮的时候，弹出对话框，对话框的内容是一个表单，表单中填数据，点击“确定”则POST给服务器，返回一个是否成功的信息</p><h4 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h4><ul><li>点击按钮弹出对话框@click=” 对话框名 “</li><li>对话框设置对应的“对话框名” :visible.sync=”对话框名”</li><li>在return中添加初始不可见 对话框名:false</li></ul><pre><code>    &lt;!--批量删除、新增按钮--&gt;    &lt;el-row&gt;        &lt;el-button type=&quot;danger&quot; &gt;批量删除&lt;/el-button&gt;        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible1=true&quot; &gt;新增&lt;/el-button&gt;        &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible2=true&quot; &gt;查询&lt;/el-button&gt;        &lt;!--查询用dialogVisible2表单--&gt;    &lt;/el-row&gt;    &lt;!--新增对话框dialogVisible1--&gt;    &lt;el-dialog            title=&quot;新增数据，填写表单后确定&quot;            :visible.sync=&quot;dialogVisible1&quot;            width=&quot;30%&quot;           &gt;        &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;    &lt;el-button @click=&quot;dialogVisible1 = false&quot;&gt;取 消&lt;/el-button&gt;    &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible1 = false&quot;&gt;确 定&lt;/el-button&gt;            &lt;!--确定取消都使dialogVisible1不可见--&gt;  &lt;/span&gt;    &lt;/el-dialog&gt;    &lt;!--查询对话框dialogVisible2--&gt;    &lt;el-dialog            title=&quot;新增数据，填写表单后查询&quot;            :visible.sync=&quot;dialogVisible2&quot;            width=&quot;30%&quot;    &gt;        &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;    &lt;el-button @click=&quot;dialogVisible2 = false&quot;&gt;取 消&lt;/el-button&gt;    &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible2 = false&quot;&gt;查 询&lt;/el-button&gt;            &lt;!--确定取消都使dialogVisible2不可见--&gt;  &lt;/span&gt;    &lt;/el-dialog&gt;/*********************************************/ data() &#123;            return &#123;            dialogVisible1: false,            dialogVisible2: false,            //表单初始不可见，必须设置，不然点都点不出来&#125;&#125;</code></pre><h3 id="新增表单"><a href="#新增表单" class="headerlink" title="新增表单"></a>新增表单</h3><p>添加在两个el-dialog对话框&lt;&gt;尖括号之间</p><h3 id="查询表单"><a href="#查询表单" class="headerlink" title="查询表单"></a>查询表单</h3><p>添加在两个el-dialog对话框&lt;&gt;尖括号之间</p><ul><li>这个案例的查询功能为：同时选定职称名 和 职称等级</li></ul><h3 id="前端页面框架"><a href="#前端页面框架" class="headerlink" title="前端页面框架"></a>前端页面框架</h3><ul><li>批量删除需要getID的List</li><li>查询可以共用一个模型绑定数据</li></ul><p><img src="https://img-blog.csdnimg.cn/19ad40a967454ea5897ed7c5ff7d1f17.png" alt="基本结构"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>File的一些细节</title>
      <link href="/zjh/2022/01/25/File%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/"/>
      <url>/zjh/2022/01/25/File%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h1 id="File对象实例化"><a href="#File对象实例化" class="headerlink" title="File对象实例化"></a>File对象实例化</h1><p>三种构造器</p><pre><code>File file = new File(&quot;C:\\Users\\Administrator\\Desktop\\数据结构代码\\algorithm&quot;);//绝对路径File file1 = new File(file,&quot;testtss.txt&quot;);//根据parent和child构造File file2 = new File(file,&quot;test&quot;);//相对路径</code></pre><p>相对路径的例子：</p><pre><code>    用junit单元测试创建的文件在当前moudle下    在main中创建的文件在当前project下</code></pre><p>跨平台路径分隔符</p><pre><code>    File file3 = new File(&quot;D:&quot; + File.separator + &quot;io&quot; + File.separator + &quot;test11.txt&quot;)</code></pre><ul><li>File对象的实例化仅仅是内存层面开辟了一个空间</li><li>File对象可以存储<strong>文件</strong>，也可以存储<strong>文件目录</strong></li><li>File对象表示的是<strong>路径的最后一个文件</strong>，例如：”C:\Users\Administrator\Desktop\数据结构代码\algorithm”的对象对其操作更改的是algorithm文件目录<br><img src="https://img-blog.csdnimg.cn/7a49bfba1e4f42128289965a77f5c149.png" alt="该文件目录实际存在与否的区别"><h1 id="部分API"><a href="#部分API" class="headerlink" title="部分API"></a>部分API</h1><table><thead><tr><th>方法</th><th>解释</th><th>备注</th></tr></thead><tbody><tr><td>createTempFile</td><td><br>(String prefix, String suffix) <br> (String prefix, String suffix, File directory)</td><td>static方法，“创建空文件”<br>文件名前缀(最少3字符)，文件名后缀<br>前缀，后缀，指定路径的File对象</td></tr><tr><td>deleteOnExit</td><td>run结束后就删掉</td><td>创建的方式是mkdirs，但删除时是只删除该File对象路径的最末尾文件</td></tr><tr><td>delete</td><td>删除File对象对应的文件or文件目录</td><td>必须保证是末梢路径，不然不能删除并且返回false</td></tr><tr><td>renameTo(File dest)</td><td>1,如果<strong>destFile对象与源文件File对象</strong>是在同一个路径下，那么renameTo的作用是重命名<br> 2,如果目标文件与源文件不是在同一个路径下，那么renameTo的作用就是剪切，而且还不能操作文件夹。</td><td>见代码详解 [^1]</td></tr><tr><td>getParent<br>getParentFile</td><td>返回父路径String<br>返回父路径File</td><td>用于同路径创建等操作</td></tr><tr><td>length</td><td>返回字节长度long</td><td>非空小文件的length返回值可能为0</td></tr></tbody></table></li></ul><p><a href="https://www.cnblogs.com/wangjinlong-padan/p/6382924.html">参考链接</a></p><p>[^1]:</p><pre><code>    File file1 = new File(&quot;D:\\io\\io2\\io3\\start.txt&quot;);    System.out.println(file1.createNewFile());//true创建成功，存在则false    File file2 = new File(&quot;D:\\io\\io1\\io3\\dest.txt&quot;);    System.out.println(file1.renameTo(file2));//dest不存在，则true    // &quot;D:\\io\\io2\\io3\\start.txt&quot;变成了&quot;D:\\io\\io1\\io3\\dest.txt&quot;( 路径不同：剪切 )    //若dest文件已存在，则返回false    File file3 = new File(&quot;D:\\io\\io1\\io3\\file.txt&quot;);    System.out.println(file2.renameTo(file3));( 同路径：重命名)</code></pre><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><h3 id="1，遍历删除"><a href="#1，遍历删除" class="headerlink" title="1，遍历删除"></a>1，遍历删除</h3><p>要求：</p><ul><li>遍历d:\io目录下的所有文件and文件目录名</li><li>删除png，img格式的文件，并告知删除成功</li></ul><p>代码示例：</p><pre><code>public class FileTest1 &#123;    public static void intoDir(File f)&#123;//定义静态方法            File[] files = f.listFiles();//罗列内部所有File对象        for(File ff : files)&#123;            if (ff.isFile())&#123;                System.out.println(&quot;文件&quot; + ff.toString());                /*****************删除img，png格式的图片文件**********/                if(ff.toString().endsWith(&quot;img&quot;) || ff.toString().endsWith(&quot;png&quot;))&#123;                    ff.delete();                    System.out.println(&quot;删除成功：&quot;+ff.toString());                &#125;                /****************************************************/            &#125;            else&#123;                System.out.println(&quot;文件目录&quot; + ff.toString());                intoDir(ff);//递归            &#125;        &#125;    &#125;    public static void main(String[] args) throws IOException &#123;    File file = new File(&quot;D:\\io&quot;);   FileTest1.intoDir(file);//调用静态遍历方法    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/7d1eec4e4ffa462dbea8d2fadcb2a6d4.png" alt="运行结果"></p><h3 id="2，遍历计算大小"><a href="#2，遍历计算大小" class="headerlink" title="2，遍历计算大小"></a>2，遍历计算大小</h3><p>要求：</p><ul><li>计算指定文件目录的大小</li><li>删除空文件（不是删空的文件目录）</li></ul><p>代码示例：</p><pre><code>public class FileTest1 &#123;    public static long sumLength(File file)&#123;        File[] files = file.listFiles();        long sum = 0;        for(File f : files)&#123;            if (f.isFile())&#123;                /****判断是否为空文件，若是则删除并告知****/                long length = f.length();                if(length == 0)&#123;                    f.delete();                    System.out.println(&quot;删除空文件：&quot;+f.toString());                &#125;                else&#123;                    sum += length;                &#125;                /*******************  *****************/            &#125;            else&#123;                FileTest1.sumLength(f);            &#125;        &#125;        return sum;    &#125;    public static void main(String[] args) &#123;        File file = new File(&quot;D:\\io&quot;);        long l = FileTest1.sumLength(file);        System.out.println(&quot;该文件总长为：&quot;+l);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/42f104763d8742e3b6dd707a10e1b2e6.png" alt="运行结果"></p><h3 id="为什么最后的文件总长计算结果为0？"><a href="#为什么最后的文件总长计算结果为0？" class="headerlink" title="为什么最后的文件总长计算结果为0？"></a>为什么最后的文件总长计算结果为0？</h3><p> <strong>因为小文件会内联存储</strong></p><p><a href="https://www.zhihu.com/question/23972911?rf=51585723">NTFS文件系统是如何处理小文件的</a></p><p><a href="https://product.pconline.com.cn/itbk/software/dnyw/1703/8961027.html">占用空间和文件大小的区别</a><br>| |大小对比 |解释 |<br>|–|–|–|<br>小文件|文件大小 &gt; 占用空间<br>通常占用空间为0|因为小文件内联存储<br>大文件|文件大小 &lt; 占用空间|大文件占用空间包括了<strong>没有使用的簇</strong>的空间大小</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IO:TCP URL网络编程</title>
      <link href="/zjh/2022/01/25/IO-TCP-URL%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/zjh/2022/01/25/IO-TCP-URL%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>方便起见，所有代码都直接throws异常，没有处理<br>以“Client把文件上传至Server为例”</p><h2 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h2><ul><li>Socket s = new Socket(“Sever的IP地址” , 端口号);</li><li>OutputStream os = s.getOutputStream();</li></ul><ol><li>先建立Socket连接</li><li>“上传文件”，所以getOutputStream</li><li>普通IO(FileInputStream)先读取文件，然后赋值给网络IO流</li></ol><pre><code>    public class Client9548 &#123;    public static void main(String[] args) throws IOException &#123;        //Client IP：192.168.3.82        Socket clientsocket = new Socket(&quot;192.168.3.47&quot;,9548);//Server的IP，共用的端口        File file = new File(&quot;D:\\FFOutput\\201983250028张家豪.docx&quot;);        OutputStream outputStream = clientsocket.getOutputStream();//从Client输出        FileInputStream fis = new FileInputStream(file);        byte[] bbuf = new byte[1024];        int len;        while((len=fis.read(bbuf))!=-1)&#123;            outputStream.write(bbuf,0,len);        &#125;        outputStream.close();        fis.close();            &#125;&#125;</code></pre><h2 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h2><ul><li>ServerSocket ss = new ServerSocket(端口号);</li><li>Socket s = ss.accept();</li><li>InputStream is = s.getInputStream();</li></ul><ol><li>Server端会多一个ServerSocket端口，并且也需要额外关闭</li><li>“接受文件”，所以s.getInputStream();</li><li>其他的本地读写操作都是普通IO</li></ol><p>public class Server9548 {<br>    public static void main(String[] args) throws IOException {<br>//Server IP:192.168.3.47<br>        ServerSocket serverSocket = new ServerSocket(9548);//new ServerSocket，端口和Client端口保持一致</p><pre><code>    Socket sa = serverSocket.accept();//SeverScoket——&gt;socket    InputStream is = sa.getInputStream();//输入流，接受来自Client的文件数据    //这下面创建输出流，保存在硬盘    File file = new File(&quot;D:\\fromClient\\file4.docx&quot;);    FileOutputStream fos = new FileOutputStream(file);   byte[] bbuf = new byte[1024];    int len;    while((len=is.read(bbuf))!=-1)&#123;        fos.write(bbuf);    &#125;        fos.close();    sa.close();    serverSocket.close();//注意接口关闭    &#125;</code></pre><p>}</p><h1 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h1><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><pre><code>URL url = new URL(&quot;http://localhost:8080/examples/myTest.txt&quot;);System.out.println(&quot;getProtocol() :&quot;+url.getProtocol());System.out.println(&quot;getHost() :&quot;+url.getHost());System.out.println(&quot;getPort() :&quot;+url.getPort());System.out.println(&quot;getPath() :&quot;+url.getPath());System.out.println(&quot;getFile() :&quot;+url.getFile());System.out.println(&quot;getQuery() :&quot;+url.getQuery());</code></pre><p><img src="https://img-blog.csdnimg.cn/7a6dc6222f614b6fa15ce2b6a1a926b4.png"></p><h2 id="从指定网址下载指定文件"><a href="#从指定网址下载指定文件" class="headerlink" title="从指定网址下载指定文件"></a>从指定网址下载指定文件</h2><pre><code>public class URLTest1 &#123;    public static void main(String[] args) throws IOException &#123;        URL url1 = new URL(&quot;https://img-blog.csdnimg.cn/img_convert/5cef01f2bb72055365b892b39b01cdfb.png&quot;);//URL地址        HttpURLConnection hURLc =  (HttpURLConnection) url1.openConnection();//建立URL连接+强转        hURLc.connect();//连接        //从该URL地址下载，input流        InputStream URLis = hURLc.getInputStream();        //导入本地，普通IO        File file = new File(&quot;temp1.jpg&quot;);        FileOutputStream fos = new FileOutputStream(file);        //从Client读，并写到Server硬盘        byte[] bbuf = new byte[1024];        int len;        while((len=URLis.read(bbuf))!=-1)&#123;            fos.write(bbuf,0,len);        &#125;                URLis.close();        fos.close();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/zjh/2022/01/25/JDBC/"/>
      <url>/zjh/2022/01/25/JDBC/</url>
      
        <content type="html"><![CDATA[<p>java.sql支持多数据库访问</p><ul><li>Java与SQL对应数据类型转换表</li></ul><table><thead><tr><th>Java类型</th><th>SQL类型</th></tr></thead><tbody><tr><td>boolean</td><td>BIT</td></tr><tr><td>byte</td><td>TINYINT</td></tr><tr><td>short</td><td>SMALLINT</td></tr><tr><td>int</td><td>INTEGER</td></tr><tr><td>long</td><td>BIGINT</td></tr><tr><td>String</td><td>CHAR,VARCHAR,LONGVARCHAR</td></tr><tr><td>byte array</td><td>BINARY , VAR BINARY</td></tr><tr><td>java.sql.Date</td><td>DATE</td></tr><tr><td>java.sql.Time</td><td>TIME</td></tr><tr><td>java.sql.Timestamp</td><td>TIMESTAMP</td></tr></tbody></table><h1 id="连接，mysql重点用第4个"><a href="#连接，mysql重点用第4个" class="headerlink" title="连接，mysql重点用第4个"></a>连接，mysql重点用第4个</h1><h2 id="1，不出现第三方API，高可移植性"><a href="#1，不出现第三方API，高可移植性" class="headerlink" title="1，不出现第三方API，高可移植性"></a>1，不出现第三方API，高可移植性</h2><pre><code>    //Driver driver = new com.mysql.jdbc.Driver();    //创建Driver实例,用如下反射方法创建更有普适性    Class clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);    Driver driver = (Driver)clazz.newInstance();    String url = &quot;jdbc:mysql://localhost:3306/yeb&quot;;//数据库的url    //jdbc:mysql://localhost:3306/是固定前缀//Properties：用户名和密码    Properties info= new Properties();    info.setProperty(&quot;user&quot;,&quot;root&quot; );    info.setProperty(&quot;password&quot;, &quot;zjh521418&quot;);//获取连接    Connection connect = driver.connect(url, info);//返回一个Connection    System.out.println(connect);</code></pre><h2 id="2，DriverManager替换Driver"><a href="#2，DriverManager替换Driver" class="headerlink" title="2，DriverManager替换Driver"></a>2，DriverManager替换Driver</h2><pre><code>//反射获取Driver对象     Class clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        Driver driver = (Driver) clazz.newInstance();//提供三个基本信息        String url = &quot;jdbc:mysql://localhost:3306/yeb&quot;;        String user = &quot;root&quot;;        String password = &quot;zjh521418&quot;;//注册驱动,DriverManager替换Driver        DriverManager.registerDriver(driver);//获取链接        Connection connection = DriverManager.getConnection(url,user,password);        System.out.println(connection);</code></pre><h2 id="3，mysql的自动注册驱动"><a href="#3，mysql的自动注册驱动" class="headerlink" title="3，mysql的自动注册驱动"></a>3，mysql的自动注册驱动</h2><p>中间的注册步骤全部可以省（仅对mysql可以）</p><pre><code>//提供三个基本信息        String url = &quot;jdbc:mysql://localhost:3306/yeb&quot;;        String user = &quot;root&quot;;        String password = &quot;zjh521418&quot;;//反射，静态加载Driver对象//     Class clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//        Driver driver = (Driver) clazz.newInstance();//注册驱动,DriverManager替换Driver::::::mysql会自动注册驱动//        DriverManager.registerDriver(driver);        //获取链接        Connection connection = DriverManager.getConnection(url,user,password);        System.out.println(connection);</code></pre><h2 id="4，配置文件加载：松耦合"><a href="#4，配置文件加载：松耦合" class="headerlink" title="4，配置文件加载：松耦合"></a>4，配置文件加载：松耦合</h2><p>读配置文件——流——存Properties——get</p><pre><code>    //读取配置信息:properties——&gt;流    InputStream is = ConnectionTest1.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);//还可以写成InputStream is =ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;配置文件名&quot;);    Properties pros = new Properties();    pros.load(is);//配置信息存储到Propertires中    String user = pros.getProperty(&quot;user&quot;);    String password = pros.getProperty(&quot;password&quot;);    String url = pros.getProperty(&quot;url&quot;);    String driverClass = pros.getProperty(&quot;driverClass&quot;);    //加载驱动    Class.forName(driverClass);    //获取连接    Connection conn = DriverManager.getConnection(url, user, password);        System.out.println(conn);</code></pre><p><img src="https://img-blog.csdnimg.cn/0c43761779654ccfbd7c3d3707883653.png" alt="用properties配置"><img src="https://img-blog.csdnimg.cn/974e80bb735e4a79882d6514b608840c.png" alt="配置信息"></p><h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><h2 id="PreparedStatement实现"><a href="#PreparedStatement实现" class="headerlink" title="PreparedStatement实现"></a>PreparedStatement实现</h2><p>PreparedStatement是Statement的子对象，也是最常用的；原始的Statement无法解决SQL注入问题，所以弃用了。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>SQL语句被<strong>预编译</strong>并存储再PreparedStatement对象中，方便使用此对象多次执行<br><img src="https://img-blog.csdnimg.cn/619c79af7ac1469fb23c4874e64967f0.png"></p><h3 id="使用：增"><a href="#使用：增" class="headerlink" title="使用：增"></a>使用：增</h3><p>以增为例：向yeb数据库文件中的t_role表添加一组数据<br><img src="https://img-blog.csdnimg.cn/e1add7bb73354d6baa1b3dba7bf73320.png" alt="t_role表"></p><ul><li>固定连接操作+PreparedStatement三步操作</li><li>开发中一定像IO处理异常一样try-catch而不是简单的throws</li><li>开发中可以把固定操作封装成一个util工具</li></ul><pre><code>    /**********固定操作******************/        //读取配置信息:properties——&gt;流        InputStream is = ConnectionTest1.class.getClassLoader().getResourceAsStream(&quot;t_role.properties&quot;);        //还可以写成InputStream is =ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;配置文件名&quot;);        Properties pros = new Properties();        pros.load(is);//配置信息存储到Propertires中        String user = pros.getProperty(&quot;user&quot;);        String password = pros.getProperty(&quot;password&quot;);        String url = pros.getProperty(&quot;url&quot;);        String driverClass = pros.getProperty(&quot;driverClass&quot;);        //加载驱动        Class.forName(driverClass);        //获取连接        Connection conn = DriverManager.getConnection(url, user, password);    /***************使用PreparedStatement增删改查**************/        String sql = &quot;insert into t_role(name,nameZh)values(?,?)&quot;;//sql操作        PreparedStatement ps = conn.prepareStatement(sql);//预编译sql语句，返回PreparedStatement实例        //填充占位符？  索引从1开始        ps.setString(1, &quot;张家豪&quot;);//第一个属性值        ps.setString(2,&quot;大数据开发&quot; );//第二个属性值            /*******执行操作**********/        ps.execute();    /*************关闭流**************/        ps.close();        conn.close();</code></pre><h3 id="规范完整代码"><a href="#规范完整代码" class="headerlink" title="规范完整代码"></a>规范完整代码</h3><pre><code>        Connection conn = null;        PreparedStatement ps = null;//预编译sql语句，返回PreparedStatement实例        try &#123;/**********固定操作******************/            //读取配置信息:properties——&gt;流            InputStream is = ConnectionTest1.class.getClassLoader().getResourceAsStream(&quot;t_role.properties&quot;);            //还可以写成InputStream is =ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;配置文件名&quot;);            Properties pros = new Properties();            pros.load(is);//配置信息存储到Propertires中            String user = pros.getProperty(&quot;user&quot;);            String password = pros.getProperty(&quot;password&quot;);            String url = pros.getProperty(&quot;url&quot;);            String driverClass = pros.getProperty(&quot;driverClass&quot;);            //加载驱动            Class.forName(driverClass);            //获取连接            conn = DriverManager.getConnection(url, user, password);/***************使用PreparedStatement增删改查**************/            String sql = &quot;insert into t_role(name,nameZh)values(?,?)&quot;;//sql操作            ps = conn.prepareStatement(sql);            //填充占位符？  索引从1开始            ps.setString(1, &quot;张家豪&quot;);//第一个属性值            ps.setString(2,&quot;大数据开发&quot; );//第二个属性值/*******执行操作**********/            ps.execute();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (SQLException e) &#123;            e.printStackTrace();        &#125; finally &#123;/*************关闭流**************/            try &#123;                if(ps != null)&#123;                ps.close();                &#125;            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if(ps != null)&#123;                conn.close();                &#125;            &#125; catch (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;</code></pre><h3 id="使用：改"><a href="#使用：改" class="headerlink" title="使用：改"></a>使用：改</h3><pre><code>/************改**********/String sql = &quot;updatE t_role set nameZh = ? where name = ? &quot;;//sql语句对语法的大小写不敏感，即便是uPdAtE也能识别为update        PreparedStatement ps = conn.prepareStatement(sql);        ps.setObject(1, &quot;大数据开发工程师&quot;);        ps.setObject(2,&quot;张家豪&quot; );        ps.execute();        ps.close();        conn.close();</code></pre><h3 id="使用：删"><a href="#使用：删" class="headerlink" title="使用：删"></a>使用：删</h3><pre><code>    PreparedStatement ps = conn.prepareStatement(sql);    ps.setObject(1,&quot;张家豪&quot;);    ps.execute();    System.out.println(conn.getAutoCommit());    //返回true则提交成功    //但提交成功≠操作成功，操作成功需要保证业务正确    ps.close();    conn.close();</code></pre><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>execute——&gt;</p><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><ul><li>封装的JDBC，最简单的持久化框架</li><li>灵活，sql语句写在xml里，降低耦合度</li><li>提供xml标签，支持编写动态sql语句</li><li>提供映射标签，映射对象和数据库的字段(ORM)</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>对SQL语法要求高，编写工作量大</li><li>SQL语法依赖于数据库，移植性差</li></ul><p>springboot对mybatis进行封装，解决了跨平台问题</p><h1 id="Springboot整合JDBC"><a href="#Springboot整合JDBC" class="headerlink" title="Springboot整合JDBC"></a>Springboot整合JDBC</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h3 id="pom-yaml"><a href="#pom-yaml" class="headerlink" title="pom.yaml"></a>pom.yaml</h3><pre><code>spring:  datasource:    username: root    password: 123456    #?serverTimezone=UTC解决时区的报错    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8    driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><h2 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a>获取连接</h2><pre><code>@SpringBootTestclass Boot05ApplicationTests &#123;    @Qualifier(&quot;dataSource&quot; )    @Autowired    DataSource dataSource;    //注入数据源，以便下面获得数据库连接    @Test    void contextLoads() throws SQLException &#123;        //当且仅当@AutoWired注入了DataSource，这里才能运行        System.out.println(dataSource.getClass());//class com.zaxxer.hikari.HikariDataSource        Connection conn = dataSource.getConnection();//获取数据库连接        System.out.println(conn);    conn.close();&#125;&#125;</code></pre><p><strong>数据源DataSource有什么作用:</strong></p><ol><li>通过DataSource可以获取数据库连接Connection</li><li>通过DataSource创建JdbcTemplate操作数据库</li></ol><h2 id="JdbcTemplate-封装JDBC-CRUD"><a href="#JdbcTemplate-封装JDBC-CRUD" class="headerlink" title="JdbcTemplate:封装JDBC CRUD"></a>JdbcTemplate:封装JDBC CRUD</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>Spring Boot 默认提供了数据源，默认提供了org.springframework.jdbc.core.JdbcTemplate</li><li>JdbcTemplate 中会自己注入数据源，用于简化 JDBC操作</li><li>不用再自己来关闭数据库连接</li></ol><p><strong>JdbcTemplate主要提供以下几类方法：</strong></p><ul><li><p>   <strong>execute方法</strong>：可以用于执行任何SQL语句，一般用于执行DDL语句；</p></li><li><p>   <strong>update方法及batchUpdate方法</strong>：update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</p></li><li><p>   <strong>query方法及queryForXXX方法</strong>：用于执行查询相关语句；</p></li><li><p>  <strong>call方法</strong>：用于执行存储过程、函数相关语句。</p></li></ul><h3 id="controller类JDBCTemplate"><a href="#controller类JDBCTemplate" class="headerlink" title="controller类JDBCTemplate"></a>controller类JDBCTemplate</h3><pre><code>@RestControllerpublic class JDBCTemplate &#123;   @Autowired    JdbcTemplate jdbcTemplate;         /******下面写requestmapping****/      &#125;</code></pre><h3 id="增-update-GetMapping-“-add-……"><a href="#增-update-GetMapping-“-add-……" class="headerlink" title="增:update   +  @GetMapping(“/add/{……"></a>增:update   +  @GetMapping(“/add/{……</h3><p>前端处理注册数据，返回一个url，如：</p><pre><code>localhost:8080/add/&#123;张家豪&#125;/&#123;123456&#125;/&#123;13288888888&#125;/&#123;222222222@qq.com&#125;</code></pre><p>然后GetMapping处理这条url附带的信息</p><pre><code>//增    @GetMapping(&quot;/add/&#123;username&#125;/&#123;password&#125;/&#123;phonenum&#125;/&#123;email&#125;&quot;)//格式标准public String addUser(@PathVariable(&quot;username&quot;) String name,                      @PathVariable(&quot;password&quot;) String pass,                      @PathVariable(&quot;phonenum&quot;) String phone,                      @PathVariable(&quot;email&quot;) String e)&#123;    //占位符sql语句    String sql = &quot;insert into userinfo(username,password,phonenum,email) &quot;            + &quot;values(name,pass,phone,e)&quot;;    //执行sql    jdbcTemplate.update(sql);    //返回值    return &quot;添加成功&quot;;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSMp整合案例</title>
      <link href="/zjh/2022/01/25/SSMp%E6%95%B4%E5%90%88%E6%A1%88%E4%BE%8B/"/>
      <url>/zjh/2022/01/25/SSMp%E6%95%B4%E5%90%88%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="制作流程"><a href="#制作流程" class="headerlink" title="制作流程"></a>制作流程</h1><h2 id="导入依赖后Maven刷新"><a href="#导入依赖后Maven刷新" class="headerlink" title="导入依赖后Maven刷新"></a>导入依赖后Maven刷新</h2><pre><code>druid-spring-boot-starter//版本号spring-webmvclombok//简化pojo开发spring-boot-starter-jdbcspring-boot-starter-webmybatis-plus-boot-starter//版本号mysql-connector-javaspring-boot-starter-test</code></pre><h2 id="实体类pojo：对应数据表单"><a href="#实体类pojo：对应数据表单" class="headerlink" title="实体类pojo：对应数据表单"></a>实体类pojo：对应数据表单</h2><ul><li><strong>实体类名=表名</strong></li><li><strong>属性=列名</strong></li><li><strong>驼峰命名问题可以选择关闭or打开</strong></li></ul><pre><code>    mybatis-plus:      configuration:    # 是否开启自动驼峰命名规则（camel case）映射，    #    即从经典数据库列名 A_COLUMN（下划线命名）     #    到经典 Java 属性名 aColumn（驼峰命名） 的类似映射            map-underscore-to-camel-case: false    </code></pre><p>在domain包下</p><pre><code>//@AllArgsConstructor//@NoArgsConstructor//因为实际使用中都是用get set方法，所以不需要上面的构造器注释  @Datapublic class t_user &#123;    private Integer id;    private String name;    private String phone;&#125;</code></pre><h2 id="数据层开发：MybatisPlus-Druid"><a href="#数据层开发：MybatisPlus-Druid" class="headerlink" title="数据层开发：MybatisPlus+Druid"></a>数据层开发：MybatisPlus+Druid</h2><h3 id="yml配置信息"><a href="#yml配置信息" class="headerlink" title="yml配置信息"></a>yml配置信息</h3><pre><code>server:  port: 80    spring:  datasource:    druid:      username: root      password: zjh521418      url: JDBC://localhost:3306/yeb      driver-class-name: com.mysql.cj.jdbc.Driver                              #mybatis-plus:#  global-config: #   db-config: #     table-prefix: t_##      表名前缀，例如t_jobLevel前缀就是这个          </code></pre><h1 id="数据层开发Dao"><a href="#数据层开发Dao" class="headerlink" title="数据层开发Dao"></a>数据层开发Dao</h1><h2 id="数据层接口Dao：整合MP"><a href="#数据层接口Dao：整合MP" class="headerlink" title="数据层接口Dao：整合MP"></a>数据层接口Dao：整合MP</h2><ul><li>接口是interface不是class！！！！</li><li>接口可以extends接口~</li><li>这个Dao接口要继承BaseMapper接口</li><li>使用之前要@Autowried注入Dao</li></ul><p><img src="https://img-blog.csdnimg.cn/d6d3653e3b46445bad8b6b829e494cc3.png" alt="t_user表"></p><pre><code>@Mapperpublic interface UserDao extends BaseMapper&lt;t_user&gt;&#123;&#125;@Datapublic class t_user &#123;    private Integer id;    private String name;    private String phone;&#125;@AutowiredUserDao userDao;</code></pre><h3 id="MP：CRUD"><a href="#MP：CRUD" class="headerlink" title="MP：CRUD"></a>MP：CRUD</h3><p><img src="https://img-blog.csdnimg.cn/d37a7852260242a39583cb59efa18078.png" alt="增删改查都有"></p><pre><code>@Testpublic void testUserAdd()&#123;    t_user tu = new t_user();    tu.setId(2);    tu.setName(&quot;sada&quot;);    tu.setPhone(&quot;5654653215&quot;);    userDao.insert(tu);    &#125;</code></pre><h4 id="BUG记录"><a href="#BUG记录" class="headerlink" title="BUG记录"></a>BUG记录</h4><ul><li>java.lang.IllegalStateException: Failed to load ApplicationContext<br>Caused by: java.lang.NoSuchFieldError: APPLICATION_NDJSON<br>要保证命名规则相同 以及 属性类型对应    </li></ul><h2 id="Mybatis-Plus的配置"><a href="#Mybatis-Plus的配置" class="headerlink" title="Mybatis-Plus的配置"></a>Mybatis-Plus的配置</h2><p><img src="https://img-blog.csdnimg.cn/77cfc73228ec444bb5c294920d1295af.png" alt="可配置项超多"></p><h3 id="开启日志：log下"><a href="#开启日志：log下" class="headerlink" title="开启日志：log下"></a>开启日志：log下</h3><p>log即日志</p><p><strong>测试的时候可以开，但上线运行千万不要开，服务器会裂开</strong><br><img src="https://img-blog.csdnimg.cn/c658e8b2b1064433b30ea7b2d8bc783b.png"></p><h4 id="StdOutImpl：控制台输出"><a href="#StdOutImpl：控制台输出" class="headerlink" title="StdOutImpl：控制台输出"></a>StdOutImpl：控制台输出</h4><p><img src="https://img-blog.csdnimg.cn/9e34ed24b8274ee6ac6aea6e254f6bf8.png" alt="sql语句是如何创建的">包括了创建sql+预编译+参数等信息<br>有了这个配置就不需要sout了</p><h2 id="分页查询：拦截器-MP"><a href="#分页查询：拦截器-MP" class="headerlink" title="分页查询：拦截器+MP"></a>分页查询：拦截器+MP</h2><h3 id="创建MPconfig配置类：拦截器，固定操作"><a href="#创建MPconfig配置类：拦截器，固定操作" class="headerlink" title="创建MPconfig配置类：拦截器，固定操作"></a>创建MPconfig配置类：拦截器，固定操作</h3><pre><code>//Mybatis-plus配置类，需要在此添加拦截器才能正常实现分页查询@Configurationpublic class MPconfig &#123;@Beanpublic MybatisPlusInterceptor mpi()&#123;    //1，定义拦截器    MybatisPlusInterceptor mpi = new MybatisPlusInterceptor();    //2，添加具体的拦截器__PaginationInnerInterceptor分页查询拦截器    mpi.addInnerInterceptor(new PaginationInnerInterceptor());    //3，返回拦截器    return mpi;    &#125;    &#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/61b93045c1c346658829dfe78e08d9e5.png" alt="拦截器"></p><h3 id="数据层：分页查询"><a href="#数据层：分页查询" class="headerlink" title="数据层：分页查询"></a>数据层：分页查询</h3><pre><code>    @Testpublic void testUserPage()&#123;        /*********分页查询*********/        IPage iPage = new Page(2,3);        //按顺序，每页size=3条数据，分页；选择第current=2页    userDao.selectPage(iPage, null);//第二个参数是queryWrapper条件    //这个方法还会返回这个iPage对象本身                System.out.println(&quot;*******iPage对象的6个属性值*******&quot;);        System.out.println(iPage.getCurrent());//2        System.out.println(iPage.getRecords());//[]        System.out.println(iPage.getSize());//3        System.out.println(iPage.getTotal());//0        System.out.println(iPage.getPages());//0    &#125;</code></pre><p>在yaml中配置了log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</p><p>如下的运行结果<img src="https://img-blog.csdnimg.cn/9910670d03eb43c9a0c7cb914f006132.png"></p><h2 id="条件查询：queryWrapper"><a href="#条件查询：queryWrapper" class="headerlink" title="条件查询：queryWrapper"></a>条件查询：queryWrapper</h2><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><pre><code>    @Testpublic void testUserQuery()&#123;//基础的条件查询        QueryWrapper&lt;t_user&gt; qw = new QueryWrapper&lt;&gt;();//查询包实例化,绑定查询的表单        qw.like(&quot;name&quot;, &quot;张三&quot;);        qw.like(&quot;id&quot;, 1);//多条like就是“且”        //查询id=1 name=张三 的数据        userDao.selectList(qw);//返回一个list        &#125;</code></pre><h3 id="lambda表达式安全绑定"><a href="#lambda表达式安全绑定" class="headerlink" title="lambda表达式安全绑定"></a>lambda表达式安全绑定</h3><pre><code>    @Testpublic void testUserLambdaQuery()&#123;//加入lambda表达式防止写错字符        LambdaQueryWrapper&lt;t_user&gt; lqw = new LambdaQueryWrapper&lt;&gt;();//查询包实例化        lqw.like(t_user::getName, &quot;aaaa&quot;);        //t_user是个pojo类        userDao.selectList(lqw);    &#125;</code></pre><h3 id="lambda-if"><a href="#lambda-if" class="headerlink" title="lambda + if"></a>lambda + if</h3><pre><code>    @Testpublic void testUserLambdaIf()&#123;//lambda + if + 条件        String namefrom = &quot;bbb&quot;;//前端传来的数据可能为null值    LambdaQueryWrapper&lt;t_user&gt; lqw = new LambdaQueryWrapper&lt;&gt;();    lqw.like(namefrom!=null , t_user::getName , namefrom);    //参数解析：        //条件1：如果前端传入的namefrom值不为空，数据才查询        //条件2：安全获取t_user的pojo类的name属性名        //条件3: 传入namefrom属性的值        userDao.selectList(lqw);    &#125;</code></pre><h3 id="like条件查询的其他用法"><a href="#like条件查询的其他用法" class="headerlink" title="like条件查询的其他用法"></a>like条件查询的其他用法</h3><p><img src="https://img-blog.csdnimg.cn/9ecae93d1e2e41d2b8dd515f77fbbb83.png" alt="like方法源码"></p><h1 id="业务层开发Service"><a href="#业务层开发Service" class="headerlink" title="业务层开发Service"></a>业务层开发Service</h1><p>相比数据层（关心如何跟数据库交互），业务层更关心<strong>业务名称</strong>，不要混用，例如：同样的登录操作，</p><ul><li>在数据层的接口：selectByUserNameAndPassword( 形参 )</li><li>在业务层的接口：login( 形参 )</li></ul><p>业务层也可以在调用数据层方法的同时，添加自己的逻辑<br><img src="https://img-blog.csdnimg.cn/5ddd2ffe71b34dbb80f5c5485e365f5f.png" alt="文件结构"></p><h2 id="Service接口和实现类"><a href="#Service接口和实现类" class="headerlink" title="Service接口和实现类"></a>Service接口和实现类</h2><ul><li>实现类中注入Dao，那么使用时注入Service就可以通过Service使用Dao了</li><li>增删改的返回值用Boolean，查询才返回一个实体类</li></ul><pre><code>    public interface UserService &#123;//是接口    Boolean save(t_user u);//    Boolean update(t_user u);//    Boolean deleteById(Integer id);//    t_user getById(Integer id);//    List&lt;t_user&gt; getAll();    &#125;    /*******实现类**********/    @Service//注入业务层的bean    public class UserServiceImpl implements UserService&#123;//Impl就是implement    @Autowired    private UserDao userDao;    //嵌套调用，因为使用中，需要注入Service    //在Service中嵌套注入Dao    //即可在业务层操作数据    @Override    public Boolean save(t_user u) &#123;//业务层的save对应数据层的insert        return userDao.insert(u) &gt; 0;        //MybatisPlus定义的CRUD方法返回值是“修改了多少个数据”        //因此判断 &gt; 0 即可    &#125;    @Override    public Boolean update(t_user u) &#123;        return userDao.update(u,null )&gt;0;        //在业务层中调用数据层的方法    &#125;    @Override    public Boolean deleteById(Integer id) &#123;        return userDao.deleteById(id)&gt;0;    &#125;    @Override    public t_user getById(Integer id) &#123;        return userDao.selectById(id);    &#125;    @Override    public List&lt;t_user&gt; getAll() &#123;        return userDao.selectList(null);    &#125;    &#125;</code></pre><h2 id="Service测试"><a href="#Service测试" class="headerlink" title="Service测试"></a>Service测试</h2><pre><code>@SpringBootTestpublic class TUserServiceTestCase &#123;@Autowiredprivate UserService userService;//注入业务层对象@Testpublic void testGetById()&#123;    System.out.println(userService.getById(1));    //业务层看不了日志，所以需要打印    //如果查询结果有多个，则会报错&#125;&#125;</code></pre><h3 id="Service层的分页查询"><a href="#Service层的分页查询" class="headerlink" title="Service层的分页查询"></a>Service层的分页查询</h3><ul><li><p>在Service接口中定义抽象方法 IPage<t_user> getPage(int currentPage,int pageSize);</p></li><li><p>在Service实现类中重写抽象方法</p><pre><code>  @Override  public IPage&lt;t_user&gt; getPage(int currentPage, int pageSize) &#123;  IPage&lt;t_user&gt; iPage = new Page&lt;&gt;(currentPage,pageSize);//定义如何分页  return userDao.selectPage(iPage,null);//返回值本身就是ipage    &#125;</code></pre></li></ul><ul><li><p>业务层进行查询没有log，需要sout输出</p><pre><code>  @Test  public void testSelectByPage()&#123;      System.out.println(userService.getPage(2, 2));      //返回一个ipage对象，但toString在@Service下已重载，可以正常输出  &#125;</code></pre></li></ul><ul><li><strong>仍然需要保证注解的嵌套注入</strong></li></ul><ul><li>下面证明BaseMapper接口下“分页查询selectPage”返回值就是形参ipage</li></ul><pre><code>    IPage&lt;t_user&gt; iPage = new Page&lt;&gt;(currentPage,pageSize);//定义如何分页    IPage&lt;t_user&gt; iPage1 = userDao.selectPage(iPage, null);//返回值本身就是ipage   System.out.println(iPage==iPage1);//true</code></pre><h2 id="MP业务层快速开发"><a href="#MP业务层快速开发" class="headerlink" title="MP业务层快速开发"></a>MP业务层快速开发</h2><p>MP不光简化了数据层的操作（在Dao上@Mapper，并extends BaseMapper&lt;&gt;，就能直接调用CRUD）<br>MP还简化了业务层的开发~（IService&lt;&gt;接口）</p><h3 id="MP业务层接口"><a href="#MP业务层接口" class="headerlink" title="MP业务层接口"></a>MP业务层接口</h3><p><img src="https://img-blog.csdnimg.cn/4ac6dfe87a5045c0bf06659f40a66619.png" alt="位置"></p><pre><code>@Servicepublic interface IMPUserService extends IService&lt;t_user&gt; &#123;//继承IService    //idea下Ctrl+O查看IService提供的方法    //还可以自己再根据业务添加方法    //I开头表示接口，MP代表mybatis plus整合业务层快速开发 //这里面可以写抽象方法，自定义业务层的方法&#125;</code></pre><h3 id="MP业务层实现类"><a href="#MP业务层实现类" class="headerlink" title="MP业务层实现类"></a>MP业务层实现类</h3><p><img src="https://img-blog.csdnimg.cn/a18756a3a14b41babbf7d0534e4d24ec.png" alt="位置"></p><pre><code>package com.bootadmin1.bootajaxtest.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.bootadmin1.bootajaxtest.service.IMPUserService;import com.bootadmin1.bootajaxtest.dao.UserDao;import com.bootadmin1.bootajaxtest.domain.t_user;//导入了4个必要的包，4个类都被MP托管了import org.springframework.stereotype.Service;/** * @author zjh * @create 2022-01-25 18:49 *///@Service之后可以被Spring托管，才能注入后使用@Servicepublic class MPUserServiceImpl extends ServiceImpl&lt;UserDao,t_user&gt; implements IMPUserService &#123;    //继承ServiceImpl可以免去写很多个IMPUserService的重载方法    //泛型指定Dao和实体类    //同时实现“实现了IService接口”的接口IMPUserService    //现在就可以不用手动重写那么多的方法了，Ctrl+O可以看能用的方法&#125;</code></pre><p>需要添加自定义方法的话，跟不用Mybatisplus托管操作是一样的</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code>@Autowiredprivate IMPUserService impUserService;//注入MP快速搭建的业务层接口@Service//查get@Testpublic void testGetById()&#123;    t_user byId = impUserService.getById(1);//这个方法是MP提供的    //只要实现了IService接口就能使用这些个方法    System.out.println(byId);&#125;</code></pre><h3 id="调用分析"><a href="#调用分析" class="headerlink" title="调用分析"></a>调用分析</h3><ul><li><p>public interface IMPUserService <strong>extends IService&lt;实体类&gt;</strong></p></li><li><p>@Service<br>public class MPUserServiceImpl <strong>extends ServiceImpl&lt;Dao,实体类&gt; implements IMPUserService</strong></p></li><li><p>@Test @Autowired 注入父类子类都OK，多态性的体现</p><pre><code>  @Autowired  private IMPUserService impUserService;  //private 其子类MPUserServiceImpl也可以 impUserService;</code></pre></li></ul><h1 id="表现层开发Controller"><a href="#表现层开发Controller" class="headerlink" title="表现层开发Controller"></a>表现层开发Controller</h1><p><img src="https://img-blog.csdnimg.cn/a5146e26282f4f918610d65b4cabc036.png" alt="位置"></p><pre><code>package com.bootadmin1.bootajaxtest.controller;import com.bootadmin1.bootajaxtest.domain.t_user;import com.bootadmin1.bootajaxtest.service.IMPUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * @author zjh * @create 2022-01-25 19:45 */@RestController@RequestMapping(&quot;/users&quot;)//users是有说法的，复数嘛public class UserController &#123;    @Autowired    private IMPUserService impUserService;    //同样因为多态性，这里也可以注入其子类    @GetMapping    public List&lt;t_user&gt; getAll()&#123;        return impUserService.list();    &#125;    //增：Post提交，save：mp的保存方法    @PostMapping    public boolean save(@RequestBody  t_user u)&#123;//        @ResponseBody请求体参数，异步提交json数据        return impUserService.save(u);    &#125;    //改：Put提交，update：mp的修改方法    @PutMapping    public boolean updata(@RequestBody t_user u)&#123;        return impUserService.updateById(u);    &#125;    //http://localhost：8080/users/id    @DeleteMapping(&quot;&#123;id&#125;&quot;)    public boolean delete(@PathVariable Integer id)&#123;        //@PathVariable表示从url路径获取的变量        return impUserService.removeById(id);    &#125;    @GetMapping(&quot;&#123;id&#125;&quot;)    public t_user getByid(@PathVariable Integer id)&#123;        return impUserService.getById(id);    &#125;&#125;</code></pre><h2 id="postman测试"><a href="#postman测试" class="headerlink" title="postman测试"></a>postman测试</h2><h3 id="查所有"><a href="#查所有" class="headerlink" title="查所有"></a>查所有</h3><p><img src="https://img-blog.csdnimg.cn/db9c7f7b1b804bb4a94090d2875f0183.png" alt="GET请求"></p><h3 id="ID查"><a href="#ID查" class="headerlink" title="ID查"></a>ID查</h3><p><img src="https://img-blog.csdnimg.cn/555e6d3e32804c588b5f9e3ce91df865.png"></p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul><li>换Post提交</li><li>Body下选raw，换位JSON，写JSON字符串<br><img src="https://img-blog.csdnimg.cn/62cebe7bed9b4217bb94bbdd5f2571bc.png" alt="这里故意超出数据库限制，提交失败"><br>然后把数据设置合理<br><img src="https://img-blog.csdnimg.cn/9829e5ac57a7405bbf966209a12441c0.png" alt="提交成功"><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3></li></ul><p><img src="https://img-blog.csdnimg.cn/f6bca076957c46af8ad338f217280407.png" alt="通过id修改成功"></p><h3 id="分页查询-自定义"><a href="#分页查询-自定义" class="headerlink" title="分页查询:自定义"></a>分页查询:自定义</h3><p><img src="https://img-blog.csdnimg.cn/10da1f38f8754c5ba043ba76d3ee01f5.png" alt="第二页，每页显示3条"></p><h4 id="业务层接口定义抽象方法"><a href="#业务层接口定义抽象方法" class="headerlink" title="业务层接口定义抽象方法"></a>业务层接口定义抽象方法</h4><pre><code>public interface IMPUserService extends IService&lt;t_user&gt; &#123;//继承IService    //idea下Ctrl+O查看IService提供的方法    //还可以自己再根据业务添加方法    //I开头表示接口，MP代表mybatis plus整合业务层快速开发    IPage&lt;t_user&gt; getPage(int current,int size);&#125;</code></pre><h4 id="业务层实现类实现抽象方法：需要注入Dao"><a href="#业务层实现类实现抽象方法：需要注入Dao" class="headerlink" title="业务层实现类实现抽象方法：需要注入Dao"></a>业务层实现类实现抽象方法：需要注入Dao</h4><pre><code>//@Service之后可以被Spring托管，才能注入后使用@Servicepublic class MPUserServiceImpl extends ServiceImpl&lt;UserDao,t_user&gt; implements IMPUserService &#123;    //继承ServiceImpl可以免去写很多个IMPUserService的重载方法    //泛型指定Dao和实体类    //同时实现“实现了IService接口”的接口IMPUserService    //现在就可以不用手动重写那么多的方法了，Ctrl+O可以看能用的方法    @Autowired    private UserDao userDao;    //自定义方法肯定需要注入Dao来操作数据库了    @Override    public IPage&lt;t_user&gt; getPage(int current, int size) &#123;        Page&lt;t_user&gt; ipage = new Page&lt;&gt;(current, size);        return userDao.selectPage(ipage,null );    &#125;&#125;</code></pre><h4 id="表现层控制请求"><a href="#表现层控制请求" class="headerlink" title="表现层控制请求"></a>表现层控制请求</h4><pre><code>//分页查询@GetMapping(&quot;&#123;current&#125;/&#123;size&#125;&quot;)public IPage&lt;t_user&gt; getPages(@PathVariable Integer current, @PathVariable Integer size)&#123;   return impUserService.getPage(current,size );//调用自定义的方法&#125;</code></pre><h2 id="Restful风格总结"><a href="#Restful风格总结" class="headerlink" title="Restful风格总结"></a>Restful风格总结</h2><p>基于Restful风格制作的表现层接口</p><ul><li>增：POST</li><li>删：DELETE</li><li>改：PUT</li><li>查：GET</li></ul><p>对于增，改操作，会从客户端读取数据参数</p><ul><li>实体数据：@RequestBody</li><li>路径变量：@PathVariable</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Springboot基本结构</title>
      <link href="/zjh/2022/01/20/Springboot%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
      <url>/zjh/2022/01/20/Springboot%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="基本运行功能"><a href="#基本运行功能" class="headerlink" title="基本运行功能"></a>基本运行功能</h1><p><img src="https://img-blog.csdnimg.cn/ef2744d2043545cb80069240f28c9c6d.png" alt="基本项目结构"></p><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><a href="https://blog.csdn.net/qq_33363618/article/details/79438044">pom.xml配置详解</a><br>注意结构，如：dependencies中包括了多个dependency</p><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li><p>@<strong>Data</strong>：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法</p></li><li><p><em>有了@Data提供的get set方法才能顺利的从配置文件中读取信息</em>*</p></li><li><p>@<strong>ConfigurationProperties(prefix = “zjh”)</strong>//配置zjh属性，这个注解要结合config中的<strong>EnableConfigurationProperties({Person.class,Pet.class})<strong>允许配置，还要结合controller中的    <br></strong>@Autowired<br>Person zjh;</strong>//注入到IOC容器才能反应</p></li></ul><p>（@Component以被@EnableConfigurationProperties替代）</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>@ConfigurationProperties(prefix = &quot;zjh&quot;)//配置zjh属性@Data@ToStringpublic class Person &#123;    private String userName;    private Boolean boss;    private Date birth;    private Integer age;    private Pet pet;    private String[] interests;    private List&lt;String&gt; animal;    private Map&lt;String, Object&gt; score;    private Set&lt;Double&gt; salarys;    private Map&lt;String, List&lt;Pet&gt;&gt; allPets;&#125;</code></pre><h2 id="config配置类"><a href="#config配置类" class="headerlink" title="config配置类"></a>config配置类</h2><p><img src="https://img-blog.csdnimg.cn/045ca7ac7b5f487d895018f21fa7cd8b.png"></p><h3 id="常用注解-1"><a href="#常用注解-1" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li><p><strong>@Configuration(proxyBeanMethods = false或true)</strong><br>Full(proxyBeanMethods = <strong>true</strong>)【保证每个@Bean方法被调用多少次返回的组件都是<strong>单实例</strong>的】<br>Lite(proxyBeanMethods = <strong>false</strong>)【每个@Bean方法被调用多少次返回的组件都是<strong>新创建</strong>的】</p></li><li><p><em>组件依赖必须使用Full模式默认。其他默认是否Lite模式</em>*</p></li><li><p><strong>@EnableConfigurationProperties({Person.class,Pet.class})</strong>{}中的类可以由配置文件配置</p></li><li><p>@Bean 给IOC容器添加组件，@Bean和@Import、@ConfigurationProperties 有冲突，<strong>并且@Bean也需要在controller下@Autowired注入</strong></p></li><li><p>@Import 导入某个类，创建默认组件，组件名默认为全类名，和@Bean冲突</p></li><li><p>@ImportResource 解析xml配置</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>  @ImportResource(“classpath:beans.xml”)<br>  @Import({ImportTest1.class})<br>  //下面两个才是基本运行所必要的注解<br>  @EnableConfigurationProperties({Person.class,Pet.class})<br>  @Configuration(proxyBeanMethods = false)<br>  public class MyConfig {</p><pre><code>  @Bean  public ImportTest1 importTest1()&#123;      ImportTest1 it1 = new ImportTest1(&quot;test&quot;);      return it1;  &#125;//这个Bean组件就唯一添加到了IOC容器中，并且可以被Cotroller或main获取  &#125;</code></pre></li></ul><h2 id="controller控制类"><a href="#controller控制类" class="headerlink" title="controller控制类"></a>controller控制类</h2><p><img src="https://img-blog.csdnimg.cn/4ffa26c0bc7e4596bc8ff02e84a2ba12.png"></p><h3 id="常用注解-2"><a href="#常用注解-2" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li>@RestController声明，== @ResponseBody+@Controller</li><li>@RequestMapping(“/hello”),RUL后缀映射访问请求</li><li>@Autowired，每个要使用的Bean都需要@Autowired注入容器</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><pre><code>    @RestControllerpublic class hello &#123;        //映射请求：浏览器访问请求    @RequestMapping(&quot;/hello&quot;)//收到hello请求    public String handle01()&#123;//反应        return &quot;world&quot;;    &#125;//   自动注入，需要Person有空参构造    //或Person类直接实现@Data注解    @Autowired    Person zjh;    @RequestMapping(&quot;/zjh&quot;)//zjh必须先   //用 @ConfigurationProperties(prefix = &quot;zjh&quot;)    //并且在application.yaml中配置    public Person handle02()&#123;        return zjh;    &#125;    @Autowired    Pet nn;    @RequestMapping(&quot;/nn&quot;)    public Pet handle03()&#123;        return nn;    &#125;    &#125;</code></pre><h2 id="运行主类"><a href="#运行主类" class="headerlink" title="运行主类"></a>运行主类</h2><ul><li>@SpringBootApplication声明为主类</li><li>SpringApplication.run(MainApp.class, args)运行且返回IOC容器<ul><li>该单独的类MainAPP.class和以上三个包同目录<img src="https://img-blog.csdnimg.cn/9e3e59181d394103b9ac04a441494b27.png">  <h3 id="单例、组件依赖：proxyBeanMethods"><a href="#单例、组件依赖：proxyBeanMethods" class="headerlink" title="单例、组件依赖：proxyBeanMethods"></a>单例、组件依赖：proxyBeanMethods</h3>因为在config类中也遇到了proxyBeanMethods，主类中也有proxyBeanMethods参数<br>他们分别为：</li></ul></li><li><em>@Configuration(proxyBeanMethods = true)<br>@SpringBootApplication(proxyBeanMethods = true)</em>*</li></ul><p>Full(proxyBeanMethods = <strong>true</strong>)【保证每个@Bean方法被调用多少次返回的组件都是<strong>单实例</strong>的】<br>Lite(proxyBeanMethods = <strong>false</strong>)【每个@Bean方法被调用多少次返回的组件都是<strong>新创建</strong>的】</p><p>组件依赖必须使用默认的Full模式，其他则默认使用Lite模式。</p><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><pre><code>@SpringBootApplicationpublic class MainApp &#123;//这是入口    public static void main(String[] args) &#123;        //不光可以启动，还可以有返回值IOC容器        ConfigurableApplicationContext run = SpringApplication.run(MainApp.class, args);//返回容器run        &#125;        &#125;</code></pre><h4 id="Bean单例的体现"><a href="#Bean单例的体现" class="headerlink" title="Bean单例的体现"></a>Bean单例的体现</h4><pre><code>//单例实例的创建不能用new，而是反射机制//并且在MyConfig中已创建该类的@Bean    //或者    //具体属性值由yaml配置//总之，IOC容器中如下getBean得到的是该类的唯一：单例    Person person1 = run.getBean(Person.class);    Pet pet1 = run.getBean(Pet.class);    System.out.println(pet1);    System.out.println(person1);</code></pre><h4 id="体现2"><a href="#体现2" class="headerlink" title="体现2"></a>体现2</h4><pre><code>    System.out.println(&quot;***************************&quot;);    String[] beanNamesForType = run.getBeanNamesForType(person1.getClass());    //获取所有Person组件的所有名字    for(String str : beanNamesForType)&#123;        System.out.println(str);    &#125;//单例下只有一个zjh-ZJH.inditest.bean.Person</code></pre><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><ul><li><strong>属性设置</strong>：Bean声明@ConfigurationProperties(prefix = “zjh”)——&gt;在application.yaml中配置</li><li><strong>配置组件</strong>：声明@Configuration的类就是配置组件——&gt;<br>@EnableConfigurationProperties({Person.class,Pet.class})<br>使配置好的Bean生效</li><li><strong>控制组件</strong>：声明@RestController的类就是控制组件——&gt;<br>结合@Autowired注入，@RequestMapping(“/hello”)映射请求</li><li><strong>主类运行</strong>：声明@SpringBootApplication的类就是主类，有main方法体——&gt; ConfigurableApplicationContext run = SpringApplication.run(MainApp.class, args);固定用法，运行且返回IOC容器</li></ul><h1 id="基本依赖"><a href="#基本依赖" class="headerlink" title="基本依赖"></a>基本依赖</h1><pre><code>&lt;!--可执行jar包--&gt;    &lt;!--Maven中点clean package--&gt;    &lt;!--cmd上方右键属性关闭快速编辑--&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;!--父项目，依赖管理，控制版本--&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.6.2&lt;/version&gt;    &lt;/parent&gt;&lt;!--Web场景启动器--&gt;    &lt;!--启动器：springboot stater- ：相当于import--&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;    &lt;!--&lt;dependency&gt;--&gt;        &lt;!--&lt;groupId&gt;mysql&lt;/groupId&gt;--&gt;        &lt;!--&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt;        &lt;!--&lt;version&gt;8.0.28&lt;/version&gt;--&gt;    &lt;!--&lt;/dependency&gt;--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;1.16.20&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件:文件加密解密器</title>
      <link href="/zjh/2022/01/16/%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%99%A8/"/>
      <url>/zjh/2022/01/16/%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一个基于对称加密机制的文件加密器"><a href="#一个基于对称加密机制的文件加密器" class="headerlink" title="一个基于对称加密机制的文件加密器"></a>一个基于对称加密机制的文件加密器</h1><ul><li>这是我写的第一个版本，能加密所有文件，但基于对称加密，安全系数不是特别高。<br></li><li>并且由于算法操作了所有字节，在执行效率上有所缺陷，后续有精力了会进行版本迭代<br></li><li>第一个版本不支持自定义输出目录<br></li></ul><p>下个版本将：自定义输出地址，可以文件夹整体加密，非对称加密方式，只操作部分字节</p><p><img src="https://img-blog.csdnimg.cn/b8edf3c2b2e049de9f9aea9c511d3ed1.png"></p><p>链接：<a href="https://pan.baidu.com/s/1eHVwitD0ZfVZLLNXfCL8TA">https://pan.baidu.com/s/1eHVwitD0ZfVZLLNXfCL8TA</a><br>提取码：iai9</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ul><li>输入的路径是文件夹，这个加密器是把<strong>整个文件夹中文件全部加密</strong></li><li>该方法默认了输出路径， 路径会自动生成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/zjh/2022/01/16/IO%E6%B5%81/"/>
      <url>/zjh/2022/01/16/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="IO流特点"><a href="#IO流特点" class="headerlink" title="IO流特点"></a>IO流特点</h1><p>IO流属于物理连接，需要手动显示close()，否则内存泄漏<br>File对象必须是<strong>文件路径</strong>而不能是文件目录，<strong>否则在使用流时会报错java.io.FileNotFoundException: D:\io\io1\io2 (拒绝访问。)</strong></p><h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><ul><li>按操作<strong>数据单位</strong>不同分为：字节流(8 bit)，字符流(16 bit)</li><li>按数据流的<strong>流向</strong>不同分为：输入流，输出流</li><li>按流的<strong>角色</strong>的不同分为：节点流，处理流<h2 id="为什么这样分类？"><a href="#为什么这样分类？" class="headerlink" title="为什么这样分类？"></a>为什么这样分类？</h2><h3 id="1，数据单位"><a href="#1，数据单位" class="headerlink" title="1，数据单位"></a>1，数据单位</h3></li><li>字节流(8bit = 255位)：适合<strong>图像视频等</strong>(.jpg .mp3 .mp4 .avi <strong>.doc</strong> .ppt….)传输，因为电脑像素点的灰度值范围是[0,255]<br></li><li>字符流(16bit = 2字节)：适合传输<strong>文本</strong>(<strong>.java  .c  .cpp</strong>  .txt)，Java语言规范规定，Java的char类型是UTF-16的code unit，也就是一定是16位（2字节）</li></ul><h3 id="2，流向"><a href="#2，流向" class="headerlink" title="2，流向"></a>2，流向</h3><p>输出流： 程序(内存)——&gt;存储设备<br><br>输入流：键盘，磁盘等——&gt;程序(内存)</p><h3 id="3，角色"><a href="#3，角色" class="headerlink" title="3，角色"></a>3，角色</h3><p>节点流：直接读写数据，最简单的一类流<br><br>处理流：以节点流对象为形参，为节点流提供更好的性能的流<br><img src="https://img-blog.csdnimg.cn/5bac5466455a45cea57bbe2d9abcf5cd.png"></p><ul><li><strong>基类（抽象类）给定了节点流的规范</strong></li><li>子类的命名后缀规则一致，虽然有40多个类，但都很规范<br><img src="https://img-blog.csdnimg.cn/9bb30cfd68a1451cbae8f3f5703f4d44.png"></li></ul><h1 id="字符流：Reader和Writer（以FileReader和FileWriter为例）"><a href="#字符流：Reader和Writer（以FileReader和FileWriter为例）" class="headerlink" title="字符流：Reader和Writer（以FileReader和FileWriter为例）"></a>字符流：Reader和Writer（以FileReader和FileWriter为例）</h1><h2 id="1-FileWriter"><a href="#1-FileWriter" class="headerlink" title="(1)FileWriter"></a>(1)FileWriter</h2><ul><li><strong>主要方法</strong></li></ul><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">构造器 <br>FileWriter(File路径or对象，可选项append)</td><td align="center">append默认为false<br>true表示write方法<strong>追加写入</strong><br>false表示write方法<strong>覆盖写入</strong></td></tr><tr><td align="center">write(“写入的内容”)<br>write(String或char[],offset,len)</td><td align="center">可以传入String或char[ ]<br>offset表示从索引offset号开始传入<br>len表示传入的长度，<strong>注意角标越界问题</strong></td></tr><tr><td align="center">flush(空参)</td><td align="center">刷新，不刷新的话，虽然写入了，但是read不到，文件打开也看不到写入</td></tr><tr><td align="center">close()</td><td align="center">显示关闭流，防止内存溢出</td></tr></tbody></table><ul><li><p><strong>示例</strong><br>准备工作：先创建好file</p><pre><code>File file = new File(&quot;text.txt&quot;);//在当前project下创建一个text.txt文件if(!file.exists())&#123;    file.createNewFile();//防止FileNotFoundException: text.txt (系统找不到指定的文件。)&#125;  /***************Writer操作*******************/      FileWriter fileWriter = new FileWriter(file,true);//流的实例化      //append为true则多个write是追加写入      //append为false则write是覆盖写入      fileWriter.write(&quot;hello world\n&quot;);      fileWriter.flush();//刷新，不刷新的话，虽然写入了，但是read不到，文件打开也看不到写入      fileWriter.write(&quot;it&#39;s a test\n&quot;);      fileWriter.flush();//刷新  //该程序运行几遍就write几遍，下面read就会重复几遍      fileWriter.close();</code></pre><h2 id="2-FileReader"><a href="#2-FileReader" class="headerlink" title="(2)FileReader"></a>(2)FileReader</h2></li><li><p><strong>主要方法</strong></p></li></ul><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">构造器<br>FileReader(File对象或路径)<br>FileReader(FileDescriptor fd)</td><td align="center">/</td></tr><tr><td align="center">read(空参)</td><td align="center">空参<strong>迭代</strong>返回该文件的<strong>一个</strong>字符的ASCII码值data，需配合强转char输出</td></tr><tr><td align="center">read(char[] cbuf)</td><td align="center"><strong>迭代</strong>返回本次流读取的长度len，<strong>并把读取的数去填入cbuf数组中</strong></td></tr><tr><td align="center">read(char[] cbuf,偏移量offset,最大读取长度length)</td><td align="center">length为0时线程阻塞，length为<strong>装填长度</strong><br>read方法返回值<br>若某段流没有可读字符，read返回-1</td></tr></tbody></table><pre><code>  当FileReader流能read到字符时，返回值len=实际读取长度&gt;0  读取不到返回-1，所以可以利用len!=-1创建循环条件  注意区别read返回值 和 对cbuf赋值的差别</code></pre><p>read()是一个迭代器，无论是read(空参)还是read(cbuf)都会导致迭代器指针移动</p><ul><li><strong>解释：什么叫“目的缓冲区”和“装填长度”？为什么read方法最好不要带offset和len参数？</strong></li></ul><p>1.char[] cbuf数组就是目的缓冲区，把cbuf传入read()的形参，则会把目标文件中cbuf.length()个连续的字符读入cbuf，然后遍历cbuf数组，故称“缓冲”<strong>目标缓冲区(cbuf数组)设置过大则内存占用大，过小则运行速度慢。</strong><br>2.而read(cbuf,offset,len)中的len就是装填长度，装填长度不影响最后read输出结果，但可能造成角标越界<br>3.len为0线程阻塞，offset会影响读取结果，所以通常不带这两个参数</p><ul><li><strong>示例</strong><pre><code>      /*************Reder操作**************/      FileReader fileReader = new FileReader(file);//流的实例化      char[] cbuf = new char[6];//设置“目的缓冲区”      int len ; //定义“装填长度”      while((len=fileReader.read(cbuf,0,6)) != -1)&#123;//最好是不带后面两个形参      //当FileReader流能read到字符时，返回值len=实际读取长度&gt;0  //形参解析：目的缓冲区数组，offset索引偏移量(为0时保证从cbuf[0]开始装填)，  // len最大装填长度：len+offset之和不能超过cbuf.length()否则报错指针越界        //输出的方式1：注意len和length区别          for(int i = 0 ; i&lt;len ; i++)&#123;              //必须是i&lt;len“装填长度”，而不能是i&lt;cbuf.length“缓冲区长度”              System.out.print(cbuf[i]);              &#125;              &#125;       fileReader.close();</code></pre></li></ul><p><img src="https://img-blog.csdnimg.cn/1b010d62b70541ac8232765d39d0476a.png" alt="输出结果"></p><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><p>为了防止各种报错，开发时最好满足以下规范</p><ul><li>close()防止内存溢出</li><li>try-catch-finally而不是简单的throws IOException </li><li>close()放在finally中，以便出问题时及时关闭流</li><li>在finally中的close()还需要<strong>if判断是否存在，并嵌套try-catch</strong></li><li><strong>使用IDEA的alt+insert调try-catch时，会自动在外边生成FileWriter fw = null;和FileReader fr = null;</strong></li></ul><h1 id="字节流：InputStream和OutputStream"><a href="#字节流：InputStream和OutputStream" class="headerlink" title="字节流：InputStream和OutputStream"></a>字节流：InputStream和OutputStream</h1><ul><li>步骤规范：创建File对象——创建流对象——操作——关闭流</li></ul><p>我们把刚刚创建的“C:\Users\Administrator\IdeaProjects\ZJHindi\text.txt”复制到“D:\io\io1\io2”下</p><ol><li>关掉QQ(热键冲突)Alt+Ctrl+T调用try-catch-finally<br><img src="https://img-blog.csdnimg.cn/ee815e5e76ae49df930872a924a786cd.png"> </li><li>第二步<br><img src="https://img-blog.csdnimg.cn/96fd16a8e316441ea0b1a1899c9b09bc.png"></li><li>第三步，两个close()分别try -catch(注意去掉throws IOException)</li></ol><p><img src="https://img-blog.csdnimg.cn/5664f138fb254c15bee917af0abf49aa.png"><br>完整代码：</p><pre><code>package zjh;import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class CopyTest &#123;    public static void main(String[] args)&#123;        FileReader fr = null;//从源文件读取        FileWriter fw = null;//写入目的文件        try &#123;            File scrfile = new File(&quot;C:\\Users\\Administrator\\IdeaProjects\\ZJHindi\\text.txt&quot;);            File destfile = new File(&quot;D:\\io\\io1\\io2\\desttext.txt&quot;);            fr = new FileReader(scrfile);            fw = new FileWriter(destfile);            char[] cbuf = new char[5];            int len;            while((len=fr.read(cbuf))!=-1)&#123;                fw.write(cbuf);            &#125;            fw.flush();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if(fw!=null)&#123;//先判断fw非空            try &#123;                fw.close();//防止关闭时出错            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            &#125;            if(fr!=null) &#123;//判断fr非空                try &#123;                    fr.close();//关闭                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        &#125;&#125;</code></pre><h1 id="处理流：缓冲流：BufferedInputStream和BufferedOutputStream"><a href="#处理流：缓冲流：BufferedInputStream和BufferedOutputStream" class="headerlink" title="处理流：缓冲流：BufferedInputStream和BufferedOutputStream"></a>处理流：缓冲流：BufferedInputStream和BufferedOutputStream</h1><ul><li>把节点流作为形参new缓冲流，套接在已有的节点流之外</li><li><strong>传统的节点流是线程阻塞的</strong>，而缓冲流则通过<strong>在内存中开辟一块缓冲区</strong>用于各节点流缓冲，缓冲满之后执行，<strong>利用空间换时间</strong></li><li><strong>外层处理流close()的时候，内层字节流也会关闭</strong>，因此只需对外层流finally{close()}</li></ul><p>如下是一个封装好的图片复制方法：</p><pre><code>    public static void BufferedStreamCopy(String srcPath,String destPath) &#123;//缓冲流字节流的复制方法        //形参直接放入源文件路径 和 目的文件路径,文件自动复制        BufferedInputStream bis = null;//写的时候按正常步骤写        BufferedOutputStream bos = null;//这两句是try-catch-finally自动生成的        try &#123;//File对象的创建，导入路径            File srcfile = new File(srcPath);            File destfile = new File(destPath);//节点流的创建，用于复制图像视频等            FileInputStream fis = new FileInputStream(srcfile);            FileOutputStream fos = new FileOutputStream(destfile);//处理流（缓冲流）的创建，用于加速            bis = new BufferedInputStream(fis);            bos = new BufferedOutputStream(fos);            //原本对节点流的操作照搬给处理流            byte[] bbuf = new byte[1024];            int len;            while((len=bis.read(bbuf)) != -1)&#123;                //每从bis读一次，就往bos写一次                bos.write(bbuf);                &#125;            //因为有处理流自动flush，所以不用显示的flush            //缓冲区满了之后自动会flush，默认长度1024x8        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;//关闭流，只需要关闭外层            if(bis!=null)&#123;                try &#123;                    bis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(bos!=null) &#123;                try &#123;                    bos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            &#125;        &#125;</code></pre><p>调用一下：</p><pre><code>public static void main(String[] args) &#123;BufferedStreamCopy(&quot;D:\\io\\io1\\io2\\QQ截图20220115002227.png&quot;,&quot;D:\\io\\io2\\io3\\新建文件夹\\复制后的图.png&quot;);//目的路径也必须是文件，并且格式(.png)最好相同&#125;</code></pre><h2 id="字符流处理文本——-gt-字节流处理图片视频"><a href="#字符流处理文本——-gt-字节流处理图片视频" class="headerlink" title="字符流处理文本——&gt;字节流处理图片视频"></a>字符流处理文本——&gt;字节流处理图片视频</h2><ul><li> 把FileReader——&gt;FileInputStream,把FileWriter——&gt;FileOutputStream</li><li> 把char[] cbuf——&gt;byte[] bbuf</li></ul><p>其实<strong>字节流</strong>也可以<strong>复制</strong>（仅仅是复制）文本文件，<strong>只是中途不能控制台输出，否则中文会被切分</strong></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="加密算法：适用于所有文件，加密解密方法相同（-5）"><a href="#加密算法：适用于所有文件，加密解密方法相同（-5）" class="headerlink" title="加密算法：适用于所有文件，加密解密方法相同（^5）"></a>加密算法：适用于所有文件，加密解密方法相同（^5）</h2><pre><code>public static void MethodEncrpt(String srcpath,String destpath)&#123;//定义方法：加密，解密    BufferedInputStream bis = null;    BufferedOutputStream bos = null;    try &#123;        bis = new BufferedInputStream(new FileInputStream(new File(srcpath)));        bos = new BufferedOutputStream(new FileOutputStream(new File(destpath)));        int data;        while((data= bis.read()) != -1)&#123;            bos.write(data^5);//异或加密，加密解密方式都相同(M^n^n=M)        &#125;    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125; finally &#123;        if (bos != null) &#123;            try &#123;                bos.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        if (bis != null) &#123;            try &#123;                bis.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;  /********************加密解密方法使用示例********************/public static void main(String[] args) &#123;//加密MethodEncrpt(&quot;C:\\Users\\Administrator\\Desktop\\数据结构文档\\00_课程介绍.pdf&quot;,&quot;D:\\io\\加密\\字节流文件\\加密数据结构课程介绍.pdf&quot;);//解码        MethodEncrpt(&quot;D:\\io\\加密\\字节流文件\\加密数据结构课程介绍.pdf&quot;,&quot;D:\\io\\解密\\字节流文件\\解密1.pdf&quot;);MethodEncrpt(&quot;D:\\io\\io1\\io2\\desttext.txt&quot;,&quot;D:\\io\\io1\\io3\\加密1.txt&quot;);MethodEncrpt(&quot;D:\\io\\io1\\io3\\加密1.txt&quot;,&quot;D:\\io\\io1\\io3\\解密1.txt&quot;);    &#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/197ea36e2f734182a9eaf220b6ea10f5.png" alt="加密后"></p><h2 id="字数统计算法-加入了转换流"><a href="#字数统计算法-加入了转换流" class="headerlink" title="字数统计算法:加入了转换流"></a>字数统计算法:加入了转换流</h2><p>注意：实际开发中应该用try-catch-finally，此处为了方便直接throws IOException</p><pre><code>public static void MethodCount(String path) throws IOException &#123;    File file = new File(path);    FileInputStream fis = new FileInputStream(file);    BufferedInputStream bis = new BufferedInputStream(fis);    InputStreamReader isr = new InputStreamReader(bis);    HashMap&lt;Character,Integer&gt; hsm1 = new HashMap&lt;&gt;();    int len;    char[] cbuf = new char[1024];    while((len=isr.read(cbuf)) != -1)&#123;//读取到cbuf        for(int i=0 ; i&lt;len ; i++)&#123;            if(hsm1.containsKey(cbuf[i]))&#123;                hsm1.replace(cbuf[i],hsm1.get(cbuf[i])+1);            &#125;            else&#123;                hsm1.put(cbuf[i],1);            &#125;        &#125;    &#125;    //输出遍历hsm1数组    Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = hsm1.entrySet();    Iterator&lt;Map.Entry&lt;Character, Integer&gt;&gt; iterator = entries.iterator();    while (iterator.hasNext())&#123;        Map.Entry&lt;Character, Integer&gt; next = iterator.next();        Character key = next.getKey();        Integer value = next.getValue();        switch (key) &#123;            case &#39; &#39;:                System.out.println(&quot;空格：&quot;+value+&quot;次&quot;);                break;            case &#39;\t&#39;:                System.out.println(&quot;tab：&quot;+value+&quot;次&quot;);                break;            case &#39;\r&#39;:                System.out.println(&quot;回车：&quot;+value+&quot;次&quot;);                break;            case &#39;\n&#39;:                System.out.println(&quot;换行：&quot;+value+&quot;次&quot;);                break;            default:                System.out.println(key+&quot;：&quot;+value+&quot;次&quot;);                break;        &#125;    &#125;    &#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/442698d2bdb245ebab578aa34137a46c.png"></p><h2 id="加密解密GUI"><a href="#加密解密GUI" class="headerlink" title="加密解密GUI"></a>加密解密GUI</h2><p><img src="https://img-blog.csdnimg.cn/aa539cc7a4724a9082f1a652f1868cc8.png"><img src="https://img-blog.csdnimg.cn/b8edf3c2b2e049de9f9aea9c511d3ed1.png"></p><pre><code>public class EncrptDir &#123;public static void EncrptMethod(String dirpath) throws IOException &#123;//文件目录    File srcfile = new File(dirpath);    File destfile = new File(&quot;D:\\加密照片\\加密照片5&quot;);//加密照片存储地址    if(!destfile.exists())&#123;        destfile.mkdirs();    &#125;    File[] files = srcfile.listFiles();//罗列所有照片的File对象    for(int i = 0 ; i&lt;files.length ; i++)&#123;//处理每个文件        String s = files[i].getName().split(&quot;\\.&quot;)[1];//s表示文件名后缀        //split方法是正则表达式，所以要用\\.        String d = &quot;加密图片&quot;+i+&quot;.&quot; + s;        File file_jm = new File(destfile,d);        //创建节点流        FileInputStream fis = new FileInputStream(files[i]);//输入原图        BufferedInputStream bis = new BufferedInputStream(fis);        FileOutputStream fos = new FileOutputStream(file_jm);//输出加密        BufferedOutputStream bos = new BufferedOutputStream(fos);    //读写操作       int data;        while((data=bis.read())!=-1)&#123;            bos.write(data^5);//加密操作        &#125;    //关闭流        bos.close();        bis.close();        System.out.println(&quot;正在加密第  &quot;+i+&quot;  张图&quot;);    &#125;    System.out.println(&quot;加密完成，文件位于D:\\加密照片\\加密照片5&quot;);    &#125;public static void DecrptMethod(String dirpath) throws IOException &#123;//文件目录    File srcfile = new File(dirpath);    File destfile = new File(&quot;D:\\解密照片\\解密照片5&quot;);//解密照片存储地址    if(!destfile.exists())&#123;        destfile.mkdirs();    &#125;    File[] files = srcfile.listFiles();//罗列所有照片的File对象    for(int i = 0 ; i&lt;files.length ; i++)&#123;//处理每个文件        String s = files[i].getName().split(&quot;\\.&quot;)[1];//s表示文件名后缀        //split方法是正则表达式，所以要用\\.        String d = &quot;加密图片&quot;+i+&quot;.&quot; + s;        File file_jm = new File(destfile,d);        //创建节点流        FileInputStream fis = new FileInputStream(files[i]);//输入原图        BufferedInputStream bis = new BufferedInputStream(fis);        FileOutputStream fos = new FileOutputStream(file_jm);//输出解密        BufferedOutputStream bos = new BufferedOutputStream(fos);        //读写操作        int data;        while((data=bis.read())!=-1)&#123;            bos.write(data^5);//解密操作        &#125;        //关闭流        bos.close();        bis.close();        System.out.println(&quot;正在解密第  &quot;+i+&quot;  张图&quot;);    &#125;    System.out.println(&quot;解密完成，文件位于D:\\解密照片\\解密照片5&quot;);    &#125;&#125;package ZJHindi;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.io.*;public class EncrptGUI &#123;    public static void main(String[] args) &#123;        JFrame jf = new JFrame(&quot;文件加密工具&quot;);        jf.setLayout(new FlowLayout(FlowLayout.LEFT));        jf.setBounds(460,300,350,200);        /*********逻辑部分**********/        JLabel label1 = new JLabel(&quot;需要加密or解密的文件源路径:&quot;);        JTextField srcfilepath = new JTextField(&quot;&quot;,30);        JButton jButton1 = new JButton(&quot;点击加密&quot;);        jButton1.setSize(20,30);        JLabel jLabe2 = new JLabel(&quot;输出位置D:\\加密照片\\加密照片5&quot;);        jf.add(label1);        jf.add(srcfilepath);        jf.add(jButton1);        jf.add(jLabe2);        JButton jButton2 = new JButton(&quot;点击解密&quot;);        jf.add(jButton2);        JLabel jLabe3 = new JLabel(&quot;输出位置D:\\解密照片\\解密照片5&quot;);        jf.add(jLabe3);        /****************************/        jf.setVisible(true);        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        JLabel outter = new JLabel(&quot;执行信息：&quot;);        jf.add(outter);        JTextArea jta = new JTextArea();        jf.add(jta);/****************************加密*********************/        jButton1.addActionListener(new AbstractAction() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                String path = srcfilepath.getText();//获取输入的路径                try &#123;                    EncrptDir.EncrptMethod(path);                &#125; catch (IOException e1) &#123;                    e1.printStackTrace();                &#125;jta.append(&quot;加密完成\n&quot;);            &#125;            &#125;);/******************解密*****************/        jButton2.addActionListener(new AbstractAction() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                String path = srcfilepath.getText();//获取输入的路径                try &#123;                    EncrptDir.DecrptMethod(path);                &#125; catch (IOException e1) &#123;                    e1.printStackTrace();                &#125;                jta.append(&quot;解密完成\n&quot;);            &#125;        &#125;);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>File常用操作</title>
      <link href="/zjh/2022/01/13/File%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/zjh/2022/01/13/File%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="File对象实例化"><a href="#File对象实例化" class="headerlink" title="File对象实例化"></a>File对象实例化</h1><p>三种构造器</p><pre><code>File file = new File(&quot;C:\\Users\\Administrator\\Desktop\\数据结构代码\\algorithm&quot;);//绝对路径File file1 = new File(file,&quot;testtss.txt&quot;);//根据parent和child构造File file2 = new File(file,&quot;test&quot;);//相对路径</code></pre><p>相对路径在main方法体 和 Test单元测试 二者不同</p><pre><code>main是创建在当前projectTest是创建在当前module</code></pre><ul><li>File对象的实例化仅仅是内存层面开辟了一个空间</li><li>File对象可以存储<strong>文件</strong>，也可以存储<strong>文件目录</strong></li><li>File对象表示的是<strong>路径的最后一个文件</strong>，例如：”C:\Users\Administrator\Desktop\数据结构代码\algorithm”的对象对其操作更改的是algorithm文件目录<br><img src="https://img-blog.csdnimg.cn/7a49bfba1e4f42128289965a77f5c149.png" alt="该文件目录实际存在与否的区别"><h1 id="部分API"><a href="#部分API" class="headerlink" title="部分API"></a>部分API</h1><table><thead><tr><th>方法</th><th>解释</th><th>备注</th></tr></thead><tbody><tr><td>createTempFile</td><td><br>(String prefix, String suffix) <br> (String prefix, String suffix, File directory)</td><td>static方法，“创建空文件”<br>文件名前缀(最少3字符)，文件名后缀<br>前缀，后缀，指定路径的File对象</td></tr><tr><td>deleteOnExit</td><td>run结束后就删掉</td><td>创建的方式是mkdirs，但删除时是只删除该File对象路径的最末尾文件</td></tr><tr><td>delete</td><td>删除File对象对应的文件or文件目录</td><td>必须保证是末梢路径，不然不能删除并且返回false<br><strong>用delete删除的文件不走回收站</strong></td></tr><tr><td>renameTo(File dest)</td><td>1,如果<strong>destFile对象与源文件File对象</strong>是在同一个路径下，那么renameTo的作用是重命名<br> 2,如果目标文件与源文件不是在同一个路径下，那么renameTo的作用就是剪切，而且还不能操作文件夹。</td><td>见代码详解</td></tr><tr><td>getParent<br>getParentFile</td><td>返回父路径String<br>返回父路径File</td><td>用于同路径创建等操作</td></tr><tr><td>length</td><td>返回字节长度long</td><td>非空小文件的length返回值可能为0</td></tr></tbody></table></li></ul><p><a href="https://www.cnblogs.com/wangjinlong-padan/p/6382924.html">参考链接</a></p><pre><code>    File file1 = new File(&quot;D:\\io\\io2\\io3\\start.txt&quot;);    System.out.println(file1.createNewFile());//true创建成功，存在则false    File file2 = new File(&quot;D:\\io\\io1\\io3\\dest.txt&quot;);    System.out.println(file1.renameTo(file2));//dest不存在，则true    // &quot;D:\\io\\io2\\io3\\start.txt&quot;变成了&quot;D:\\io\\io1\\io3\\dest.txt&quot;( 路径不同：剪切 )    //若dest文件已存在，则返回false    File file3 = new File(&quot;D:\\io\\io1\\io3\\file.txt&quot;);    System.out.println(file2.renameTo(file3));( 同路径：重命名)</code></pre><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><h3 id="1，遍历删除"><a href="#1，遍历删除" class="headerlink" title="1，遍历删除"></a>1，遍历删除</h3><p>要求：</p><ul><li>遍历d:\io目录下的所有文件and文件目录名</li><li>删除png，img格式的文件，并告知删除成功</li></ul><p>代码示例：</p><pre><code>public class FileTest1 &#123;    public static void intoDir(File f)&#123;//定义静态方法            File[] files = f.listFiles();//罗列内部所有File对象        for(File ff : files)&#123;            if (ff.isFile())&#123;                System.out.println(&quot;文件&quot; + ff.toString());                /*****************删除img，png格式的图片文件**********/                if(ff.toString().endsWith(&quot;img&quot;) || ff.toString().endsWith(&quot;png&quot;))&#123;                    ff.delete();                    System.out.println(&quot;删除成功：&quot;+ff.toString());                &#125;                /****************************************************/            &#125;            else&#123;                System.out.println(&quot;文件目录&quot; + ff.toString());                intoDir(ff);//递归            &#125;        &#125;    &#125;    public static void main(String[] args) throws IOException &#123;    File file = new File(&quot;D:\\io&quot;);   FileTest1.intoDir(file);//调用静态遍历方法    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/7d1eec4e4ffa462dbea8d2fadcb2a6d4.png" alt="运行结果"></p><h3 id="2，遍历计算大小"><a href="#2，遍历计算大小" class="headerlink" title="2，遍历计算大小"></a>2，遍历计算大小</h3><p>要求：</p><ul><li>计算指定文件目录的大小</li><li>删除空文件（不是删空的文件目录）</li></ul><p>代码示例：</p><pre><code>public class FileTest1 &#123;    public static long sumLength(File file)&#123;        File[] files = file.listFiles();        long sum = 0;        for(File f : files)&#123;            if (f.isFile())&#123;                /****判断是否为空文件，若是则删除并告知****/                long length = f.length();                if(length == 0)&#123;                    f.delete();                    System.out.println(&quot;删除空文件：&quot;+f.toString());                &#125;                else&#123;                    sum += length;                &#125;                /*******************  *****************/            &#125;            else&#123;                FileTest1.sumLength(f);            &#125;        &#125;        return sum;    &#125;    public static void main(String[] args) &#123;        File file = new File(&quot;D:\\io&quot;);        long l = FileTest1.sumLength(file);        System.out.println(&quot;该文件总长为：&quot;+l);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/42f104763d8742e3b6dd707a10e1b2e6.png" alt="运行结果"></p><h3 id="为什么最后的文件总长计算结果为0？"><a href="#为什么最后的文件总长计算结果为0？" class="headerlink" title="为什么最后的文件总长计算结果为0？"></a>为什么最后的文件总长计算结果为0？</h3><p> <strong>因为小文件会内联存储</strong><br><a href="https://www.zhihu.com/question/23972911?rf=51585723">NTFS文件系统是如何处理小文件的</a></p><p><a href="https://product.pconline.com.cn/itbk/software/dnyw/1703/8961027.html">占用空间和文件大小的区别</a></p><table><thead><tr><th align="center"><p></th><th align="center">大小对比</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">小文件</td><td align="center">文件大小 &gt; 占用空间<br>通常,占用空间为0</td><td align="center">因为小文件内联存储</td></tr><tr><td align="center">大文件</td><td align="center">文件大小 &lt; 占用空间</td><td align="center">大文件占用空间包括了<strong>没有使用的簇</strong>的空间大小</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随机森林——泰坦尼克号获救预测</title>
      <link href="/zjh/2022/01/11/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E8%8E%B7%E6%95%91%E9%A2%84%E6%B5%8B/"/>
      <url>/zjh/2022/01/11/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E8%8E%B7%E6%95%91%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>定义问题——&gt;数据收集——&gt;数据清洗——&gt;分析——&gt;建模——&gt;验证——&gt;优化</p><p>该问题下前两步已经完成，本文从数据清洗开始</p><h1 id="数据集的特征解读"><a href="#数据集的特征解读" class="headerlink" title="数据集的特征解读"></a>数据集的特征解读</h1><table><thead><tr><th align="center">英</th><th align="center">中</th><th align="center">分析</th></tr></thead><tbody><tr><td align="center">PassengeID</td><td align="center">乘客ID</td><td align="center">乘客ID不影响Survive与否，但可标识身份</td></tr><tr><td align="center">Pclass</td><td align="center">船舱等级</td><td align="center">高等船舱靠近甲板，更容易Survive</td></tr><tr><td align="center">Name</td><td align="center">姓名</td><td align="center">标记</td></tr><tr><td align="center">Sex</td><td align="center">性别</td><td align="center">男女生理差别，对Survive有影响</td></tr><tr><td align="center">Age</td><td align="center">年龄</td><td align="center">同上</td></tr><tr><td align="center">SibSp</td><td align="center">兄弟配偶数</td><td align="center">有无同行兄弟or配偶，同行会影响决策</td></tr><tr><td align="center">Parch</td><td align="center">父母孩子数</td><td align="center">有无同行父母or孩子，从而影响Survive</td></tr><tr><td align="center">Ticket</td><td align="center">船票信息</td><td align="center">/</td></tr><tr><td align="center">Fare</td><td align="center">票价</td><td align="center">票价跟Pclass也是正相关</td></tr><tr><td align="center">Cabin</td><td align="center">船舱信息</td><td align="center">/</td></tr><tr><td align="center">Embarked</td><td align="center">港口</td><td align="center">/</td></tr><tr><td align="center">Survived</td><td align="center">存活与否</td><td align="center">/</td></tr></tbody></table><p>以上信息中</p><ul><li>有些特征对分析没什么意义，建模时可以不扔进算法</li><li>有些特征之间互相有关联，可以多特征线性合并</li><li>部分数据需要清洗</li><li>Train集中的Survived变量要放入模型训练</li><li>Test集中的Survived变量作为验证标准</li></ul><h1 id="库和数据导入，简单分析"><a href="#库和数据导入，简单分析" class="headerlink" title="库和数据导入，简单分析"></a>库和数据导入，简单分析</h1><pre><code>import pandas as pdimport numpy as npimport timeimport sklearnfrom sklearn import ensemble#集成学习，包括了随机森林，SVM等集成学习算法from sklearn import feature_selection#特征值选择，分类回归都需要的特征值如F和Pfrom sklearn import model_selection#模型选择，包括了交叉验证，网格搜索等from sklearn import metrics#包括了多个计算模型评估的算法from sklearn.preprocessing import LabelEncoder#将Label标准化，如：字符串——&gt;数字，以便代入模型##绘图import matplotlib as mplimport matplotlib.pyplot as pltimport seaborn as sns#一个封装好的matplotlib，底层是matplotlib，使用更方便#mpl.style_use(&quot;ggplot&quot;)#设置matplotlib的绘图风格，可有可无data_train = pd.read_csv(&quot;train.csv&quot;)data_test  = pd.read_csv(&quot;test.csv&quot;)#显示数据集信息print(data_train.info())print(data_test.head(10))</code></pre><h2 id="完整显示数据集统计信息（完整描述）set-option"><a href="#完整显示数据集统计信息（完整描述）set-option" class="headerlink" title="完整显示数据集统计信息（完整描述）set_option"></a>完整显示数据集统计信息（完整描述）set_option</h2><pre><code>pd.set_option(&#39;display.max_columns&#39;,11)#train集中有11列属性，设置最大列数为11print(data_train.describe())</code></pre><ul><li>同样的，pd.set_option(‘display.max_columns’,10)也可以让原本显示不全的head()显示全</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/5cef01f2bb72055365b892b39b01cdfb.png" alt="info和head输出结果"></p><pre><code>count:有效值个数（非空值）unique:特征值的种类数top：出现最多的特征freq: top出现的次数mean：均值std : 标准差min ：最小值25%：四分之一位50%：中位数75%：四分之三位max：最大值</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/aadde03b94c0c0ced9033806d8fa540f.png" alt="describe输出结果"></p><ul><li><strong>一共有891行数据，但Age、Cabin属性明显缺失，此案例下的缺失值暂时用中位数代替</strong></li></ul><h1 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h1><p>数据清洗是数据分析中耗时最长最麻烦的阶段</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><pre><code>#列名小写,方便后续data_test.columns = data_test.columns.str.lower()data_train.columns = data_train.columns.str.lower()data_train.info()#查看属性小写后的info#合并Train和Test以便统一数据清洗data_sum = [data_train , data_test]#但由于这个sum是一个list，会缺少很多原本train和test能用的属性or方法，如columns#注意：此处的合并不是直接合并数据集，而是创建一个list，实现一键操作#一定是先分别lower再合并成sum</code></pre><p>   <strong>要想调用方法，需要使用for循环</strong></p><h3 id="查看survived的统计直方图"><a href="#查看survived的统计直方图" class="headerlink" title="查看survived的统计直方图"></a>查看survived的统计直方图</h3><pre><code>#查看属性统计量seaborn下的countplot，绘制图像sns.countplot(x = data_train[&#39;survived&#39;] )#sns.coutplot(x = &quot;survived&quot; , data = data_train)#两种表达方式plt.show()#olt.show()是生成图的操作，必不可少</code></pre><h2 id="补全缺失值fillna"><a href="#补全缺失值fillna" class="headerlink" title="补全缺失值fillna"></a>补全缺失值fillna</h2><pre><code>#分别查看train和test集中为null值的汇总print(data_train.isnull().sum())print(&#39;\n&#39;)print(data_test.isnull().sum())</code></pre><ul><li><strong>age embarked的缺失值占比比较少，可以替换值</strong></li><li><strong>cabin的缺失值占比很高，建模时直接把cabin属性全扔掉</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/6608f6f8d8f17032998fd2e2801c213b.png" alt="左：null汇总  右：contplot直方图"></p><h3 id="利用for循环对样本集一键纠正"><a href="#利用for循环对样本集一键纠正" class="headerlink" title="利用for循环对样本集一键纠正"></a>利用for循环对样本集一键纠正</h3><pre><code>for dataset in data_sum:    dataset[&#39;age&#39;].fillna(dataset[&#39;age&#39;].median() , inplace=True)    dataset[&#39;fare&#39;].fillna(dataset[&#39;fare&#39;].median() , inplace=True)    ###因为age、fare都是数字类型，因此可以调用median中位数    ###而像属性值位字符串的特征则不能调用median    dataset[&#39;embarked&#39;].fillna(dataset[&#39;embarked&#39;].mode()[0] , inplace=True)    #mode返回的是 众数，因为即便是字符串，也可以调用</code></pre><ul><li><p>注意：mode和median的用法场景区别</p></li><li><p>注意fillna的使用格式</p></li><li><p>inplace=True表示更改原数据集，而不是返回一个新的数据集</p></li><li><p>mode是pandas下的一个方法，返回按索引号排序的众数，<strong>mode()[索引号]的索引号很重要，如果省略则不填充</strong></p><h2 id="删除无用字段-特征-drop"><a href="#删除无用字段-特征-drop" class="headerlink" title="删除无用字段(特征)drop"></a>删除无用字段(特征)drop</h2><p>  drop_columns = [‘cabin’,’passengerid’,’ticket’]#创建一个list<br>  #分析认为：cabin缺失值太多，需要删除<br>  #passengerid无关survive，删除<br>  #ticket都是编号，删除</p><p>  data_train.drop(drop_columns,axis=1,inplace=True)<br>  data_test.drop(drop_columns,axis=1,inplace=True)<br>  #drop参数的意义(行or列 , axis=0删行 axis=1删列 ， inplace=True直接更改调用者数据集本身)</p></li><li><p>注意：drop的参数含义</p></li><li><p>可以构建for循环 + drop_columns一次操作</p></li></ul><h2 id="纠正异常值"><a href="#纠正异常值" class="headerlink" title="纠正异常值"></a>纠正异常值</h2><h3 id="利用for循环的样本集一键纠正"><a href="#利用for循环的样本集一键纠正" class="headerlink" title="利用for循环的样本集一键纠正"></a>利用for循环的样本集一键纠正</h3><p>因为这个案例中信息来源准确，可以认为没有异常值，故在此案例中不做处理</p><h2 id="构建新特征"><a href="#构建新特征" class="headerlink" title="构建新特征"></a>构建新特征</h2><ul><li>连续值用cut或者qcut来划分</li><li>离散值直接划分，合并数量少的值<h3 id="同行规模"><a href="#同行规模" class="headerlink" title="同行规模"></a>同行规模</h3><pre><code>  #同行规模 = 配偶 + 兄弟姐妹 + 1(自己)  dataset[&#39;together_size&#39;] =  dataset[&#39;sibsp&#39;] + dataset[&#39;parch&#39;] + 1</code></pre></li></ul><h3 id="是否单身"><a href="#是否单身" class="headerlink" title="是否单身"></a>是否单身</h3><pre><code>    #是否单身：单身可以不顾别人，会影响survive    dataset[&#39;isSingle&#39;] = 0    dataset[&#39;isSingle&#39;].loc[dataset[&#39;together_size&#39;] &gt; 1] = 1</code></pre><h3 id="票价分段：cut"><a href="#票价分段：cut" class="headerlink" title="票价分段：cut"></a>票价分段：cut</h3><pre><code>    #票价分段fare_bin:票价的离散值太多，应该划分为几个集    #数据集中票价0~512，并且绝大多数都是便宜票，所以用cut等宽划分    dataset[&#39;fare_bin&#39;] = pd.cut(dataset[&#39;fare&#39;] , 4)</code></pre><h3 id="年龄分段：qcut"><a href="#年龄分段：qcut" class="headerlink" title="年龄分段：qcut"></a>年龄分段：qcut</h3><pre><code>    #年龄分段age_bin    dataset[&#39;age_bin&#39;] = pd.qcut(dataset[&#39;age&#39;] , 4)</code></pre><h3 id="身份分类：合少为1"><a href="#身份分类：合少为1" class="headerlink" title="身份分类：合少为1"></a>身份分类：合少为1</h3><pre><code>    #身份 status:因为英国人的名字会加入跟身份有关的职业，身份也会影响获救概率    dataset[&#39;status&#39;] = dataset[&#39;name&#39;].str.split(&#39;, &#39; , expand = True)[1].str.split(&#39;.&#39; , expand = True)[0]    ###参数含义：str是返回字符串，expand要为True值    ###按引号中的符号进行split拆分，[0]表示取前半段，[1]表示取后半段    print(dataset[&#39;status&#39;].value_counts())#查看统计</code></pre><p><img src="https://img-blog.csdnimg.cn/6a4e973ba6174e63a9514db8712abbc3.png" alt="可以把少的分为一类other"></p><pre><code>   #把少的分为一类other    othersSum = dataset[&#39;status&#39;].value_counts() &lt; 10    #other对象 = 小于10的    dataset[&#39;status&#39;] = dataset[&#39;status&#39;].apply(lambda x : &#39;ohter&#39; if othersSum[x] else x)    #更新后的status属性 = 之前的status.aooly(lambda x : &#39;新的名字&#39; if other对象[x] else x)    print(dataset[&#39;status&#39;].value_counts())</code></pre><p><img src="https://img-blog.csdnimg.cn/2629dc2066e64987b95896a87db5dd6c.png" alt="少的被分到了other组"></p><h2 id="新特征分析：评估新特征划分的好坏"><a href="#新特征分析：评估新特征划分的好坏" class="headerlink" title="新特征分析：评估新特征划分的好坏"></a>新特征分析：评估新特征划分的好坏</h2><p>以不同的特征分类计算各属性值的均值，以标签survived的均值为参考，不同特征值的标签均值差别越大越好</p><pre><code>#简单分析上述构建特征是否有效:groupby根据属性值分组print(data_train[&#39;survived&#39;].groupby(data_train[&#39;status&#39;]).mean())#查看按这样构建的特征status的不同值survived对应的均值print(data_train[&#39;survived&#39;].groupby(data_train[&#39;age_bin&#39;]).mean())print(data_train[&#39;survived&#39;].groupby(data_train[&#39;fare_bin&#39;]).mean())print(data_train[&#39;survived&#39;].groupby(data_train[&#39;isSingle&#39;]).mean())print(data_train[&#39;survived&#39;].groupby(data_train[&#39;together_size&#39;]).mean())</code></pre><p><img src="https://img-blog.csdnimg.cn/7fb4dcd3150d4be886223a0af1715d6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_19,color_FFFFFF,t_70,g_se,x_16" alt="新特征分析">于是对age_bin进行修改，最终尝试结果是qcut改cut，区分度提升最明显</p><h1 id="格式替换-构建新字段，"><a href="#格式替换-构建新字段，" class="headerlink" title="格式替换,构建新字段，"></a>格式替换,构建新字段，</h1><p>1，基于scikit-learn中的LabelEncoder()<br>把属性值为字符串的特征转化为“特征_code”，字符串——&gt;数字，以便放入模型中跑<br><strong>机器学习模型只能处理int和float的数据</strong></p><pre><code>#实例化label = LabelEncoder()#字符串——&gt;数字for dataset in data_sum:    # （1）新字段：sex_code    dataset[&#39;sex_code&#39;] = label.fit_transform(dataset[&#39;sex&#39;])    # （2）新字段：embarked_code    dataset[&#39;embarked_code&#39;] = label.fit_transform(dataset[&#39;embarked&#39;])    # （3）新字段：status_code    dataset[&#39;status_code&#39;] = label.fit_transform(dataset[&#39;status&#39;])    # （4）新字段：age_bin_code    dataset[&#39;age_bin_code&#39;] = label.fit_transform(dataset[&#39;age_bin&#39;])    # （5）新字段：fare_bin_code    dataset[&#39;fare_bin_code&#39;] = label.fit_transform(dataset[&#39;fare_bin&#39;])print(data_train.columns.to_list)    </code></pre><p><img src="https://img-blog.csdnimg.cn/e20dfbee4e5b4bb7992cfb15aaeae6ac.png" alt="新的列名"><br><img src="https://img-blog.csdnimg.cn/cda97a956c634886b678242a3a315ec8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br>2，通过Pandas中的get_dummies() 进行编码</p><h1 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h1><h2 id="标签、特征选择"><a href="#标签、特征选择" class="headerlink" title="标签、特征选择"></a>标签、特征选择</h2><h3 id="标签选择"><a href="#标签选择" class="headerlink" title="标签选择"></a>标签选择</h3><pre><code>target = [&#39;survived&#39;]    </code></pre><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><pre><code>data_feature_one = [&#39;sex&#39;, &#39;pclass&#39;, &#39;embarked&#39;, &#39;status&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;age&#39;, &#39;fare&#39;, &#39;together_size&#39;,                    &#39;isSingle&#39;]</code></pre><h3 id="通过Pandas中的get-dummies-进行编码"><a href="#通过Pandas中的get-dummies-进行编码" class="headerlink" title="通过Pandas中的get_dummies() 进行编码"></a>通过Pandas中的get_dummies() 进行编码</h3><p>这是一个暴力转码（字符串——&gt;数字代号）的方法，十分简单，且更好用</p><pre><code>data_one_dummy = pd.get_dummies(data_train[data_feature_one])#把data_feature_one中需要转码的如：status、embarked转为数字代号data_one_dummy_list = data_one_dummy.columns.tolist()#转list，以便放入网格搜索的形参中去跑</code></pre><h2 id="把train集拆分为训练集和测试"><a href="#把train集拆分为训练集和测试" class="headerlink" title="把train集拆分为训练集和测试"></a>把train集拆分为训练集和测试</h2><pre><code>X_train_one, X_test_one, y_train_one, y_test_one = model_selection.train_test_split(data_one_dummy[data_one_dummy_list],#转码后的list格式的train[feature]                                                                    data_train[target],#标签                                                                    random_state = 0)#随机种子print(X_train_one.shape)print(X_test_one.shape)#shape查看分割的大小，也可以通过size参数自己设置分割比例,数据量很大时通常使用2 8分，train_size=0.8print(y_train_one.shape)print(y_test_one.shape)#大X表示：特征  小y表示：标签</code></pre><p><img src="https://img-blog.csdnimg.cn/f70f693e524f4c75bfdb6ccfe37883b4.png" alt="左：数据量(行)  右：特征数(列)"></p><h2 id="网格搜索：寻找最优"><a href="#网格搜索：寻找最优" class="headerlink" title="网格搜索：寻找最优"></a>网格搜索：寻找最优</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><pre><code>from sklearn.model_selection import GridSearchCV   #网格搜索from sklearn.ensemble import RandomForestClassifier #随机森林分类器rfc = RandomForestClassifier(max_features=&#39;auto&#39; , random_state= 0 , n_jobs=-1 )#实例化一个RandomForestClassifier对象#简单选取所有特征 ， 随机种子=0  ， 利用所有线程#这里实例化RandomForestClassifier时可以不用写入太多参数，参数可以放进网格里面自己跑出最优的</code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><pre><code>param_gird = &#123;#需要最优化的参数对象    &#39;criterion&#39; : [&#39;gini&#39;, &#39;entropy&#39;],#标准选择    &#39;min_samples_leaf&#39; : [ 1,3,5, 10],#最小子叶数    &#39;min_samples_split&#39; : [10, 12, 16,20,24],#最小样本数    &#39;n_estimators&#39; : [20,35,50,100]#决策树的个数选择&#125;gscv = GridSearchCV(#网格搜索交叉验证对象                estimator=rfc,#rf带入网格算                param_grid=param_gird,#需要最优化的参数带入                scoring= &#39;accuracy&#39;, #得分评判————准确度                cv=3,#交叉验证次数                n_jobs=-1)#-1 利用CPU所有线程gs = gscv.fit(X_train_one , y_train_one.values.ravel())#自动训练，两个参数都是train集#.values.ravel()是为了防止warning#自动训练的所有结果返回在gs中，这个print(gs.best_score_)#最高分数print(gs.best_params_)#最佳组合</code></pre><p><img src="https://img-blog.csdnimg.cn/7b7e4e2ba989488b8e4d553f025731fc.png"></p><h3 id="网格搜索调参"><a href="#网格搜索调参" class="headerlink" title="网格搜索调参"></a>网格搜索调参</h3><ul><li>如果某特征的最优值是在罗列的数的中间，那么认为比较优秀</li><li>如果在边上，就需要往那个方向调参重新跑</li><li>同时有多个参数需要调时，先调差距最大的</li><li>即使是位于中间的参数也可以细分调整</li><li>类似高中生物实验探究题《寻找最佳浓度》的思想</li></ul><h2 id="用最优参数训练随机森林"><a href="#用最优参数训练随机森林" class="headerlink" title="用最优参数训练随机森林"></a>用最优参数训练随机森林</h2><pre><code>#实例化RandomForestClassifier对象rfc2 = RandomForestClassifier(criterion=&#39;entropy&#39;,                             min_samples_leaf=5,                             min_samples_split=16,                             n_estimators=35,                             n_jobs=-1,                             random_state=1)#训练rfc2.fit(X_train_one, y_train_one.values.ravel())</code></pre><p>此时训练完成，等待后续用<strong>split分割出来的测试集test来测试</strong></p><h3 id="根据特征的重要性排序"><a href="#根据特征的重要性排序" class="headerlink" title="根据特征的重要性排序"></a>根据特征的重要性排序</h3><pre><code>print(pd.concat((pd.DataFrame(X_train_one.iloc[:, 1:].columns, columns=[&#39;Variable&#39;]),           pd.DataFrame(rfc2.feature_importances_, columns=[&#39;importance&#39;])),           axis=1).sort_values(by=&#39;importance&#39;, ascending=False))</code></pre><p><img src="https://img-blog.csdnimg.cn/1583b73b3f2845c2b203ded785146e72.png"></p><ul><li><strong>重要性</strong>：重要性是特征在模型中的决定能力，而不是越高就代表标签越接近1</li></ul><h2 id="在test上预测：是split分割出来的test"><a href="#在test上预测：是split分割出来的test" class="headerlink" title="在test上预测：是split分割出来的test"></a>在test上预测：是split分割出来的test</h2><pre><code>predict_test = rfc2.predict(X_test_one)#test集中的特征数据Xpred_df = pd.DataFrame(predict_test, columns=[&#39;survived&#39;])#预测结果表print(pred_df)#test集的验证结果print(&#39;随机森林 AUC...&#39;)fpr_test, tpr_test, th_test = metrics.roc_curve(predict_test, y_test_one)# 构造 roc 曲线print(&#39;AUC = %.4f&#39; %metrics.auc(fpr_test, tpr_test))#参考意义最大的就是AUCprint(&#39;随机森林精确度...&#39;)print(metrics.classification_report(predict_test, y_test_one))#精准度表格</code></pre><p><img src="https://img-blog.csdnimg.cn/04fabbe4baed47c68ad12214800bf1d0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_19,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="验证：不是split分割出来的test，而是test-csv"><a href="#验证：不是split分割出来的test，而是test-csv" class="headerlink" title="验证：不是split分割出来的test，而是test.csv"></a>验证：不是split分割出来的test，而是test.csv</h2><pre><code>data_val_dummy = pd.get_dummies(data_test[data_feature_one])#转码data_val_dummy_list = data_val_dummy.columns.tolist()print(data_val_dummy_list)#查看转码后的列名，拿着这些列名预测pred_val = rfc2.predict(data_val_dummy[[#根据上一条语句的结果，copy了列名                                        &#39;pclass&#39;, &#39;sibsp&#39;, &#39;parch&#39;, &#39;age&#39;,                                        &#39;fare&#39;, &#39;together_size&#39;, &#39;isSingle&#39;,                                        &#39;sex_female&#39;, &#39;sex_male&#39;, &#39;embarked_C&#39;,                                        &#39;embarked_Q&#39;, &#39;embarked_S&#39;, &#39;status_Master&#39;,                                        &#39;status_Miss&#39;, &#39;status_Mr&#39;, &#39;status_Mrs&#39;,                                        &#39;status_ohter&#39;]])pred_val_df = pd.DataFrame(pred_val, columns=[&#39;survived&#39;])print(pred_val_df.head(10))#展示前10个数据</code></pre><p><img src="https://img-blog.csdnimg.cn/348435ac3b974dfd827f256ee10998f0.png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/zjh/2022/01/03/Java%E9%9B%86%E5%90%88/"/>
      <url>/zjh/2022/01/03/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><blockquote><ul><li>集合框架被设计成要满足以下几个目标。<br></li><li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。<br></li><li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li><li>对一个集合的扩展和适应必须是简单的。</li></ul></blockquote><p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet 等,<strong>除此之外你也可以通过这些接口实现自己的集合。</strong></p><p><img src="https://img-blog.csdnimg.cn/202109060840461.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/20210906085157676.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/20210906085253299.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif"></p><p><strong>一般名为xxxxList  xxxxSet   xxxxMap的类都是集合，集合的子类非常多，本文介绍以下的集中常用集合类</strong><br>常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。</p><blockquote><p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p></blockquote><blockquote><p><strong>接口</strong>：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</p></blockquote><blockquote><p><strong>实现（类）</strong>：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</p></blockquote><blockquote><p><strong>算法</strong>：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。**(Collections类提供了排序，遍历等多种算法实现)**<br>Java 集合框架提供了一套性能优良，使用方便的接口和类，<strong>java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。</strong></p></blockquote><h1 id="线程安全和线程不安全的集合"><a href="#线程安全和线程不安全的集合" class="headerlink" title="线程安全和线程不安全的集合"></a>线程安全和线程不安全的集合</h1><p>Vector、HashTable、Properties是线程安全的；</p><p>ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap等都是线程不安全的。</p><h1 id="Collection根接口：单列集合"><a href="#Collection根接口：单列集合" class="headerlink" title="Collection根接口：单列集合"></a>Collection根接口：单列集合</h1><p>Collection下定义了很多方法：<strong>add  addAll  clear  contains  containsAll  equals  hashCode  isEmpty  iterator  parallelStream  remove  removeAll  removeIf  retainAll  size  spliterator  stream  toArray</strong>等</p><h2 id="List子接口：有序可重复"><a href="#List子接口：有序可重复" class="headerlink" title="List子接口：有序可重复"></a>List子接口：有序可重复</h2><p>有序：List的有序源于它的元素有地址值<br>List接口下的ArrayList，LinkedList都线程不安全，多线程访问时需显式同步。</p><h3 id="ArrayList实现类："><a href="#ArrayList实现类：" class="headerlink" title="ArrayList实现类："></a>ArrayList实现类：</h3><p>List接口的主要实现类<br>底层是Object[] elementData(<strong>动态可修改的数组，封装好的数组，存储地址连续</strong>)</p><ul><li>增删操作低效(底层是数组)</li><li>查找、修改效率高(有索引)</li><li>执行效率高，但线程不安全。多线程访问时需显式同步。</li></ul><h4 id="ArrayList底层分析"><a href="#ArrayList底层分析" class="headerlink" title="ArrayList底层分析"></a>ArrayList底层分析</h4><ul><li><strong>参数int capacity:</strong> 空参默认底层创建长度为10的数组，<br>JDK7之前是“饿汉”，JDK8之后是“懒汉”————JDK8后延迟底层数组创建，<em>new时底层不创建数组，当且仅当add元素后创建底层数组</em>，节约了内存</li><li><strong>扩容:</strong> 当前底层数组长度不够用时，扩容为原来的<strong>1.5倍</strong></li><li>开发中尽量带参构造，防止内存浪费</li></ul><h3 id="LinkedList实现类："><a href="#LinkedList实现类：" class="headerlink" title="LinkedList实现类："></a>LinkedList实现类：</h3><p>底层是<strong>双向链表</strong></p><ul><li>增删效率高(改变链表的next和prev地址即可，涉及的操作元素很少)</li><li>查找、修改效率低(没有索引)</li><li>执行效率高，但线程不安全。多线程访问时需显式同步。<blockquote><p>LinkedList 继承了 AbstractSequentialList 类。<br><br>LinkedList 实现了 Queue 接口，可作为队列使用。<br><br>LinkedList 实现了 List 接口，可进行列表的相关操作。<br><br>LinkedList 实现了 Deque 接口，可作为队列使用。<br><br>LinkedList 实现了 Cloneable 接口，可实现克隆。<br><br>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。</p></blockquote></li></ul><h2 id="Set子接口：无序不可重复"><a href="#Set子接口：无序不可重复" class="headerlink" title="Set子接口：无序不可重复"></a>Set子接口：无序不可重复</h2><p>因为无序，所以不能重复，类似于高中所学的“集合”<br><br>开发中Set接口用的不太多，一般用List和Map更多</p><ul><li>Set没有额外定义方法，所有方法和Collection根接口定义的相同</li><li><strong>无序性</strong>：不是随机，而是add时由数据的哈希值决定存储位置，对外“相对无序”<br></li><li><strong>不可重复性</strong>：add时先调用hashcode方法算哈希值，不相等则直接add；若有相同的哈希值，则进行equals方法比对细节，若还相等，则add方法返回false，添加失败</li></ul><h3 id="HashSet实现类"><a href="#HashSet实现类" class="headerlink" title="HashSet实现类"></a>HashSet实现类</h3><p>底层是<strong>哈希表</strong>(元素为链表的数组)</p><ul><li>效率高，但线程不安全。多线程访问时需显式同步。</li><li>可以存储一个null值并分配空间</li><li>遍历无序，每次遍历输出的顺序都可能不同</li></ul><h4 id="LinkedHashSet实现类"><a href="#LinkedHashSet实现类" class="headerlink" title="LinkedHashSet实现类"></a>LinkedHashSet实现类</h4><ul><li>LinkedHashSet是HashSet的一个子类<br>底层是<strong>哈希表+链表</strong>(链表可以保证元素的顺序透明)</li><li>遍历时会<strong>按照添加进来的顺序进行遍历</strong><blockquote><p>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p></blockquote></li><li><em>LinkedHashSet在迭代访问（遍历）Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</em>*<br><br><br>在开发中由需求决定具体使用哪个</li></ul><blockquote><ul><li>补充：去除List中重复元素的方法：把List对象扔给LinkedHashSet的构造器形参</li></ul></blockquote><h3 id="TreeSet实现类（用的少）"><a href="#TreeSet实现类（用的少）" class="headerlink" title="TreeSet实现类（用的少）"></a>TreeSet实现类（用的少）</h3><p>SortedSet接口的唯一实现类，<strong>自排序</strong>的集合<br><br>底层是<strong>红黑树</strong>(自平衡的二叉树)</p><ul><li><strong>自排序</strong>：存储元素的类必须实现Comparable接口或Comparator接口<br><br>  并且为了保证可以排序，<strong>后续add的所有元素必须跟第一个add的元素类型相同</strong>，否则报错ClassCastException</li><li><strong>包装类的自排序</strong>：由于包装类都实现了Comparable自然排序，所以包装类元素可以直接扔进TreeSet</li><li>自定义类需先实现排序接口才能扔进TreeSet</li></ul><h1 id="Map根接口"><a href="#Map根接口" class="headerlink" title="Map根接口"></a>Map根接口</h1><p>双列数据，存储键值对，类似高中函数y=f(x)<br>key:无序、不可重复——&gt;Set储存<br>value:无序、可重复——&gt;Collection储存</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><a href="https://zhuanlan.zhihu.com/p/78079598">链接：HashMap底层原理</a></p><p>散列表</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="/zjh/2022/01/02/Java%E6%B3%9B%E5%9E%8B/"/>
      <url>/zjh/2022/01/02/Java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Java 泛型（generic）是 JDK 5 中引入的一个新特性, 泛型提供了<strong>编译时</strong>类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>泛型设计背景：集合容器类在设计/声明的时候不能确定到底是存储什么类型的元素，但对元素如何存储，如何使用都是清楚的，唯一不确定的是元素的类型，因此在JDK1.5的时候引入了泛型来解决这个问题；把元素的类型设置为一个参数，这个参数就叫泛型：Collection<E>  List<E>  Map<E>这个E就是类型参数，即泛型；</p><p>什么时候使用：设计时只设计用法不考虑类型，使用时必须确定类型</p><p>正如ArrayList<String>表示的含义即为：只能存储String类型元素的ArrayList集合</p><h1 id="1-0泛型使用特点"><a href="#1-0泛型使用特点" class="headerlink" title="1.0泛型使用特点"></a>1.0泛型使用特点</h1><p>在<strong>编译之后程序会采取<u>去泛型化</u>的措施</strong>。也就是说Java中的泛型，<u>只在编译阶段有效</u>。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出（<strong>类型擦除</strong>），并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><h2 id="1-1符号"><a href="#1-1符号" class="headerlink" title="1.1符号"></a>1.1符号</h2><p>常用的通配符有T,E,K,V分别表示类型、元素、键、值，当然这并不是硬性规定，而是大家形成的一种通识。</p><h2 id="1-2规范"><a href="#1-2规范" class="headerlink" title="1.2规范"></a>1.2规范</h2><p>泛型只能是类，不能是基本数据类型：int(×) Integer(√)</p><p>定义了泛型之后，在编译期也要受泛型的约束，从而在某些情况可以避免强转操作</p><p>方法中不是出现<E>就一定是泛型方法，详见</p><p>类上声明的泛型<T>和类中又声明的泛型<E>是两回事</p><h1 id="2-0泛型的声明与指定"><a href="#2-0泛型的声明与指定" class="headerlink" title="2.0泛型的声明与指定"></a>2.0泛型的声明与指定</h1><p><a href="https://www.cnblogs.com/GGYC/p/10951794.html?ivk_sa=1024320u">链接：泛型的使用场景</a></p><h2 id="2-1类上声明"><a href="#2-1类上声明" class="headerlink" title="2.1类上声明"></a>2.1类上声明</h2><p>声明在类上时，写在类名后边；作为参数或者返回值时，如果在类上没有声明，必须在访问修饰符和返回值之间</p><pre><code>/** * 声明在类上时，写在类名后边 * @param &lt;E&gt; */class Animal &lt;E&gt; &#123;    /**     * 作为属性声明时，必须在类上声明泛型     */    E pet;     /**     * 作为参数或者返回值时，如果在类上没有声明，必须在访问修饰符和返回值之间     * @param pet     */    public  void setPet(E pet)&#123;        this.pet = pet;    &#125;     public E getPet()&#123;        return pet;    &#125;//这里的T在泛型类中没有声明，所以要在泛型方法中&lt;T&gt;声明为泛型方法    public &lt;T&gt; void call(T t)&#123;        System.out.println( t.toString() );     &#125; &#125;</code></pre><h2 id="2-2接口声明、子类声明和指定"><a href="#2-2接口声明、子类声明和指定" class="headerlink" title="2.2接口声明、子类声明和指定"></a>2.2接口声明、子类声明和指定</h2><p>使用泛型实现时，实现类必须使用对应的泛型类。<br>实现类声明泛型跟接口指定泛型可以同时使用。（“声明”“指定”互不影响）</p><pre><code>/** * 作用在接口上，如果实现该接口时指定实现类型 * @param &lt;T&gt; */public interface Animals&lt;T&gt;&#123;    double PI = 3.1415926535;//等价于public static final double PI = 3.1415926535;    void call(T t);//等价于public abstract void call(T t);&#125;/** * 拉布拉多犬 */ /** * 使用泛型实现时，实现类必须使用对应的泛型类。 * 实现类声明泛型跟接口指定泛型可以同时使用。 *如下代码： */ class LaBuLaDuo&lt;T&gt; implements Animals&lt;String&gt; &#123;//&lt;T&gt;是声明新泛型  &lt;String&gt;是指定旧泛型     public void call(String s) &#123;        System.out.println( s );    &#125; &#125;</code></pre><h2 id="2-3泛型通配符？-上限与下限"><a href="#2-3泛型通配符？-上限与下限" class="headerlink" title="2.3泛型通配符？ 上限与下限"></a>2.3泛型通配符？ 上限与下限</h2><p>泛型占位符  ?  的使用<br>如何设置泛型的上限下限</p><p>上限：泛型为E或者E的子类：&lt;? extends E&gt;</p><p>下限：泛型为E或者E的父类：&lt;? super E&gt;</p><p>单独使用：泛型为Object及其子类：&lt;?&gt;</p><pre><code>/** * 小狗狗 */ class Dog extends  Animal &#123;    public String name;    public Integer age; &#125;  /** * 泛型占位符  ?  的使用 * 泛型的上限 &lt; ? extends E&gt;  即传入参数必须为E 的子类 * 泛型的下限 &lt; ? super E&gt; */public class ErHa &lt;E&gt;  &#123;     //当参数传递时可以设置上下限 比如下面的是  传入类型必须是 Dog 的子类，上限为Dog    public  void call(Animal&lt; ? extends E&gt; s)&#123;        System.out.println(s.pet);    &#125;     //传入类型必须是 Dog 的父类，下限为Dog    public  void jump(Animal&lt; ? super E&gt; s)&#123;        System.out.println(s.pet);    &#125;     // ? 占位符单独使用时，相当于 &lt; ? extends Object &gt;    public  void smile(Animal&lt;?&gt; s)&#123;        System.out.println(s.pet);    &#125;      public static void main(String[] args) &#123;        new ErHa&lt;Dog&gt;().call(new Dog());    &#125;&#125;</code></pre><h2 id="2-4上下边界的测试和get-set限制及解释"><a href="#2-4上下边界的测试和get-set限制及解释" class="headerlink" title="2.4上下边界的测试和get set限制及解释"></a>2.4上下边界的测试和get set限制及解释</h2><pre><code>class plate&lt;T&gt;&#123;    private T t;    public plate(T t)&#123;        this.t = t;    &#125;    public  void set(T t)&#123;//测试1        this.t = t;    &#125;    public T get()&#123;        return t;    &#125;&#125;  class Food&#123;&#125;class Furit extends Food&#123;&#125;class Apple extends Furit&#123;&#125;class Banana extends Furit&#123;&#125;   /*************下面测试上下边界通配符***************/         //1.0 extends 通配符上界        plate&lt;? extends Furit&gt; p10 = new plate&lt;Furit&gt;(new Apple());        plate&lt;? extends Furit&gt; p11 = new plate&lt;Banana&gt;(new Banana());        p10 = p11;        p11 = p10;        //上述例子中，&lt;? extends Furit&gt;表示“该盘子可以装Furit包括Furit的所有子类”        //2.0 super 通配符下界(注意第二个&lt;&gt;中的细微差别)        plate&lt;? super Furit&gt; p12 = new plate&lt;Furit&gt;(new Apple());        plate&lt;? super Furit&gt; p13 = new plate&lt;Furit&gt;(new Banana());//        p13.set(new Food());        p13.set(new Furit());        plate&lt;? super Furit&gt; p14 = new plate&lt;Food&gt;(new Food());        plate&lt;? super Furit&gt; p15 = new plate&lt;Furit&gt;(new Furit());        p12 = p13;        p13 = p14;        p14 = p15;        //上述例子中，&lt;? super Furit&gt;表示“该盘子可以装Fuirt包括Fuirt的所有父类”        //并且可知：当指定了泛型时，可以装入泛型的实例化子类          /************通配符？有get和set的限制规则**************/        //p10 p11是extends通配符上界，p12~p15是super通配符上界 //        p10.set(new Apple());即便是同类型也报错//        p15.get(0);  不能获取，报错        p10.get();        p15.set(new Furit());//? extends xxx只能调用get不能调用set//? super xxx只能调用set不能调用get        /*********问：为什么有这样的限制呢*************/        /**答：         * 首先明确一点，创建的plate对象具体存储什么由左右两边共同决定，set和get方法都会受二者的影响         * 具体就是左边的&lt;&gt;限制右边的&lt;&gt;,而右边的&lt;&gt;决定最终存储的类型         *  1，plate&lt;? extends Furit&gt; p10 = new plate&lt;Apple&gt;(new Apple());确定了通配符？,该plate能存储Apple及其子类的实例         *  ~1.1，不能使用set()的原因：         *  从结构出发，左边部分plate&lt;? extends Furit&gt; p10：决定了p10只能接受Furit及其子类Apple或Banana         *  编译看左：&lt;? extends Furit&gt;         *  假设set()可以使用，编译器只能识别set(形参)中是否为“new了一个Furit及其子类的形参”         *  运行看右：&lt;Apple&gt;         *  而右边部分new plate&lt;Apple&gt;(new Apple())一开始就确定了p10只能放Apple         *  倘若可以使用set(new Banana())，由于Banana也是Furit子类，编译器无法判断错误，但运行则会出错         *  因此编译器直接取消了上边界extends中的set方法         *         *  ~1.2而对于get()方法，则没有限制，因为返回值一定是由右边new plate&lt;Apple&gt;(new Apple())所决定的Apple类型,         *      即使是依据左边来盛放返回值，Furit getback = p.get();也是一定可以的         *         * 2，plate&lt;? super Furit&gt; p12 = new plate&lt;Food&gt;(new Apple());右边的&lt;&gt;中必须填Furit或者Food         *  ~2.1不能使用get()的原因：         *  从结构出发，左边部分plate&lt;? super Furit&gt; p12：决定了p12只能接受Furit及其父类Food         *  编译看左，运行看右：         *  假设get()方法可以使用，那么get的返回值用什么接收呢？         *  Furit getback = p12.get();运行时不一定正确         *  Food getback = p12.get();运行时也不一定正确         *  只有超类Object getback = p12.get();才能一定不报错         *  因此继续假设get返回值用Object存储         *  但是这样就使用不了除Object以外的任何方法，并且本身还很容易出错         *  因此编译器直接取消了下边界super中的get方法         *  ~2.2         *  而对于set()方法，则没有限制，因为形参中只要满足右边的&lt;&gt;即可         *         *         */</code></pre><h1 id="3-0自定义结构的泛型"><a href="#3-0自定义结构的泛型" class="headerlink" title="3.0自定义结构的泛型"></a>3.0自定义结构的泛型</h1><p>（结构包括：类、接口、方法）</p><h2 id="3-1自定义类、接口的泛型"><a href="#3-1自定义类、接口的泛型" class="headerlink" title="3.1自定义类、接口的泛型"></a>3.1自定义类、接口的泛型</h2><pre><code>plate p1 = new plate(new Apple());        plate p2 = new plate(new Banana());        p1 = p2;        /*1.0因为省略了泛型，默认泛型T为Object，        该plate盘子可以装所有Object及其子类，所以p1可以转化为p2*/         plate&lt;Food&gt; p3 = new plate&lt;&gt;(new Apple());        plate&lt;Food&gt; p4 = new plate&lt;&gt;(new Banana());        p3 = p4;        p4 = p3;        /*2.0表示该盘子plate可以装Food及其子类，因此可以相互转化*/         plate&lt;Furit&gt; p5 = new plate&lt;&gt;(new Apple());        plate&lt;Furit&gt; p6 = new plate&lt;&gt;(new Banana());        p5 = p6;        p6 = p5;        /*3.0表示盘子可以装Furit及其子类，因此也能相互转化*/         plate&lt;Apple&gt; p7 = new plate&lt;&gt;(new Apple());        /*4.0表示p7盘子只能装Apple及其子类，只有Apple及其子类的盘子可以相互转化*///        plate&lt;Apple&gt; p8 = new plate&lt;&gt;(new Banana());泛型确定为Apple，所以不能赋值Banana        plate&lt;Banana&gt; p8 = new plate&lt;&gt;(new Banana());//        p7 = p8;泛型不同不能相互转化        /*4.1表示p8盘子只能装Banana及其子类，只有Banana及其子类的盘子可以相互转化*/</code></pre><h2 id="自定义方法的泛型"><a href="#自定义方法的泛型" class="headerlink" title="自定义方法的泛型"></a>自定义方法的泛型</h2><pre><code>泛型方法与所处类是否泛型无关只有在public之后跟上&lt;&gt;的才是泛型方法，使用时    public &lt;T&gt; ArrayList&lt;T&gt; arrayToList(T... arr) &#123;        //泛型方法与所处类是否泛型无关        //只有在public之后跟上&lt;&gt;的才是泛型方法，使用时如下        ArrayList&lt;T&gt; DestArr = new ArrayList&lt;&gt;();       for(T t:arr)&#123;           DestArr.add(t);       &#125;//foreach循环中每个t都代表对应的arr[i]        return DestArr;    &#125;</code></pre><h1 id="继承与泛型"><a href="#继承与泛型" class="headerlink" title="继承与泛型"></a>继承与泛型</h1><p>类A&lt;父类&gt;和 类A&lt;子类&gt;是不能相互转化的<br>        //要想实现这种转化，必须使用通配符? 利用上下边界通配符解决</p><pre><code>       plate p1 = new plate(new Apple());        plate p2 = new plate(new Banana());        p1 = p2;        /*1.0因为省略了泛型，默认泛型T为Object，        该plate盘子可以装所有Object及其子类，所以p1可以转化为p2*/         plate&lt;Food&gt; p3 = new plate&lt;&gt;(new Apple());        plate&lt;Food&gt; p4 = new plate&lt;&gt;(new Banana());        p3 = p4;        p4 = p3;        /*2.0表示该盘子plate可以装Food及其子类，因此可以相互转化*/         plate&lt;Furit&gt; p5 = new plate&lt;&gt;(new Apple());        plate&lt;Furit&gt; p6 = new plate&lt;&gt;(new Banana());        p5 = p6;        p6 = p5;        /*3.0表示盘子可以装Furit及其子类，因此也能相互转化*/         plate&lt;Apple&gt; p7 = new plate&lt;&gt;(new Apple());        /*4.0表示p7盘子只能装Apple及其子类，只有Apple及其子类的盘子可以相互转化*///        plate&lt;Apple&gt; p8 = new plate&lt;&gt;(new Banana());泛型确定为Apple，所以不能赋值Banana        plate&lt;Banana&gt; p8 = new plate&lt;&gt;(new Banana());//        p7 = p8;泛型不同不能相互转化        /*4.1表示p8盘子只能装Banana及其子类，只有Banana及其子类的盘子可以相互转化*/         /*************下面测试继承关系***********///        p3 = p5;//        p5 = p3;//        p5 = p7;//以上这种看似继承却不能转化，因为编译器不认同泛型有继承多态性        //即：类A&lt;父类&gt;和 类A&lt;子类&gt;是不能相互转化的        //要想实现这种转化，必须使用通配符? 利用上下边界通配符解决</code></pre><h1 id="实例化规律"><a href="#实例化规律" class="headerlink" title="实例化规律"></a>实例化规律</h1><pre><code>plate&lt;前面的泛型&gt; p = new plate&lt;后面的泛型&gt;(new 泛型对象);对于这样一个实例化语句，一般只有如下两种情况plate&lt;甲&gt; p = new plate&lt;甲&gt;(new 甲或甲的子类);plate&lt;甲&gt; p = new plate&lt;  &gt;(new 甲或甲的子类);//后面的泛型可以省略plate&lt;? extends 甲&gt; = new plate&lt;甲或甲的子类：记作乙&gt;(new 乙或乙的子类);//但如果使用了通配符？，那么后面的泛型必须先指定，不能省略</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>决策树/随机森林——用户流失预测的案例</title>
      <link href="/zjh/2022/01/01/%E5%86%B3%E7%AD%96%E6%A0%91-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E6%B5%81%E5%A4%B1%E9%A2%84%E6%B5%8B%E7%9A%84%E6%A1%88%E4%BE%8B/"/>
      <url>/zjh/2022/01/01/%E5%86%B3%E7%AD%96%E6%A0%91-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E6%B5%81%E5%A4%B1%E9%A2%84%E6%B5%8B%E7%9A%84%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><p><strong>摘要</strong>：<br><br>从决策树的定义，优缺点等宏观角度入题，逐步从数学原理过渡到代码实现，最后总结</p><p><strong>关键词</strong>:<br><br>决策树、信息熵、基尼系数、ID3、CART</p><h2 id="决策树是什么"><a href="#决策树是什么" class="headerlink" title="决策树是什么"></a>决策树是什么</h2><blockquote><p>一个根节点，若干个内部节点和叶节点<br><br> 非参数学习算法<br><br> 天然的分类器<br></p></blockquote><h2 id="决策树的目标"><a href="#决策树的目标" class="headerlink" title="决策树的目标"></a>决策树的目标</h2><p>解决<strong>分类</strong>和<strong>回归</strong>问题</p><h2 id="决策树的优点"><a href="#决策树的优点" class="headerlink" title="决策树的优点"></a>决策树的优点</h2><blockquote><ul><li>决策树易于理解和实现，人们在在学习过程中不需要使用者了解很多的背景知识，这同时是它的能够直接体现数据的特点，只要通过解释后都有能力去理解决策树所表达的意义。</li><li>对于决策树，数据的准备往往是简单或者是不必要的，而且能够同时处理数据型和常规型属性，在相对短的时间内能够对大型数据源做出可行且效果良好的结果。</li><li>准确性高: 挖掘出来的分类规则准确性高, 便于理解, 决策树可以清晰的显示哪些字段比较重要, 即可以生成可以理解的规则.</li><li>适合处理有缺失属性的样本，对缺失值不敏感</li></ul></blockquote><h2 id="决策树的缺点"><a href="#决策树的缺点" class="headerlink" title="决策树的缺点"></a>决策树的缺点</h2><blockquote><ul><li>容易发生过拟合（剪枝 随机森林）</li><li>分类过程中每一步都依据单一特征，忽视了特征之间的关联性，在处理特征关联性强的数据时表现不好</li><li>对于样本不均衡的数据集表现不好，欠拟合。在特征选择时ID3算法偏好于选取可取值数目较多的属性,C4.5算法偏向选取可取值数目较少的属性（实际中是在算法中采用启发式原则，先从候选属性中选出信息增益高于平均水平的属性，再从中选择增益率最高的属性）</li></ul></blockquote><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>根据<strong>信息熵</strong>(entropy) or <strong>基尼系数</strong>(gini)的大小决定下一个节点怎么分枝，最后生成决策树，而<strong>随机森林</strong>就是多个决策树的组合</p><h2 id="信息熵entropy"><a href="#信息熵entropy" class="headerlink" title="信息熵entropy"></a>信息熵entropy</h2><p><a href="https://www.zhihu.com/search?q=yjango%E4%BF%A1%E6%81%AF%E7%86%B5&utm_content=search_suggestion&type=content">超链接：Yjango:什么是信息熵？</a></p><p><em>熵在信息论中代表随机变量的不确定性的度量</em></p><p>熵越小，数据不确定性越低<br>熵越大，数据不确定性越高</p><p>信息熵<br>H=$-\displaystyle \sum^{k}_{i = 1}{Pi}$${log_2{(Pi)}}$</p><h2 id="基尼系数"><a href="#基尼系数" class="headerlink" title="基尼系数"></a>基尼系数</h2><ul><li>基尼值<br>G = 1 $-\displaystyle \sum^{k}_{i = 1}{Pi^2}$</li></ul><p>以基尼指数为指标时，应该选择Gini指数最<strong>小</strong>的</p><p>CART决策树使用“基尼指数”来选择划分属性</p><ul><li>  基尼指数<br>G_index = $-\displaystyle \sum^{V}_{v = 1}{\frac{|D^v|}{|D|}Gini(D^v)}$</li></ul><p><strong>基尼指数到0时，即到叶节点，不能再往下划分</strong></p><h2 id="AUC-ROC-tpr-fpr"><a href="#AUC-ROC-tpr-fpr" class="headerlink" title="AUC ROC tpr fpr"></a>AUC ROC tpr fpr</h2><ul><li>tpr：Recall，召回率，即当前被分到正样本类别中，真实的正样本占所有正样本的比例，即召回率（召回了多少正样本比例）</li><li>fpr：Precision，正例率，即当前划分到正样本类别中，被正确分类的比例（即正式正样本所占比例），就是我们一般理解意义上所关心的正样本的分类准确率；</li><li>ROC：tpr和fpr决定的曲线</li><li>AUC：ROC曲线下包围的面积，最大值为1，越大拟合性能越好</li></ul><h2 id="过拟合的原因及如何防止"><a href="#过拟合的原因及如何防止" class="headerlink" title="过拟合的原因及如何防止"></a>过拟合的原因及如何防止</h2><p>对于过拟合现象产生的原因，有以下几个方面，</p><blockquote><ul><li>第一：在决策树构建的过程中，对决策树的生长没有进行合理的限制（<strong>剪枝</strong>）；</li><li>第二：在建模过程中使用了<strong>较多的输出变量</strong>，变量较多也容易产生过拟合；</li><li>第三：样本中有一些<strong>噪声数据</strong>，噪声数据对决策树的构建的干扰很多，没有对噪声数据进行有效的剔除。</li></ul></blockquote><p>对于过拟合现象的预防措施，有以下一些方法，</p><blockquote><ul><li>第一：选择合理的参数进行<strong>剪枝</strong>，可以分为预剪枝后剪枝，我们一般用后剪枝的方法来做；</li><li>第二：<strong>K-folds交叉验证</strong>，将训练集分为K份，然后进行K次的交叉验证，每次使用K-1份作为训练样本数据集，另外的一份作为测试集合（作者说反了，应该是份作为测试集，其余k-1份作为训练集）；</li><li>第三：减少特征，计算每一个特征和相应变量的<strong>相关性</strong>，常见的为皮尔逊相关系数，将相关性较小的变量剔除，当然还有一些其他的方法来进行特征筛选，比如基于决策树的特征筛选，通过正则化的方式来进行特征选取等。</li></ul></blockquote><h2 id="预剪枝：生成决策树的过程中剪枝"><a href="#预剪枝：生成决策树的过程中剪枝" class="headerlink" title="预剪枝：生成决策树的过程中剪枝"></a>预剪枝：生成决策树的过程中剪枝</h2><pre><code>基于“贪心”本质，能剪则剪。</code></pre><p>如果某个分支的存在并没有提高准确率，or降低了准确率，则剪掉</p><blockquote><p>降低了过拟合风险；<br><br>显著减少了决策树训练时间；<br><br>但带来了欠拟合的风险</p></blockquote><h2 id="后剪枝：生成决策树之后剪枝"><a href="#后剪枝：生成决策树之后剪枝" class="headerlink" title="后剪枝：生成决策树之后剪枝"></a>后剪枝：生成决策树之后剪枝</h2><pre><code>能不剪，则不剪，剪前后若准确率相等，则保留</code></pre><blockquote><p>同样的训练模型，后剪枝的决策树保留了更多的分支<br><br>后剪枝的欠拟合风险很小<br><br>泛化性能往往优于预剪枝(分的更细，在面对陌生数据时判断更准确)<br><br>训练时间长的多(生成决策树之后需要自底向上逐一考察，计算开销大)<br></p></blockquote><pre><code>“在有噪声的情况下，剪枝操作甚至能将泛化性能提高25%”</code></pre><h2 id="连续值：可取连续值的属性"><a href="#连续值：可取连续值的属性" class="headerlink" title="连续值：可取连续值的属性"></a>连续值：可取连续值的属性</h2><p>例如：脐部{凹陷，平坦，稍凹}这种是离散值；而密度，xx含量等很多属性值都是连续的</p><p>因此在划分分支的时候，需要有一个间断点</p><p>间断点的划分方法：二分法，例如有17个排序后的点集，两两之间算中位数，一共算16次，生成16个t值，组成一个t的集合T，用T中的划分点代入Gain算法，计算Gain(D，该属性，t为划分点)，取Gain最大值，对应的t即为最终确定的划分点<br>划分完t之后，如果子分支还需用到更细的判断， 可以使用t的子集：例如：一个节点判断“密度&lt;=0.381”那么后续的子节点可以使用任何”密度&lt;0.381”范围的判断依据</p><h2 id="缺失值：某些数据的其中某个数据缺失，若全部弃用则会很浪费"><a href="#缺失值：某些数据的其中某个数据缺失，若全部弃用则会很浪费" class="headerlink" title="缺失值：某些数据的其中某个数据缺失，若全部弃用则会很浪费"></a>缺失值：某些数据的其中某个数据缺失，若全部弃用则会很浪费</h2><p>属性a缺失值处理方法：</p><p>西瓜书上p88：跳过该属性a的判断，直接判断下一节点的所有可能性，但需要加上训练集中的比例权重</p><pre><code>(离散值)：众数填充、相关性最高的列(属性b总是与属性a的取值几乎一一对应)填充(连续值)：中位数、相关性最高的列(同上)做线性回归估计</code></pre><h2 id="多变量决策树：用线性关系替代多个变量"><a href="#多变量决策树：用线性关系替代多个变量" class="headerlink" title="多变量决策树：用线性关系替代多个变量"></a>多变量决策树：用线性关系替代多个变量</h2><p>有些属性之间有一定的线性关系，例如：密度和含糖量之间存在着线性关系，那么就把密度和含糖量分别乘上各自的权重系数，用他俩组成的一个式子&lt;=t 或 &gt;=t 作为分界点来判断</p><pre><code>多变量决策树算法：贪心寻找每个属性的最优权值，线性分类器的最小二乘法</code></pre><h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>擅长于解决数据不平衡的分类</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1，导包"><a href="#1，导包" class="headerlink" title="1，导包"></a>1，导包</h3><pre><code>import pandas as pdimport numpy as np</code></pre><h3 id="2，读取、初步查看分析数据"><a href="#2，读取、初步查看分析数据" class="headerlink" title="2，读取、初步查看分析数据"></a>2，读取、初步查看分析数据</h3><pre><code>df = pd.read_csv(&#39;broadband.csv&#39;)df.rename(str.lower, axis=&#39;columns&#39;, inplace=True)#列名全换小写，方便看print(df.head())#空参则显示前5行数据# broadband 即可：0-离开(否)，1-留存(是)df.info() #输出行列信息（总体数据特征）print(df.sample()) # 随机查看一个样本数据# 查看因变量 broadband 分布情况，看是否存在不平衡from collections import Counterprint(&#39;Broadband: &#39;, Counter(df[&#39;broadband&#39;]))     #输出结果是Broadband:  Counter(&#123;0: 131, 1: 49&#125;)，数据并不平衡</code></pre><p><img src="https://img-blog.csdnimg.cn/6a2b7fea48b04223b402fb145f80d793.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="前5行信息and随机查看样本数据"></p><p><img src="https://img-blog.csdnimg.cn/30820d3df1b24efb98664f1347d2109d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_19,color_FFFFFF,t_70,g_se,x_16" alt="info输出信息"></p><h3 id="3，划分训练集-测试集"><a href="#3，划分训练集-测试集" class="headerlink" title="3，划分训练集 测试集"></a>3，划分训练集 测试集</h3><p>由于步骤2中info()发现数据集的第一列是用户ID，最后一列是判断标准Broadband，故这两列都不用做数据分析</p><pre><code>y = df[&#39;broadband&#39;] # y就是标签(结果)X = df.iloc[:, 1:-1] # 客户 id 没有用，故丢弃 cust_id；标签y也要去掉，故1：-1#左边冒号左右端为空，表示所有行数据全部都取到X中from sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4, random_state=123)#40%划分为test集，# 这里的random_state就是为了保证程序每次运行都分割一样的训练集和测试集。# 否则，同样的算法模型在不同的训练集和测试集上的效果不一样。# 因此具体取值多少无所谓，但对结果有影响</code></pre><h3 id="4，决策树建模"><a href="#4，决策树建模" class="headerlink" title="4，决策树建模"></a>4，决策树建模</h3><h4 id="网格搜索："><a href="#网格搜索：" class="headerlink" title="网格搜索："></a>网格搜索：</h4><p>因为决策树算法是非参数学习算法，需要自行调参，利用网格搜索则可以自动调参，择优选取<br><br>把自己认为好的参数都扔进去，让网格搜索自己跑</p><pre><code>import sklearn.tree as tree# 1. 直接使用交叉网格搜索来优化决策树模型，边训练边优化from sklearn.model_selection import GridSearchCV# 2. 网格搜索参数，选择最优参数,该param_grid作为评价指标用于下面的训练模型param_grid = &#123;&#39;criterion&#39;: [&#39;entropy&#39;, &#39;gini&#39;], # 树的深度评估指标,信息熵or基尼            &#39;max_depth&#39;: [2, 3, 4, 5, 6, 7, 8], # 可选树的深度            &#39;min_samples_split&#39;: [4, 8, 12, 16, 20, 24, 28]&#125; # 可选最小拆分的叶子样本数</code></pre><h4 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h4><pre><code># 3. 定义一棵树对象clf = tree.DecisionTreeClassifier()  # 4. 传入模型，网格搜索的参数，评估指标，cv交叉验证的次数clfcv = GridSearchCV(estimator=clf, param_grid=param_grid, scoring=&#39;roc_auc&#39;,cv=4) # roc曲线和auc面积值作为评价标准（一般都用auc直接比较面积）# cv=？表示交叉验证的次数# 5. 训练模型clfcv.fit(X_train, y_train)# 6. 使用模型来对测试集进行预测test_result = clfcv.predict(X_test)</code></pre><h4 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h4><pre><code># 7. 模型评估import sklearn.metrics as metricsprint(&quot;决策树 AUC:&quot;)fpr_test, tpr_test, th_test = metrics.roc_curve(y_test, test_result)#主要是为了得到fpr，tpr，代入AUC计算公式print(&#39;AUC = %.4f&#39; %metrics.auc(fpr_test, tpr_test))#输出AUC的值print(&quot;决策树准确度:&quot;)print(metrics.classification_report(y_test,test_result))#输出准确度表格，参考价值不是很大，一般还是以AUC为准# 9. 求网格搜索后的最优参数print(clfcv.best_params_)#输出最优参数组合，但这个最优并非完全最优，可能还需要在开始的地方再重新调参，可能#算出的最后参数结果还不同#假设“最小样本设置&#123;4，5，6，7，8&#125;”，而最优结果是4 或 8，处于边缘，#就需要往边缘调参#因为该样本结果是：#&#123;&#39;criterion&#39;: &#39;entropy&#39;, &#39;max_depth&#39;: 3, &#39;min_samples_split&#39;: 12&#125;#都不是设置的边缘只，所以可以认为这些参数还不错，暂时不调参</code></pre><p><img src="https://img-blog.csdnimg.cn/16e8639fe87447e1b9f205219401708c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="决策树AUC" title="决策树AUC"></p><h3 id="5，决策树生成"><a href="#5，决策树生成" class="headerlink" title="5，决策树生成"></a>5，决策树生成</h3><h4 id="选择最优参数重新训练"><a href="#选择最优参数重新训练" class="headerlink" title="选择最优参数重新训练"></a>选择最优参数重新训练</h4><pre><code># 将最优参数代入到模型中，重新训练、预测#&#123;&#39;criterion&#39;: &#39;entropy&#39;, &#39;max_depth&#39;: 3, &#39;min_samples_split&#39;: 12&#125;clf2 = tree.DecisionTreeClassifier(criterion=&#39;entropy&#39;, max_depth=3, min_samples_split=12)clf2.fit(X_train, y_train)test_res2 = clf2.predict(X_test)</code></pre><h4 id="绘制决策树，在同目录下生成pdf"><a href="#绘制决策树，在同目录下生成pdf" class="headerlink" title="绘制决策树，在同目录下生成pdf"></a>绘制决策树，在同目录下生成pdf</h4><pre><code>#  绘制图形 pip3 install graphvizimport graphvizdot_data = tree.export_graphviz(clf2, out_file=None)graph = graphviz.Source(dot_data)graph.render(&#39;决策树&#39;)#生成文件名为决策树的pdf图片</code></pre><p><img src="https://img-blog.csdnimg.cn/bac26eaf8ba04751a8308ddf86301246.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="决策树生成" title="决策树生成"></p><h2 id="随机森林-1"><a href="#随机森林-1" class="headerlink" title="随机森林"></a>随机森林</h2><p>由于上述决策树生成的AUC值还不到0.7，认为拟合效果不够好，因此尝试使用随机森林算法</p><h3 id="1-网格搜索"><a href="#1-网格搜索" class="headerlink" title="1,网格搜索"></a>1,网格搜索</h3><pre><code>param_grid = &#123;    &#39;criterion&#39;:[&#39;entropy&#39;,&#39;gini&#39;],# 衡量标准    &#39;max_depth&#39;:[5, 6, 7, 8],    # 每棵决策树的深度    &#39;n_estimators&#39;:[11,13,15],  # 决策树个数 - 随机森林特有参数    &#39;max_features&#39;:[0.3,0.4,0.5], # 每棵决策树使用的变量占比 - 随机森林特有参数    &#39;min_samples_split&#39;:[4,8,12,16]  # 叶子的最小拆分样本量&#125;</code></pre><h3 id="2-集成学习：随机森林训练"><a href="#2-集成学习：随机森林训练" class="headerlink" title="2,集成学习：随机森林训练"></a>2,集成学习：随机森林训练</h3><pre><code>import sklearn.ensemble as ensemble # ensemble learning: 集成学习rfc = ensemble.RandomForestClassifier()rfc_cv = GridSearchCV(estimator=rfc, param_grid=param_grid,                    scoring=&#39;roc_auc&#39;, cv=4)rfc_cv.fit(X_train, y_train)</code></pre><h3 id="3-使用随机森林对结果预测，并求AUC（一般都高于决策树）"><a href="#3-使用随机森林对结果预测，并求AUC（一般都高于决策树）" class="headerlink" title="3,使用随机森林对结果预测，并求AUC（一般都高于决策树）"></a>3,使用随机森林对结果预测，并求AUC（一般都高于决策树）</h3><pre><code>predict_test = rfc_cv.predict(X_test)#训练，预测结束之后，方可查看最佳参数配置print(rfc_cv.best_params_)#输出AUC和精度表格print(&#39;随机森林 AUC...&#39;)fpr_test, tpr_test, th_test = metrics.roc_curve(predict_test, y_test) # 构造 roc 曲线print(&#39;AUC = %.4f&#39; %metrics.auc(fpr_test, tpr_test))print(&#39;随机森林精确度...&#39;)print(metrics.classification_report(predict_test, y_test))</code></pre><p><img src="https://img-blog.csdnimg.cn/f0a64f28f5004c82bc2914efde97415c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="随机森林AUC结果"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>调参的思想类似于高中生物实验探究题中的 <strong>“寻找最佳浓度”</strong></p><p>衡量决策树 or 随机森林 <strong>模型好坏的标准一般用AUC的值来判断</strong></p><p><strong>非参数学习一般都用网格搜索</strong><br><br>例如在进行网格搜索时，有很多参数，哪怕最优结果表明只需要调整一个参数，调整之后其他最优结果可能也会改变（牵一发动全身）<br><em>当然，如果电脑性能足够好，可以直接放很多参数去跑，省去了大量的调参花费的精力</em></p><p><strong>网格搜索的参数范围一开始要间隔比较大才好</strong></p><p>其他参数相同时，同一个 random_state=？保证了算出来的结果相同</p><h1 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h1><h2 id="树模型的参数"><a href="#树模型的参数" class="headerlink" title="树模型的参数"></a>树模型的参数</h2><pre><code># # -  1.criterion  gini  or  entropy# # -  2.splitter  best or random 前者是在所有特征中找最好的切分点 后者是在部分特征中（数据量大的时候）# # -  3.max_features  None（所有），log2，sqrt，N  特征小于50的时候一般使用所有的# # -  4.max_depth  数据少或者特征少的时候可以不管这个值，如果模型样本量多，特征也多的情况下，可以尝试限制下# # -  5.min_samples_split  如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分如果样本量不大，不需要管这个值。如果样本量数量级非常大，则推荐增大这个值。# # -  6.min_samples_leaf  这个值限制了叶子节点最少的样本数，如果某叶子节点数目小于样本数，则会和兄弟节点一起被剪枝，如果样本量不大，不需要管这个值，大些如10W可是尝试下5# # -  7.min_weight_fraction_leaf 这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和兄弟节点一起被剪枝默认是0，就是不考虑权重问题。一般来说，如果我们有较多样本有缺失值，或者分类树样本的分布类别偏差很大，就会引入样本权重，这时我们就要注意这个值了。# # -  8.max_leaf_nodes 通过限制最大叶子节点数，可以防止过拟合，默认是&quot;None”，即不限制最大的叶子节点数。如果加了限制，算法会建立在最大叶子节点数内最优的决策树。如果特征不多，可以不考虑这个值，但是如果特征分成多的话，可以加以限制具体的值可以通过交叉验证得到。# # -  9.class_weight 指定样本各类别的的权重，主要是为了防止训练集某些类别的样本过多导致训练的决策树过于偏向这些类别。这里可以自己指定各个样本的权重如果使用“balanced”，则算法会自己计算权重，样本量少的类别所对应的样本权重会高。# # - 10.min_impurity_split 这个值限制了决策树的增长，如果某节点的不纯度(基尼系数，信息增益，均方差，绝对差)小于这个阈值则该节点不再生成子节点。即为叶子节点 。# - n_estimators:要建立树的个数</code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA常用快捷键</title>
      <link href="/zjh/2021/12/25/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/zjh/2021/12/25/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>摘自： <a href="https://blog.csdn.net/cold___play/article/details/100178346?ops_request_misc=&request_id=&biz_id=102&utm_term=idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100178346.nonecase&spm=1018.2226.3001.4187" title="来自：CSDN"> IDEA常用命令 ,侵删</a></p><h3 id="1-自动代码"><a href="#1-自动代码" class="headerlink" title="1. 自动代码"></a>1. 自动代码</h3><p>常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。<br>例如要输入for(User user : users)只需输入user.for+Tab。</p><p>再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。代码标签输入完成后，按Tab，生成代码。</p><table><thead><tr><th align="center">快捷键</th><th align="center">指令</th></tr></thead><tbody><tr><td align="center">Ctrl+Alt+O</td><td align="center">优化导入的类和包</td></tr><tr><td align="center">Alt+Insert</td><td align="center">生成代码(如get,set方法,构造函数等) 或者右键（Generate）</td></tr><tr><td align="center">Ctrl+Alt+T</td><td align="center">生成try catch 或者 Alt+enter</td></tr><tr><td align="center">CTRL+ALT+T</td><td align="center">把选中的代码放在 TRY{} IF{} ELSE{} 里</td></tr><tr><td align="center">Ctrl + O</td><td align="center">重写方法</td></tr><tr><td align="center">Ctrl + I</td><td align="center">实现方法</td></tr><tr><td align="center">Ctr+shift+U</td><td align="center">大小写转化</td></tr><tr><td align="center">ALT+回车</td><td align="center">导入包,自动修正</td></tr><tr><td align="center">ALT+/</td><td align="center">代码提示</td></tr><tr><td align="center">CTRL+J</td><td align="center">自动代码</td></tr><tr><td align="center">Ctrl+Shift+J</td><td align="center">整合两行为一行</td></tr><tr><td align="center">CTRL+空格</td><td align="center">代码提示</td></tr><tr><td align="center">CTRL+SHIFT+SPACE</td><td align="center">自动补全代码</td></tr><tr><td align="center">CTRL+ALT+L</td><td align="center">格式化代码</td></tr><tr><td align="center">CTRL+ALT+I</td><td align="center">自动缩进</td></tr><tr><td align="center">CTRL+ALT+O</td><td align="center">优化导入的类和包</td></tr><tr><td align="center">ALT+INSERT</td><td align="center">生成代码(如GET,SET方法,构造函数等)</td></tr><tr><td align="center">CTRL+E</td><td align="center">最近更改的代码</td></tr><tr><td align="center">CTRL+ALT+SPACE</td><td align="center">类名或接口名提示</td></tr><tr><td align="center">CTRL+P</td><td align="center">方法参数提示</td></tr><tr><td align="center">CTRL+Q</td><td align="center">可以看到当前方法的声明</td></tr><tr><td align="center">Shift+F6</td><td align="center">重构-重命名 (包、类、方法、变量、甚至注释等)</td></tr><tr><td align="center">Ctrl+Alt+V</td><td align="center">提取变量</td></tr></tbody></table><h3 id="2-查询快捷键"><a href="#2-查询快捷键" class="headerlink" title="2. 查询快捷键"></a>2. 查询快捷键</h3><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Ctrl＋Shift＋Backspace</td><td align="center">可以跳转到上次编辑的地</td></tr><tr><td align="center">CTRL+ALT+ left/right</td><td align="center">前后导航编辑过的地方</td></tr><tr><td align="center">ALT+7</td><td align="center">靠左窗口显示当前文件的结构</td></tr><tr><td align="center">Ctrl+F12</td><td align="center">浮动显示当前文件的结构</td></tr><tr><td align="center">ALT+F7</td><td align="center">找到你的函数或者变量或者类的所有引用到的地方</td></tr><tr><td align="center">CTRL+ALT+F7</td><td align="center">找到你的函数或者变量或者类的所有引用到的地方</td></tr><tr><td align="center">Ctrl+Shift+Alt+N</td><td align="center">查找类中的方法或变量</td></tr><tr><td align="center">双击SHIFT</td><td align="center">在项目的所有目录查找文件</td></tr><tr><td align="center">Ctrl+N</td><td align="center">查找类</td></tr><tr><td align="center">Ctrl+Shift+N</td><td align="center">查找文件</td></tr><tr><td align="center">CTRL+G</td><td align="center">定位行</td></tr><tr><td align="center">CTRL+F</td><td align="center">在当前窗口查找文本</td></tr><tr><td align="center">CTRL+SHIFT+F</td><td align="center">在指定窗口查找文本</td></tr><tr><td align="center">CTRL+R</td><td align="center">在当前窗口替换文本</td></tr><tr><td align="center">CTRL+SHIFT+R</td><td align="center">在指定窗口替换文本</td></tr><tr><td align="center">ALT+SHIFT+C</td><td align="center">查找修改的文件</td></tr><tr><td align="center">CTRL+E</td><td align="center">最近打开的文件</td></tr><tr><td align="center">F3</td><td align="center">向下查找关键字出现位置</td></tr><tr><td align="center">SHIFT+F3</td><td align="center">向上一个关键字出现位置</td></tr><tr><td align="center">选中文本，按Alt+F3</td><td align="center">高亮相同文本，F3逐个往下查找相同文本</td></tr><tr><td align="center">F4</td><td align="center">查找变量来源</td></tr><tr><td align="center">CTRL+SHIFT+O</td><td align="center">弹出显示查找内容</td></tr><tr><td align="center">Ctrl+W</td><td align="center">选中代码，连续按会有其他效果</td></tr><tr><td align="center">F2 或Shift+F2</td><td align="center">高亮错误或警告快速定位</td></tr><tr><td align="center">Ctrl+Up/Down</td><td align="center">光标跳转到第一行或最后一行下</td></tr><tr><td align="center">Ctrl+B</td><td align="center">快速打开光标处的类或方法</td></tr><tr><td align="center">CTRL+ALT+B</td><td align="center">找所有的子类</td></tr><tr><td align="center">CTRL+SHIFT+B</td><td align="center">找变量的类</td></tr><tr><td align="center">Ctrl+Shift+上下键</td><td align="center">上下移动代码</td></tr><tr><td align="center">Ctrl+Alt+ left/right</td><td align="center">返回至上次浏览的位置</td></tr><tr><td align="center">Ctrl+X</td><td align="center">删除行</td></tr><tr><td align="center">Ctrl+D</td><td align="center">复制行</td></tr><tr><td align="center">Ctrl+/ 或 Ctrl+Shift+/</td><td align="center">注释（// 或者/…/ ）</td></tr><tr><td align="center">Ctrl+H</td><td align="center">显示类结构图</td></tr><tr><td align="center">Ctrl+Q</td><td align="center">显示注释文档</td></tr><tr><td align="center">Alt+F1</td><td align="center">查找代码所在位置</td></tr><tr><td align="center">Alt+1</td><td align="center">快速打开或隐藏工程面板</td></tr><tr><td align="center">Alt+ left/right</td><td align="center">切换代码视图</td></tr><tr><td align="center">ALT+ ↑/↓</td><td align="center">在方法间快速移动定位</td></tr><tr><td align="center">CTRL+ALT+ left/right</td><td align="center">前后导航编辑过的地方</td></tr><tr><td align="center">Ctrl＋Shift＋Backspace</td><td align="center">可以跳转到上次编辑的地</td></tr><tr><td align="center">Alt+6</td><td align="center">查找TODO</td></tr></tbody></table><h3 id="3-其它快捷键"><a href="#3-其它快捷键" class="headerlink" title="3. 其它快捷键"></a>3. 其它快捷键</h3><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SHIFT+ENTER</td><td align="center">另起一行</td></tr><tr><td align="center">CTRL+Z</td><td align="center">倒退(撤销)</td></tr><tr><td align="center">CTRL+SHIFT+Z</td><td align="center">向前(取消撤销)</td></tr><tr><td align="center">CTRL+ALT+F12</td><td align="center">资源管理器打开文件夹</td></tr><tr><td align="center">ALT+F1</td><td align="center">查找文件所在目录位置</td></tr><tr><td align="center">SHIFT+ALT+INSERT</td><td align="center">竖编辑模式</td></tr><tr><td align="center">CTRL+F4</td><td align="center">关闭当前窗口</td></tr><tr><td align="center">Ctrl+Alt+V</td><td align="center">可以引入变量。例如：new String(); 自动导入变量定义</td></tr><tr><td align="center">Ctrl+~</td><td align="center">快速切换方案（界面外观、代码风格、快捷键映射等菜单）</td></tr></tbody></table><h3 id="4-svn快捷键"><a href="#4-svn快捷键" class="headerlink" title="4. svn快捷键"></a>4. svn快捷键</h3><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ctrl+k</td><td align="center">提交代码到SVN</td></tr><tr><td align="center">ctrl+t</td><td align="center">更新代码</td></tr></tbody></table><h3 id="5-调试快捷键"><a href="#5-调试快捷键" class="headerlink" title="5. 调试快捷键"></a>5. 调试快捷键</h3><p>其实常用的 就是F8 F7 F9 最值得一提的 就是Drop Frame 可以让运行过的代码从头再来</p><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">alt+F8</td><td align="center">debug时选中查看值</td></tr><tr><td align="center">Alt+Shift+F9</td><td align="center">选择 Debug</td></tr><tr><td align="center">Alt+Shift+F10</td><td align="center">选择 Run</td></tr><tr><td align="center">Ctrl+Shift+F9</td><td align="center">编译</td></tr><tr><td align="center">Ctrl+Shift+F8</td><td align="center">查看断点</td></tr><tr><td align="center">F7</td><td align="center">步入</td></tr><tr><td align="center">Shift+F7</td><td align="center">智能步入</td></tr><tr><td align="center">Alt+Shift+F7</td><td align="center">强制步入</td></tr><tr><td align="center">F8</td><td align="center">步过</td></tr><tr><td align="center">Shift+F8</td><td align="center">步出</td></tr><tr><td align="center">Alt+Shift+F8</td><td align="center">强制步过</td></tr><tr><td align="center">Alt+F9</td><td align="center">运行至光标处</td></tr><tr><td align="center">Ctrl+Alt+F9</td><td align="center">强制运行至光标处</td></tr><tr><td align="center">F9</td><td align="center">恢复程序</td></tr><tr><td align="center">Alt+F10</td><td align="center">定位到断点</td></tr></tbody></table><h3 id="6-重构"><a href="#6-重构" class="headerlink" title="6. 重构"></a>6. 重构</h3><table><thead><tr><th align="center">快捷键</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Ctrl+Alt+Shift+T</td><td align="center">弹出重构菜单</td></tr><tr><td align="center">Shift+F6</td><td align="center">重命名</td></tr><tr><td align="center">F6</td><td align="center">移动</td></tr><tr><td align="center">F5</td><td align="center">复制</td></tr><tr><td align="center">Alt+Delete</td><td align="center">安全删除</td></tr><tr><td align="center">Ctrl+Alt+N</td><td align="center">内联</td></tr></tbody></table><h1 id="十大IntelliJ-IDEA快捷键"><a href="#十大IntelliJ-IDEA快捷键" class="headerlink" title="十大IntelliJ IDEA快捷键"></a>十大IntelliJ IDEA快捷键</h1><p>Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。<br>以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。</p><h3 id="智能提示："><a href="#智能提示：" class="headerlink" title="智能提示："></a>智能提示：</h3><p>Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。<br>最后要说一点，Intellij能够智能感知Spring、Hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。</p><h3 id="重构："><a href="#重构：" class="headerlink" title="重构："></a>重构：</h3><p>Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。<br>切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。</p><h3 id="代码生成："><a href="#代码生成：" class="headerlink" title="代码生成："></a>代码生成：</h3><p>这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。<br>另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。</p><h3 id="编辑："><a href="#编辑：" class="headerlink" title="编辑："></a>编辑：</h3><p>编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+&lt;/&gt;折叠代码就不多说了。<br>关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。</p><h3 id="查找打开："><a href="#查找打开：" class="headerlink" title="查找打开："></a>查找打开：</h3><p>类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。<br>类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。<br>要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。<br>Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。</p><h3 id="其他辅助："><a href="#其他辅助：" class="headerlink" title="其他辅助："></a>其他辅助：</h3><p>以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：</p><ul><li>命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。</li><li>新建：Alt+Insert可以新建类、方法等任何东西。</li><li>格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。</li><li>切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。</li><li>单元测试：Ctrl+Alt+T创建单元测试用例。</li><li>运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。</li><li>调试：F7/F8/F9分别对应Step into，Step over，Continue。</li></ul><p>此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。</p><ul><li>Top #10切来切去：Ctrl+Tab</li><li>Top #9选你所想：Ctrl+W</li><li>Top #8代码生成：Template/Postfix +Tab</li><li>Top #7发号施令：Ctrl+Shift+A</li><li>Top #6无处藏身：Shift+Shift</li><li>Top #5自动完成：Ctrl+Shift+Enter</li><li>Top #4创造万物：Alt+Insert</li><li>Top #1智能补全：Ctrl+Shift+Space</li><li>Top #1自我修复：Alt+Enter</li><li>Top #1重构一切：Ctrl+Shift+Alt+T</li></ul><p>CTRL+ALT+ left/right 前后导航编辑过的地方。<br>Ctrl＋Shift＋Backspace可以跳转到上次编辑的地。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回形针数字矩阵Java实现</title>
      <link href="/zjh/2021/12/25/%E5%9B%9E%E5%BD%A2%E9%92%88%E6%95%B0%E5%AD%97%E7%9F%A9%E9%98%B5Java%E5%AE%9E%E7%8E%B0/"/>
      <url>/zjh/2021/12/25/%E5%9B%9E%E5%BD%A2%E9%92%88%E6%95%B0%E5%AD%97%E7%9F%A9%E9%98%B5Java%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210726004539592.png"><br>我们发现这个回形数矩阵的逻辑是：→↓←↑四个为一个循环，故考虑框架为：一个外层for里面嵌套4个内层for</p><p>每个内层for的起点终点都随着外层的变化而变化</p><p>说实话这种问题只可意会不可言传，光看源码没什么用，你得逼着自己去思考，哪怕是一个下午，一天才做出来也比你直接看源码好啊<del>使劲想想现实逻辑怎么转化为for循环逻辑，一般看到那个→↓←↑就会感觉这四个地位等价，就尝试着把这四个for放到一个外层大for里面，一点一点试出来</del></p><pre><code>import java.util.Scanner;public class Test1 &#123;    public static void main(String[] args) &#123;        Scanner scan = new Scanner(System.in);        System.out.println(&quot;输入一个数，返回回形数矩阵&quot;);        int i = scan.nextInt();        // 键盘输入一个数        int[][] arr = new int[i][i];        int m = 1;//用于赋值        /*思考循环数的逻辑顺序，→↓←↑四个为一个循环，故考虑框架为一个外层for里面套4个内层for*/        /*每一个循环的→↓←↑内层for循环，其起点和终点都不断改变，所以起点终点必须表现出来这个联系，绝不能为常数*/        for (int j = 0; j &lt; i; j++) &#123;             for (int k = j; k &lt; i - j; k++) &#123;//k=j和k&lt;i-j都在不断的改变                        arr[j][k] = m;                m++;            &#125;             for (int l = j + 1; l &lt; i - j; l++) &#123;                arr[l][i - j - 1] = m;                m++;            &#125;            for (int p = i - j - 2; p &gt; j - 1; p--) &#123;                arr[i - j - 1][p] = m;                m++;            &#125;            for (int q = i - j - 2; q &gt; j; q--) &#123;                arr[q][j] = m;                m++;            &#125;        &#125;        // 输出矩阵        for (int a = 0; a &lt; arr.length; a++) &#123;            for (int b = 0; b &lt; arr[a].length; b++) &#123;                System.out.print(arr[a][b] + &quot;\t&quot;);             &#125;            System.out.println();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java四种next用法</title>
      <link href="/zjh/2021/12/25/Java%E5%9B%9B%E7%A7%8Dnext%E7%94%A8%E6%B3%95/"/>
      <url>/zjh/2021/12/25/Java%E5%9B%9B%E7%A7%8Dnext%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在查阅了大量网上相关资料都没有一个完整的解释，并且我查的几篇高赞回答都是错误的时候，我决定用一整天的时间来精细写下这篇文章，希望对你有帮助。</p><pre><code>大多数人对hasNext的印象停留在“判断是否有下一个值”上，而该方法还是一个阻塞式的方法</code></pre><h1 id="hasNext和hasNextLine的区别"><a href="#hasNext和hasNextLine的区别" class="headerlink" title="hasNext和hasNextLine的区别"></a>hasNext和hasNextLine的区别</h1><p>二者都是用于判断“有无键盘输入”的，有则返回true，没有则阻塞！一定记住是阻塞而不是返回false，很多人都说是返回false，但你查源码会发现是不会返回false的，他会让你一直阻塞在判断阶段，二者只是在细节上有不同</p><pre><code>hasNext()方法会判断接下来是否有非空字符.如果有,则返回true，没有则阻塞。例如一直敲回车相当于一直判断为空字符，但是不会返回false，而是一直阻塞在判断阶段，直到你输入了非空字符hasNextLine() 方法会根据行匹配模式去判断接下来是否有一行(包括空行),如果有,则返回true。这个没什么特别的，只要是你敲了回车那都是true并且不会阻塞</code></pre><p>例如像这种if语句是永远不可能执行到内部方法体的</p><pre><code>if(scan.hasNext()==false)&#123;    System.out.println(&quot;hasNext和hasNextLine不会返回false&quot;);&#125;</code></pre><p> 再举一个例子加深理解：</p><pre><code>Scanner scan = new Scanner(System.in);System.out.println(scan.hasNextLine());System.out.println(scan.hasNext());</code></pre><p> 运行该代码，一直不停敲回车键，第一次回车会直接输出true，而后面一直敲都会阻塞在hasNext语句上，运行如下图</p><p><img src="https://img-blog.csdnimg.cn/20211001130739982.png"></p><p>首先，在看用法和解释之前，有以下几个点必须时刻牢记</p><blockquote><p>next方法不能录入空格，在特定情况下会把空格当作回车，nextLine方法可以识录入空格<br>hasNext和hasNextLine的返回值都是boolean类型，但只有可能返回true，不可能返回false，并且都默认以回车键为结束（hasNext可以设置为任意符号为结束键，不在本文研究范围之内）<br>hasNext、next不能直接识别裸回车，而hasNextLine和nextLine都可以直接识别裸回车。换句话讲：对于不输入符号而直接裸敲一个回车的操作，只有后两个能识别<br>hasNext、hasNextLine在返回一个boolean类型结果true的同时，会在堆空间中开辟一块专门用于存放刚刚输入的字符串，用于下次next或者nextLine：即下次next或者nextLine不需要再从键盘输入，相当于系统自动把刚刚输入的字符串再原封不动的输入了一遍。同时这个存储寿命＝调用对象的寿命<br>对于hasNext来说，每次敲击回车都相当于在堆空间中开辟一行，敲几次回车就会直接给后续next、nextLine方法赋值几次<br>hasNext是线程阻塞的，对于hasNext来说，如果一直不输入字符，反而一直敲回车的话，整个线程会卡在这个输入的地方，直到有字符输入</p></blockquote><p>在知道 hasNext的方法用于判断和存储，next的方法用于输入之后，来做如下预备工作</p><blockquote><p>因为hasNext、hasNextLine与next、nextLine有2X2种组合方式，所以我们用4段代码做4次实验就可以大体上了解他们的特性</p></blockquote><p>以下4段代码希望看客们能亲自复制粘贴了试一试，以便更深理解</p><h2 id="hasNext-和-next组合"><a href="#hasNext-和-next组合" class="headerlink" title="hasNext 和 next组合"></a>hasNext 和 next组合</h2><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNext() ) &#123;    System.out.println(&quot;第一次&quot;+scan.next());    System.out.println(&quot;第二次&quot;+scan.next());    System.out.println(&quot;第三次&quot;+scan.next());&#125;</code></pre><p>尝试输入：空格aaa空格bbb空格ccc回车<br><img src="https://img-blog.csdnimg.cn/20211001131608748.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_18,color_FFFFFF,t_70,g_se,x_16"><br>解释：<br><img src="https://img-blog.csdnimg.cn/20211001125303907.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_15,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="hasNext-和-NextLine组合"><a href="#hasNext-和-NextLine组合" class="headerlink" title="hasNext 和 NextLine组合"></a>hasNext 和 NextLine组合</h2><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNext() ) &#123;    System.out.println(&quot;第一次&quot;+scan.nextLine());    System.out.println(&quot;第二次&quot;+scan.nextLine());    System.out.println(&quot;第三次&quot;+scan.nextLine());&#125;</code></pre><p>解释：光标仍然闪烁，证明堆空间中的  aaa bbb ccc只赋值给了第一个，这也验证了nextLine可以录入空格。此时线程正在等待用户输入第二个nextLine<br>hasNextLine 和 next组合</p><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNextLine() ) &#123;    System.out.println(&quot;第一次&quot;+scan.next());    System.out.println(&quot;第二次&quot;+scan.next());    System.out.println(&quot;第三次&quot;+scan.next());&#125;</code></pre><h2 id="hasNextLine-和-nextLine组合"><a href="#hasNextLine-和-nextLine组合" class="headerlink" title="hasNextLine 和 nextLine组合"></a>hasNextLine 和 nextLine组合</h2><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNextLine() ) &#123;    System.out.println(&quot;第一次&quot;+scan.nextLine());    System.out.println(&quot;第二次&quot;+scan.nextLine());    System.out.println(&quot;第三次&quot;+scan.nextLine());&#125;</code></pre><p>发现规律了吗<br><img src="https://img-blog.csdnimg.cn/20211001132037981.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_18,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>如果直接连续敲回车，那么hasNextLine会判断为true，同时进入if语句执行，并且输入了三个空行也会输出三个空行</strong></p><p>验证hasNext、hasNextLine对输入代码的存储寿命</p><p>hasNextLine在if语句内，我们将验证语句next放在if语句之外，输入aaa bbb ccc ddd测试</p><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNextLine() ) &#123;    System.out.println(&quot;第一次&quot;+scan.next());    System.out.println(&quot;第二次&quot;+scan.next());    System.out.println(&quot;第三次&quot;+scan.next());&#125;        System.out.println(&quot;验证存储寿命是否＝scan对象寿命&quot;+scan.next());</code></pre><p> <img src="https://img-blog.csdnimg.cn/20211001132824820.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_17,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>hasNext、hasNextLine不可能返回false，只有true和阻塞两种结果</p><p>hasNext、hasNextLine会判断有无输入，并且hasNext一直敲回车而不输入字符会导致线程阻塞</p><p>hasNext、hasNextLine也有存储功能，从“开始输入”到“判断结束”的过程中的所有输入都将储存，直到之后遇到需要键盘输入的next、nextLine，这些存储的字符串和空格会自动填写给后面的next、nextLine。而空格再next和nextLine上有不同的表现</p><p>查看API还有很多同类型的不同方法，按照这个思路可以一通百通<br><img src="https://img-blog.csdnimg.cn/2021100113530823.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/20211001135328579.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RLE算法的Java实现</title>
      <link href="/zjh/2021/12/25/RLE%E7%AE%97%E6%B3%95%E7%9A%84Java%E5%AE%9E%E7%8E%B0/"/>
      <url>/zjh/2021/12/25/RLE%E7%AE%97%E6%B3%95%E7%9A%84Java%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="针对字符的RLE压缩"><a href="#针对字符的RLE压缩" class="headerlink" title="针对字符的RLE压缩"></a>针对字符的RLE压缩</h1><pre><code>1. 针对纯字符的压缩2. 不考虑两位数及以上的循环例如：用1*2#5*3#表示：11555两个1三个5，即 数*重复次数#</code></pre><p>至于为什么只考虑一位数：多位数可以用包装类Integer表示，并且实际压缩中不会单纯压缩字符，一般都是整个对象一起压缩，所以没必要两位相连的数与后面判断</p><pre><code> public static StringBuffer RLE(char...chars)&#123;//行程编码方法，形参放char型数组        //因为频繁更改字符串，所以返回值不用String        StringBuffer dest = new StringBuffer();        //注意：StringBuffer必须用new，不然不分配空间        //StringBuffer dest = null;会空指针异常        for(int i = 0 ; i&lt;chars.length-1 ; i++)&#123;//chars数组遍历——————压缩            //每次轮到chars[i],都需要用if和屁股后面紧跟的元素判断是否相等            dest.append(chars[i]);            dest.append(&#39;*&#39;);            int count = 1;//相等元素计数器            boolean bo = true;            while(bo)&#123;//while循环直到碰不到一样的元素就break                if(i&lt;chars.length-1 &amp;&amp; chars[i]==chars[i+1])&#123;//必须要避免空指针异常                    //注意：此处对i的判断必须在前，否则角标越界                    //并且要用&amp;&amp; 不能用&amp;，否则仍角标越界                    count++;                    i++;                &#125;else&#123;                    bo = false;                &#125;            &#125;            //循环结束，统计相同的个数            dest.append(count);            dest.append(&#39;#&#39;);//标识符，#之后又开始新的判断        &#125;        return dest;        &#125;//main方法中实现 String s1 = &quot;1112233334455566777778889999&quot;;        StringBuffer s2 = RLE(s1.toCharArray());        System.out.println(s2.toString());</code></pre><p>输出结果：1<em>3#2</em>2#3<em>4#4</em>2#5<em>3#6</em>2#7<em>5#8</em>3#9*4#</p><p>含义为：1出现了3次，2出现了2次……</p><h1 id="针对一维对象的RLE压缩"><a href="#针对一维对象的RLE压缩" class="headerlink" title="针对一维对象的RLE压缩"></a>针对一维对象的RLE压缩</h1><pre><code>1. 对象具有一个属性值和一个坐标值2. 不考虑独立多属性值，因为很难重复</code></pre><p> 先定义像素点：</p><pre><code>public class PixelPoint &#123;//一维像素点       private int grayScale;//灰度值    private int x;//x坐标     public PixelPoint(int grayScale,int x)&#123;        this.grayScale = grayScale;        this.x = x;    &#125;     public int getX()&#123;        return this.x;    &#125;     public int getGrayScale() &#123;        return grayScale;    &#125;&#125;</code></pre><p> 定义像素点的压缩方法：</p><pre><code>    public static LinkedHashMap&lt;PixelPoint,Integer&gt; RLE(ArrayList&lt;PixelPoint&gt; px)&#123;        //形参放入ArryaList，返回值用LinkedHashMap存储键值对，并且LinkedHashMap可以按添加顺序遍历        LinkedHashMap&lt;ZJH.HJZ.PixelPoint,Integer&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();         for(int i = 0 ; i &lt; px.size() ; )&#123;//            int j = i;            boolean bo = true;            int count = 1;//计相同个数             while(bo)&#123;                if(i&lt;px.size()-1)&#123;                    if(px.get(i).getGrayScale() == px.get(i+1).getGrayScale())&#123;                        count++;                        i++;                    &#125;else&#123;                        i++;                        bo = false;                    &#125;                    &#125; else&#123;                    bo = false;                    i++;                &#125;            &#125;                 linkedHashMap.put(px.get(j), count);            &#125;            return linkedHashMap;    &#125;</code></pre><p>载入像素点：并使用上面定义好的压缩方法，最后迭代器遍历(完整源码如下)</p><pre><code>public class RLE_complex_one &#123;//对一维像素点的RLE算法测试    public static void main(String[] args) &#123;       //此例中所有像素点x坐标连续分布，故暂不考虑排序，用ArrayList效率更高        ArrayList&lt;ZJH.HJZ.PixelPoint&gt; arrayList = new ArrayList&lt;&gt;(20);//初始容量设为20(默认是10，每次扩大1.5X)        //以下模拟像素点的连续排布及灰度值情况        arrayList.add(new PixelPoint(1,1));        arrayList.add(new PixelPoint(1,2));        arrayList.add(new PixelPoint(1,3));        arrayList.add(new PixelPoint(1,4));        arrayList.add(new PixelPoint(1,5));        arrayList.add(new PixelPoint(50,6));        arrayList.add(new PixelPoint(50,7));        arrayList.add(new PixelPoint(50,8));        arrayList.add(new PixelPoint(50,9));        arrayList.add(new PixelPoint(255,10));        arrayList.add(new PixelPoint(255,11));        arrayList.add(new PixelPoint(255,12));        arrayList.add(new PixelPoint(255,13));        arrayList.add(new PixelPoint(255,14));        arrayList.add(new PixelPoint(255,15));        arrayList.add(new PixelPoint(255,16));        arrayList.add(new PixelPoint(255,17));        arrayList.add(new PixelPoint(255,18));           LinkedHashMap&lt;ZJH.HJZ.PixelPoint, Integer&gt; rleDest = RLE(arrayList);//返回编码结果        //以下用迭代器遍历        Set&lt;Map.Entry&lt;PixelPoint, Integer&gt;&gt; entries = rleDest.entrySet();        Iterator&lt;Map.Entry&lt;PixelPoint, Integer&gt;&gt; iterator = entries.iterator();            int i = 1;        while(iterator.hasNext())&#123;            Map.Entry&lt;PixelPoint, Integer&gt; nextentries = iterator.next();            System.out.println(&quot;第&quot;+i+&quot;位压缩后的元素的灰度值是：&quot;+nextentries.getKey().getGrayScale()+&quot;，且压缩了&quot;+nextentries.getValue()+&quot;个连续的像素点&quot;);            i++;        &#125;      &#125;     public static LinkedHashMap&lt;PixelPoint,Integer&gt; RLE(ArrayList&lt;PixelPoint&gt; px)&#123;        //形参放入ArryaList，返回值用LinkedHashMap存储键值对，并且LinkedHashMap可以按添加顺序遍历        LinkedHashMap&lt;ZJH.HJZ.PixelPoint,Integer&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();         for(int i = 0 ; i &lt; px.size() ; )&#123;//            int j = i;            boolean bo = true;            int count = 1;//计相同个数             while(bo)&#123;                if(i&lt;px.size()-1)&#123;                    if(px.get(i).getGrayScale() == px.get(i+1).getGrayScale())&#123;                        count++;                        i++;                    &#125;else&#123;                        i++;                        bo = false;                    &#125;                    &#125; else&#123;                    bo = false;                    i++;                &#125;            &#125;                 linkedHashMap.put(px.get(j), count);            &#125;            return linkedHashMap;    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/a131150dbf364cc0ada38ae815633039.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown常用语法</title>
      <link href="/zjh/2021/12/24/MarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/zjh/2021/12/24/MarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h1><p>一共支持6级标题，例如二级标题用“## 标题2”</p><h2 id="标题2示例"><a href="#标题2示例" class="headerlink" title="标题2示例"></a>标题2示例</h2><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p><strong>加粗</strong>：左右各2*</p><p><em>斜体</em>：左右各1*</p><p><em><strong>加粗斜体</strong></em>：左右各3*</p><p><del>删除横杠</del>：左右各2~</p><h1 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h1><p>&lt;br/&gt;<br>中间加上这个br<br/>就能换行了</p><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>\xxxx就能让命令原样显示</p><h1 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h1><pre><code>按tab   引用块和引用冲突，不可分层</code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>可以嵌套使用,原理同标题，&gt;表示第一层，&gt;&gt;表示内2层，&gt;后接空格</p><blockquote><p>第一层</p><blockquote><p>第二层</p><blockquote><p>第三层内容</p></blockquote></blockquote></blockquote><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><hr><p>3个或3个以上的<em>或者-，*<em>效果相同</em></em></p><hr><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p><a href="https://www.jianshu.com/p/ea1eb11db63f" title="图床">图床的应用</a></p><blockquote><p>格式<br/><br>![图片alt](图片地址 ‘’图片title’’)</p></blockquote><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</p><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>[超链接名]（超链接地址 “超链接title”）</p><p>title可加可不加</p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>表头|表头|表头</p><p>—|:–:|—:</p><p>内容|内容|内容</p><p>内容|内容|内容</p><table><thead><tr><th>表头111</th><th align="center">表头222</th><th align="right">表头333</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>默认居左</td><td align="center">设置居中</td><td align="right">设置居右</td></tr></tbody></table><p>第二行分割表头和内容。<br><br><strong>- 有一个就行，为了对齐，多加了几个</strong></p><blockquote><dl><dt>文字默认居左<br/><br>: 两边加：表示文字居中<br/></dt><dd>右边加：表示文字居右<br/><br>注：原生的语法两边都要用 | 包起来。此处省略</dd></dl></blockquote><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表用"><a href="#无序列表用" class="headerlink" title="无序列表用-+*"></a>无序列表用-+*</h2><p>- 举例1<br/>+ 举例2<br/>* 举例3<br/></p><ul><li>举例1</li></ul><ul><li>举例2</li></ul><ul><li>举例3<h2 id="有序列表用1-2-3"><a href="#有序列表用1-2-3" class="headerlink" title="有序列表用1. 2. 3."></a>有序列表用1. 2. 3.</h2></li></ul><ol><li>举例1</li><li>举例2</li></ol><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>反引号`是~号的半角模式</p><h2 id="单行代码-xxxx"><a href="#单行代码-xxxx" class="headerlink" title="单行代码`xxxx`"></a>单行代码`xxxx`</h2><p><code>System.out.println(&quot;Hello&quot;);</code><br><code>System.out.println(&quot;World&quot;);</code></p><h2 id="多行代码-39-‘’xxx-xxx’’’"><a href="#多行代码-39-‘’xxx-xxx’’’" class="headerlink" title="多行代码&#39;‘’xxx xxx’’’"></a>多行代码&#39;‘’xxx xxx’’’</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(iterators.hasNextLine)&#123;</span><br><span class="line">    iterators.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><pre><code class="flow">st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;```</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
