<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>回形针数字矩阵Java实现</title>
      <link href="/zjh/2021/12/25/%E5%9B%9E%E5%BD%A2%E9%92%88%E6%95%B0%E5%AD%97%E7%9F%A9%E9%98%B5Java%E5%AE%9E%E7%8E%B0/"/>
      <url>/zjh/2021/12/25/%E5%9B%9E%E5%BD%A2%E9%92%88%E6%95%B0%E5%AD%97%E7%9F%A9%E9%98%B5Java%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20210726004539592.png"><br>我们发现这个回形数矩阵的逻辑是：→↓←↑四个为一个循环，故考虑框架为：一个外层for里面嵌套4个内层for</p><p>每个内层for的起点终点都随着外层的变化而变化</p><p>说实话这种问题只可意会不可言传，光看源码没什么用，你得逼着自己去思考，哪怕是一个下午，一天才做出来也比你直接看源码好啊<del>使劲想想现实逻辑怎么转化为for循环逻辑，一般看到那个→↓←↑就会感觉这四个地位等价，就尝试着把这四个for放到一个外层大for里面，一点一点试出来</del></p><pre><code>import java.util.Scanner;public class Test1 &#123;    public static void main(String[] args) &#123;        Scanner scan = new Scanner(System.in);        System.out.println(&quot;输入一个数，返回回形数矩阵&quot;);        int i = scan.nextInt();        // 键盘输入一个数        int[][] arr = new int[i][i];        int m = 1;//用于赋值        /*思考循环数的逻辑顺序，→↓←↑四个为一个循环，故考虑框架为一个外层for里面套4个内层for*/        /*每一个循环的→↓←↑内层for循环，其起点和终点都不断改变，所以起点终点必须表现出来这个联系，绝不能为常数*/        for (int j = 0; j &lt; i; j++) &#123;             for (int k = j; k &lt; i - j; k++) &#123;//k=j和k&lt;i-j都在不断的改变                        arr[j][k] = m;                m++;            &#125;             for (int l = j + 1; l &lt; i - j; l++) &#123;                arr[l][i - j - 1] = m;                m++;            &#125;            for (int p = i - j - 2; p &gt; j - 1; p--) &#123;                arr[i - j - 1][p] = m;                m++;            &#125;            for (int q = i - j - 2; q &gt; j; q--) &#123;                arr[q][j] = m;                m++;            &#125;        &#125;        // 输出矩阵        for (int a = 0; a &lt; arr.length; a++) &#123;            for (int b = 0; b &lt; arr[a].length; b++) &#123;                System.out.print(arr[a][b] + &quot;\t&quot;);             &#125;            System.out.println();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java四种next用法</title>
      <link href="/zjh/2021/12/25/Java%E5%9B%9B%E7%A7%8Dnext%E7%94%A8%E6%B3%95/"/>
      <url>/zjh/2021/12/25/Java%E5%9B%9B%E7%A7%8Dnext%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在查阅了大量网上相关资料都没有一个完整的解释，并且我查的几篇高赞回答都是错误的时候，我决定用一整天的时间来精细写下这篇文章，希望对你有帮助。</p><pre><code>大多数人对hasNext的印象停留在“判断是否有下一个值”上，而该方法还是一个阻塞式的方法</code></pre><h1 id="hasNext和hasNextLine的区别"><a href="#hasNext和hasNextLine的区别" class="headerlink" title="hasNext和hasNextLine的区别"></a>hasNext和hasNextLine的区别</h1><p>二者都是用于判断“有无键盘输入”的，有则返回true，没有则阻塞！一定记住是阻塞而不是返回false，很多人都说是返回false，但你查源码会发现是不会返回false的，他会让你一直阻塞在判断阶段，二者只是在细节上有不同</p><pre><code>hasNext()方法会判断接下来是否有非空字符.如果有,则返回true，没有则阻塞。例如一直敲回车相当于一直判断为空字符，但是不会返回false，而是一直阻塞在判断阶段，直到你输入了非空字符hasNextLine() 方法会根据行匹配模式去判断接下来是否有一行(包括空行),如果有,则返回true。这个没什么特别的，只要是你敲了回车那都是true并且不会阻塞</code></pre><p>例如像这种if语句是永远不可能执行到内部方法体的</p><pre><code>if(scan.hasNext()==false)&#123;    System.out.println(&quot;hasNext和hasNextLine不会返回false&quot;);&#125;</code></pre><p> 再举一个例子加深理解：</p><pre><code>Scanner scan = new Scanner(System.in);System.out.println(scan.hasNextLine());System.out.println(scan.hasNext());</code></pre><p> 运行该代码，一直不停敲回车键，第一次回车会直接输出true，而后面一直敲都会阻塞在hasNext语句上，运行如下图</p><p><img src="https://img-blog.csdnimg.cn/20211001130739982.png"></p><p>首先，在看用法和解释之前，有以下几个点必须时刻牢记</p><pre><code>    next方法不能录入空格，在特定情况下会把空格当作回车，nextLine方法可以识录入空格    hasNext和hasNextLine的返回值都是boolean类型，但只有可能返回true，不可能返回false，并且都默认以回车键为结束（hasNext可以设置为任意符号为结束键，不在本文研究范围之内）    hasNext、next不能直接识别裸回车，而hasNextLine和nextLine都可以直接识别裸回车。换句话讲：对于不输入符号而直接裸敲一个回车的操作，只有后两个能识别    hasNext、hasNextLine在返回一个boolean类型结果true的同时，会在堆空间中开辟一块专门用于存放刚刚输入的字符串，用于下次next或者nextLine：即下次next或者nextLine不需要再从键盘输入，相当于系统自动把刚刚输入的字符串再原封不动的输入了一遍。同时这个存储寿命＝调用对象的寿命    对于hasNext来说，每次敲击回车都相当于在堆空间中开辟一行，敲几次回车就会直接给后续next、nextLine方法赋值几次    hasNext是线程阻塞的，对于hasNext来说，如果一直不输入字符，反而一直敲回车的话，整个线程会卡在这个输入的地方，直到有字符输入</code></pre><p>在知道 hasNext的方法用于判断和存储，next的方法用于输入之后，来做如下预备工作</p><pre><code>因为hasNext、hasNextLine与next、nextLine有2X2种组合方式，所以我们用4段代码做4次实验就可以大体上了解他们的特性以下4段代码希望看客们能亲自复制粘贴了试一试，以便更深理解</code></pre><h2 id="hasNext-和-next组合"><a href="#hasNext-和-next组合" class="headerlink" title="hasNext 和 next组合"></a>hasNext 和 next组合</h2><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNext() ) &#123;    System.out.println(&quot;第一次&quot;+scan.next());    System.out.println(&quot;第二次&quot;+scan.next());    System.out.println(&quot;第三次&quot;+scan.next());&#125;</code></pre><p>尝试输入：空格aaa空格bbb空格ccc回车<br><img src="https://img-blog.csdnimg.cn/20211001131608748.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_18,color_FFFFFF,t_70,g_se,x_16"><br>解释：<br><img src="https://img-blog.csdnimg.cn/20211001125303907.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_15,color_FFFFFF,t_70,g_se,x_16"></p><h2 id="hasNext-和-NextLine组合"><a href="#hasNext-和-NextLine组合" class="headerlink" title="hasNext 和 NextLine组合"></a>hasNext 和 NextLine组合</h2><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNext() ) &#123;    System.out.println(&quot;第一次&quot;+scan.nextLine());    System.out.println(&quot;第二次&quot;+scan.nextLine());    System.out.println(&quot;第三次&quot;+scan.nextLine());&#125;</code></pre><p>解释：光标仍然闪烁，证明堆空间中的  aaa bbb ccc只赋值给了第一个，这也验证了nextLine可以录入空格。此时线程正在等待用户输入第二个nextLine<br>hasNextLine 和 next组合</p><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNextLine() ) &#123;    System.out.println(&quot;第一次&quot;+scan.next());    System.out.println(&quot;第二次&quot;+scan.next());    System.out.println(&quot;第三次&quot;+scan.next());&#125;</code></pre><h2 id="hasNextLine-和-nextLine组合"><a href="#hasNextLine-和-nextLine组合" class="headerlink" title="hasNextLine 和 nextLine组合"></a>hasNextLine 和 nextLine组合</h2><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNextLine() ) &#123;    System.out.println(&quot;第一次&quot;+scan.nextLine());    System.out.println(&quot;第二次&quot;+scan.nextLine());    System.out.println(&quot;第三次&quot;+scan.nextLine());&#125;</code></pre><p>发现规律了吗<br><img src="https://img-blog.csdnimg.cn/20211001132037981.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_18,color_FFFFFF,t_70,g_se,x_16"></p><p><strong>如果直接连续敲回车，那么hasNextLine会判断为true，同时进入if语句执行，并且输入了三个空行也会输出三个空行</strong></p><p>验证hasNext、hasNextLine对输入代码的存储寿命</p><p>hasNextLine在if语句内，我们将验证语句next放在if语句之外，输入aaa bbb ccc ddd测试</p><pre><code>Scanner scan = new Scanner(System.in);System.out.println(&quot;请输入字符串，并多混入空格回车尝试不同结果&quot;);if(scan.hasNextLine() ) &#123;    System.out.println(&quot;第一次&quot;+scan.next());    System.out.println(&quot;第二次&quot;+scan.next());    System.out.println(&quot;第三次&quot;+scan.next());&#125;        System.out.println(&quot;验证存储寿命是否＝scan对象寿命&quot;+scan.next());</code></pre><p> <img src="https://img-blog.csdnimg.cn/20211001132824820.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_17,color_FFFFFF,t_70,g_se,x_16"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>hasNext、hasNextLine不可能返回false，只有true和阻塞两种结果</p><p>hasNext、hasNextLine会判断有无输入，并且hasNext一直敲回车而不输入字符会导致线程阻塞</p><p>hasNext、hasNextLine也有存储功能，从“开始输入”到“判断结束”的过程中的所有输入都将储存，直到之后遇到需要键盘输入的next、nextLine，这些存储的字符串和空格会自动填写给后面的next、nextLine。而空格再next和nextLine上有不同的表现</p><p>查看API还有很多同类型的不同方法，按照这个思路可以一通百通<br><img src="https://img-blog.csdnimg.cn/2021100113530823.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/20211001135328579.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16"></p>]]></content>
      
      
      <categories>
          
          <category> 语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RLE算法的Java实现</title>
      <link href="/zjh/2021/12/25/RLE%E7%AE%97%E6%B3%95%E7%9A%84Java%E5%AE%9E%E7%8E%B0/"/>
      <url>/zjh/2021/12/25/RLE%E7%AE%97%E6%B3%95%E7%9A%84Java%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="针对字符的RLE压缩"><a href="#针对字符的RLE压缩" class="headerlink" title="针对字符的RLE压缩"></a>针对字符的RLE压缩</h1><pre><code>1. 针对纯字符的压缩2. 不考虑两位数及以上的循环例如：用1*2#5*3#表示：11555两个1三个5，即 数*重复次数#</code></pre><p>至于为什么只考虑一位数：多位数可以用包装类Integer表示，并且实际压缩中不会单纯压缩字符，一般都是整个对象一起压缩，所以没必要两位相连的数与后面判断</p><pre><code> public static StringBuffer RLE(char...chars)&#123;//行程编码方法，形参放char型数组        //因为频繁更改字符串，所以返回值不用String        StringBuffer dest = new StringBuffer();        //注意：StringBuffer必须用new，不然不分配空间        //StringBuffer dest = null;会空指针异常        for(int i = 0 ; i&lt;chars.length-1 ; i++)&#123;//chars数组遍历——————压缩            //每次轮到chars[i],都需要用if和屁股后面紧跟的元素判断是否相等            dest.append(chars[i]);            dest.append(&#39;*&#39;);            int count = 1;//相等元素计数器            boolean bo = true;            while(bo)&#123;//while循环直到碰不到一样的元素就break                if(i&lt;chars.length-1 &amp;&amp; chars[i]==chars[i+1])&#123;//必须要避免空指针异常                    //注意：此处对i的判断必须在前，否则角标越界                    //并且要用&amp;&amp; 不能用&amp;，否则仍角标越界                    count++;                    i++;                &#125;else&#123;                    bo = false;                &#125;            &#125;            //循环结束，统计相同的个数            dest.append(count);            dest.append(&#39;#&#39;);//标识符，#之后又开始新的判断        &#125;        return dest;        &#125;//main方法中实现 String s1 = &quot;1112233334455566777778889999&quot;;        StringBuffer s2 = RLE(s1.toCharArray());        System.out.println(s2.toString());</code></pre><p>输出结果：1<em>3#2</em>2#3<em>4#4</em>2#5<em>3#6</em>2#7<em>5#8</em>3#9*4#</p><p>含义为：1出现了3次，2出现了2次……</p><h1 id="针对一维对象的RLE压缩"><a href="#针对一维对象的RLE压缩" class="headerlink" title="针对一维对象的RLE压缩"></a>针对一维对象的RLE压缩</h1><pre><code>1. 对象具有一个属性值和一个坐标值2. 不考虑独立多属性值，因为很难重复</code></pre><p> 先定义像素点：</p><pre><code>public class PixelPoint &#123;//一维像素点       private int grayScale;//灰度值    private int x;//x坐标     public PixelPoint(int grayScale,int x)&#123;        this.grayScale = grayScale;        this.x = x;    &#125;     public int getX()&#123;        return this.x;    &#125;     public int getGrayScale() &#123;        return grayScale;    &#125;&#125;</code></pre><p> 定义像素点的压缩方法：</p><pre><code>    public static LinkedHashMap&lt;PixelPoint,Integer&gt; RLE(ArrayList&lt;PixelPoint&gt; px)&#123;        //形参放入ArryaList，返回值用LinkedHashMap存储键值对，并且LinkedHashMap可以按添加顺序遍历        LinkedHashMap&lt;ZJH.HJZ.PixelPoint,Integer&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();         for(int i = 0 ; i &lt; px.size() ; )&#123;//            int j = i;            boolean bo = true;            int count = 1;//计相同个数             while(bo)&#123;                if(i&lt;px.size()-1)&#123;                    if(px.get(i).getGrayScale() == px.get(i+1).getGrayScale())&#123;                        count++;                        i++;                    &#125;else&#123;                        i++;                        bo = false;                    &#125;                    &#125; else&#123;                    bo = false;                    i++;                &#125;            &#125;                 linkedHashMap.put(px.get(j), count);            &#125;            return linkedHashMap;    &#125;</code></pre><p>载入像素点：并使用上面定义好的压缩方法，最后迭代器遍历(完整源码如下)</p><pre><code>public class RLE_complex_one &#123;//对一维像素点的RLE算法测试    public static void main(String[] args) &#123;       //此例中所有像素点x坐标连续分布，故暂不考虑排序，用ArrayList效率更高        ArrayList&lt;ZJH.HJZ.PixelPoint&gt; arrayList = new ArrayList&lt;&gt;(20);//初始容量设为20(默认是10，每次扩大1.5X)        //以下模拟像素点的连续排布及灰度值情况        arrayList.add(new PixelPoint(1,1));        arrayList.add(new PixelPoint(1,2));        arrayList.add(new PixelPoint(1,3));        arrayList.add(new PixelPoint(1,4));        arrayList.add(new PixelPoint(1,5));        arrayList.add(new PixelPoint(50,6));        arrayList.add(new PixelPoint(50,7));        arrayList.add(new PixelPoint(50,8));        arrayList.add(new PixelPoint(50,9));        arrayList.add(new PixelPoint(255,10));        arrayList.add(new PixelPoint(255,11));        arrayList.add(new PixelPoint(255,12));        arrayList.add(new PixelPoint(255,13));        arrayList.add(new PixelPoint(255,14));        arrayList.add(new PixelPoint(255,15));        arrayList.add(new PixelPoint(255,16));        arrayList.add(new PixelPoint(255,17));        arrayList.add(new PixelPoint(255,18));           LinkedHashMap&lt;ZJH.HJZ.PixelPoint, Integer&gt; rleDest = RLE(arrayList);//返回编码结果        //以下用迭代器遍历        Set&lt;Map.Entry&lt;PixelPoint, Integer&gt;&gt; entries = rleDest.entrySet();        Iterator&lt;Map.Entry&lt;PixelPoint, Integer&gt;&gt; iterator = entries.iterator();            int i = 1;        while(iterator.hasNext())&#123;            Map.Entry&lt;PixelPoint, Integer&gt; nextentries = iterator.next();            System.out.println(&quot;第&quot;+i+&quot;位压缩后的元素的灰度值是：&quot;+nextentries.getKey().getGrayScale()+&quot;，且压缩了&quot;+nextentries.getValue()+&quot;个连续的像素点&quot;);            i++;        &#125;      &#125;     public static LinkedHashMap&lt;PixelPoint,Integer&gt; RLE(ArrayList&lt;PixelPoint&gt; px)&#123;        //形参放入ArryaList，返回值用LinkedHashMap存储键值对，并且LinkedHashMap可以按添加顺序遍历        LinkedHashMap&lt;ZJH.HJZ.PixelPoint,Integer&gt; linkedHashMap = new LinkedHashMap&lt;&gt;();         for(int i = 0 ; i &lt; px.size() ; )&#123;//            int j = i;            boolean bo = true;            int count = 1;//计相同个数             while(bo)&#123;                if(i&lt;px.size()-1)&#123;                    if(px.get(i).getGrayScale() == px.get(i+1).getGrayScale())&#123;                        count++;                        i++;                    &#125;else&#123;                        i++;                        bo = false;                    &#125;                    &#125; else&#123;                    bo = false;                    i++;                &#125;            &#125;                 linkedHashMap.put(px.get(j), count);            &#125;            return linkedHashMap;    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/a131150dbf364cc0ada38ae815633039.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-k57uG5Lqa,size_20,color_FFFFFF,t_70,g_se,x_16" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown常用语法</title>
      <link href="/zjh/2021/12/24/MarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/zjh/2021/12/24/MarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h1><p>一共支持6级标题，例如二级标题用“## 标题2”</p><h2 id="标题2示例"><a href="#标题2示例" class="headerlink" title="标题2示例"></a>标题2示例</h2><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p><strong>加粗</strong>：左右各2*</p><p><em>斜体</em>：左右各1*</p><p><em><strong>加粗斜体</strong></em>：左右各3*</p><p><del>删除横杠</del>：左右各2~</p><h1 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h1><p>&lt;br/&gt;<br>中间加上这个br<br/>就能换行了</p><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>\xxxx就能让命令原样显示</p><h1 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h1><pre><code>按tab   引用块和引用冲突，不可分层</code></pre><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>可以嵌套使用,原理同标题，&gt;表示第一层，&gt;&gt;表示内2层，&gt;后接空格</p><blockquote><p>第一层</p><blockquote><p>第二层</p><blockquote><p>第三层内容</p></blockquote></blockquote></blockquote><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><hr><p>3个或3个以上的<em>或者-，*<em>效果相同</em></em></p><hr><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p><a href="https://www.jianshu.com/p/ea1eb11db63f" title="图床">图床的应用</a></p><blockquote><p><br/>格式<br/><br>![图片alt](图片地址 ‘’图片title’’)</p></blockquote><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</p><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><blockquote><p><a href="%E8%B6%85%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80" title="超链接title">超链接名</a><br>title可加可不加</p></blockquote><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>表头|表头|表头</p><p>—|:–:|—:</p><p>内容|内容|内容</p><p>内容|内容|内容</p><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><p>第二行分割表头和内容。<br><strong>- 有一个就行，为了对齐，多加了几个</strong></p><p>文字默认居左<br/><br>-两边加：表示文字居中<br/><br>-右边加：表示文字居右<br/><br>注：原生的语法两边都要用 | 包起来。此处省略</p><p>第二行分割表头和内容。<br/><br>- 有一个就行，为了对齐，多加了几个<br/><br>文字默认居左<br/><br>-两边加：表示文字居中<br/><br>-右边加：表示文字居右<br/><br>注：原生的语法两边都要用 | 包起来。此处省略</p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表用"><a href="#无序列表用" class="headerlink" title="无序列表用-+*"></a>无序列表用-+*</h2><p>- 举例1<br/>+ 举例2<br/>* 举例3<br/></p><ul><li>举例1</li></ul><ul><li>举例2</li></ul><ul><li>举例3<h2 id="有序列表用1-2-3"><a href="#有序列表用1-2-3" class="headerlink" title="有序列表用1. 2. 3."></a>有序列表用1. 2. 3.</h2></li></ul><ol><li>举例1</li><li>举例2</li></ol><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>反引号`是~号的半角模式</p><h2 id="单行代码-xxxx"><a href="#单行代码-xxxx" class="headerlink" title="单行代码`xxxx`"></a>单行代码`xxxx`</h2><p><code>System.out.println(&quot;Hello&quot;);</code><br><code>System.out.println(&quot;World&quot;);</code></p><h2 id="多行代码-39-‘’xxx-xxx’’’"><a href="#多行代码-39-‘’xxx-xxx’’’" class="headerlink" title="多行代码&#39;‘’xxx xxx’’’"></a>多行代码&#39;‘’xxx xxx’’’</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(iterators.hasNextLine)&#123;</span><br><span class="line">    iterators.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><pre><code class="flow">st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;```</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
