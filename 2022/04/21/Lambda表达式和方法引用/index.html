<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Lambda表达式和方法引用 | ZJH&#39;blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="参考:12 什么是lambda表达式 lambda意为λ，表示是一个函数，而一个函数只有唯一的输入输出映射，因此引出lambda表达式的定义  Lambda是一个唯一匿名方法  一个接口，如果只有一个显式声明的抽象方法，那么它就是一个函数式接口。一般用@FunctionalInterface标注出来（也可以不标）  因为该接口有一个抽象方法，在new的时候需要@Override这个抽象方法">
<meta property="og:type" content="article">
<meta property="og:title" content="Lambda表达式和方法引用">
<meta property="og:url" content="https://blogzjh.github.io/2022/04/21/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/index.html">
<meta property="og:site_name" content="ZJH&#39;blog">
<meta property="og:description" content="参考:12 什么是lambda表达式 lambda意为λ，表示是一个函数，而一个函数只有唯一的输入输出映射，因此引出lambda表达式的定义  Lambda是一个唯一匿名方法  一个接口，如果只有一个显式声明的抽象方法，那么它就是一个函数式接口。一般用@FunctionalInterface标注出来（也可以不标）  因为该接口有一个抽象方法，在new的时候需要@Override这个抽象方法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9eb2a21974c0441b9de4e42cd32db7a2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/09cef4588f1e4cb68009d2eb80211ee3.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1fb4162e9e3743de8c6c874e83c16ec7.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9e28c69a2a504aab9f42270ab7060d65.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/25b2e7cf019843209f7785facc863f84.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b26591439cf348949f684e757c2eb215.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7c49fdd38cdc4f15bf1fcc2fb2d6a460.png">
<meta property="article:published_time" content="2022-04-21T01:50:42.000Z">
<meta property="article:modified_time" content="2022-04-21T01:50:52.238Z">
<meta property="article:author" content="ZJH&#39;blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/9eb2a21974c0441b9de4e42cd32db7a2.png">
  
    <link rel="alternate" href="/atom.xml" title="ZJH&#39;blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ZJH&#39;blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blogzjh.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Lambda表达式和方法引用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/21/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/" class="article-date">
  <time datetime="2022-04-21T01:50:42.000Z" itemprop="datePublished">2022-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Lambda表达式和方法引用
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参考:<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/ioriogami/article/details/12782141?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164946395516780255216553%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164946395516780255216553&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-12782141.142%5Ev7%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1018.2226.3001.4187">1</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kb411W75N?p=674&spm_id_from=pageDriver">2</a></p>
<h1 id="什么是lambda表达式"><a href="#什么是lambda表达式" class="headerlink" title="什么是lambda表达式"></a>什么是lambda表达式</h1><ul>
<li><p>lambda意为λ，表示是一个函数，而一个函数只有唯一的输入输出映射，因此引出lambda表达式的定义</p>
</li>
<li><p><strong>Lambda是一个<code>唯一匿名方法</code></strong></p>
</li>
<li><p>一个接口，如果<strong>只有一个显式声明的抽象方法，那么它就是一个函数式接口</strong>。一般用@FunctionalInterface标注出来（也可以不标）</p>
</li>
<li><p>因为该接口有一个抽象方法，在new的时候需要@Override这个抽象方法    </p>
</li>
</ul>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><p><img src="https://img-blog.csdnimg.cn/9eb2a21974c0441b9de4e42cd32db7a2.png"></p>
<h2 id="什么可以省略？"><a href="#什么可以省略？" class="headerlink" title="什么可以省略？"></a>什么可以省略？</h2><p><strong><code>可推断的都可省略，因此尽可能使用泛型</code></strong></p>
<p>方框中都可以省略</p>
<p><img src="https://img-blog.csdnimg.cn/09cef4588f1e4cb68009d2eb80211ee3.png" alt="方框中都可以省略">因为在调用这个方法的时候，public int add(int int ) return 都是<strong>唯一且确定且必须存在的</strong>，因此可以被唯一推断出来，所以可以省略，省略后为</p>
<p><code>(x,y) -&gt; x+y;</code><br>因为只有一行语句，所以代码块{}可省，return可省</p>
<h1 id="1-预定义的函数式接口"><a href="#1-预定义的函数式接口" class="headerlink" title="1.预定义的函数式接口"></a>1.预定义的函数式接口</h1><p>在JDK中定义了很多的函数式接口，例如BiFunction接口，就可以传入两个参数，返回一个参数，无需自定义；当然三个传参还是需要自定义的<br><img src="https://img-blog.csdnimg.cn/1fb4162e9e3743de8c6c874e83c16ec7.png"></p>
<h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><h3 id="函数型接口"><a href="#函数型接口" class="headerlink" title="函数型接口"></a>函数型接口</h3><p>1.JDK预定义了很多函数式接口以避免用户重复定义。最典型的是<code>Function</code>：</p>
<pre><code>@FunctionalInterface
public interface Function&lt;T, R&gt; &#123; 
    R apply(T t);
&#125;
</code></pre>
<p>这个接口代表一个函数，接受一个T类型的参数，并返回一个R类型的返回值。   </p>
<h3 id="消费型接口"><a href="#消费型接口" class="headerlink" title="消费型接口"></a>消费型接口</h3><p>2.另一个预定义函数式接口叫做<code>Consumer</code>，跟Function的唯一不同是它没有返回值。</p>
<pre><code>@FunctionalInterface
public interface Consumer&lt;T&gt; &#123; 
    void accept(T t);
&#125;
</code></pre>
<h3 id="供给型接口"><a href="#供给型接口" class="headerlink" title="供给型接口"></a>供给型接口</h3><p>3.<code>Supplier</code> 有一个get(）方法</p>
<pre><code>@FunctionnallInterface
public interface Supplier&lt;T&gt;&#123;
    T get();
&#125;
</code></pre>
<h3 id="断定型接口"><a href="#断定型接口" class="headerlink" title="断定型接口"></a>断定型接口</h3><p>4.还有一个<code>Predicate</code>断定，用来判断某项条件是否满足。经常用来进行筛滤操作：</p>
<pre><code>@FunctionalInterface
public interface Predicate&lt;T&gt; &#123; 
    boolean test(T t);
&#125;
</code></pre>
<h2 id="1-2函数式接口的测试"><a href="#1-2函数式接口的测试" class="headerlink" title="1.2函数式接口的测试"></a>1.2函数式接口的测试</h2><pre><code>public class LambdaTest &#123;


    public static void main(String[] args) &#123;

//1.Runnale接口测试————run()
        Runnable r = () -&gt; System.out.println(&quot;测试&quot;);
        r.run();


//2.Function接口测试————— T apply(X x)
        Function&lt;Integer, Integer&gt; fun = (age) -&gt; &#123;
            System.out.println(&quot;年龄为：&quot; + age);//年龄为：21
            return age + 1;
        &#125;;
        System.out.println(&quot;下次过生日的年龄：&quot; + fun.apply(21));//下次过生日的年龄：22

//3.Consumer接口测试————accept(T t)
        //3.1加泛型，推断s为String类型
        Consumer&lt;String&gt; con = (s) -&gt; System.out.println(s + &quot;666666&quot;);//双击关注666666
        con.accept(&quot;双击关注&quot;);
        //3.2不加泛型需要指定，默认为Object
        Consumer con2 = (s) -&gt; System.out.println(s + &quot;777777&quot;);//养猪厂子777777
        con2.accept(&quot;养猪厂子&quot;);

//4.Supplier接口测试
        //4.1不加泛型，则不推断
        Supplier sup = () -&gt; &#123;
            return new Integer(1);
        &#125;;
        //4.2加泛型，则可推断返回值为Integer
        Supplier&lt;Integer&gt; sup2 = () -&gt; 1;

//5.Predicate接口测试
        Predicate&lt;Integer&gt; pred = (i) -&gt; i &gt; 10;
        System.out.println(pred.test(11));//ture
        System.out.println(pred.test(9));//false
    &#125;
    &#125;
</code></pre>
<h1 id="2-自定义函数式接口"><a href="#2-自定义函数式接口" class="headerlink" title="2.自定义函数式接口"></a>2.自定义函数式接口</h1><p>定义函数式接口，接收多个参数</p>
<pre><code>@FunctionalInterface
public interface MyFunction&lt;X,Y,Z,T&gt; &#123;
    T fun(X x,Y y ,Z z);
&#125;
</code></pre>
<p>使用</p>
<pre><code>//6.自定义MyFunction接口
        MyFunction&lt;Integer,Integer,Integer,String&gt; myFun =
                (age,weight,higth) -&gt; &quot;年龄为：&quot; + age
                                    + &quot;体重为：&quot; + weight
                                    + &quot;身高为：&quot; + higth;

        String myInfo = myFun.fun(21, 145, 181);
        System.out.println(myInfo);//年龄为：21体重为：145身高为：181
</code></pre>
<h1 id="3-方法引用"><a href="#3-方法引用" class="headerlink" title="3.方法引用"></a>3.方法引用</h1><ul>
<li>当实现@FunctionalInterface的函数式接口使用lambda表达式时，<br>如果方法体直接调用 某个类or对象 的 静态or非静态方法，<br>且返回值和形参都高度相同or完全相同，那么就可以使用方法引用</li>
<li><code>编译看左</code>：类型的推断需要左边函数类的泛型来指定<h2 id="3-1对象-非静态方法"><a href="#3-1对象-非静态方法" class="headerlink" title="3.1对象::非静态方法"></a>3.1对象::非静态方法</h2><code>Function fun = p :: myHight;即把fun中的唯一抽象函数apply() 和 myHight()方法绑定，调用fun.apply(1)相当于调用p.myHight(1)</code></li>
</ul>
<pre><code>public class LambdaTest2 &#123;
    public static void main(String[] args) &#123;

        //0. People的非静态方法myHight()的形参 和 Function类的apply()方法的形参对应
        //                            的返回值 和                      的返回值对应

        People p = new People(21,&quot;张家豪&quot;);
        //1.用 对象p :: 非静态方法
        Function&lt;Integer,String&gt; fun = p :: myHight;
        //2.此时的fun对象中的apply()方法已经和 p对象中的myHight()方法绑定
        System.out.println(fun.apply(181));


    &#125;
&#125;



class People&#123;
    int age;
    String name;

    public  String myHight(Integer hight)&#123;
        return &quot;my hight is &quot; + hight;
    &#125;&#125;
</code></pre>
<h2 id="3-2类-静态方法"><a href="#3-2类-静态方法" class="headerlink" title="3.2类 :: 静态方法"></a>3.2类 :: 静态方法</h2><pre><code>。。。。。。。。
    //编译看左：左边需要指定泛型，才能推断出右边的参数类型
        Consumer&lt;Integer&gt; con = People::describe;
        con.accept(2);
    &#125;
&#125;


class People &#123;
    int age;
    String name;

    public static void describe2(Integer i) &#123;
        System.out.println(&quot;People类有&quot; + i + &quot;个属性参数&quot;);
        System.out.println(&quot;一个是name，一个是age&quot;);
    &#125;
</code></pre>
<h2 id="3-3类-实例方法"><a href="#3-3类-实例方法" class="headerlink" title="3.3类 :: 实例方法"></a>3.3类 :: 实例方法</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lkforce/article/details/99682885?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164947501216780264034763%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164947501216780264034763&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-99682885.142%5Ev7%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8&spm=1018.2226.3001.4187">参考</a></p>
<h1 id="4-构造器引用"><a href="#4-构造器引用" class="headerlink" title="4.构造器引用"></a>4.构造器引用</h1><p>和方法引用类似<br>构造器的形参 = 函数式接口的抽象方法</p>
<pre><code>        Function&lt;String,People&gt; fun1 = s -&gt; new People(s);
        People p1 = fun1.apply(&quot;张豪猪&quot;);
        
        Function&lt;String,People&gt; fun2 = People::new;
        People p2 = fun2.apply(&quot;豪猪张&quot;);

        BiFunction&lt;Integer,String,People&gt; bifun1 = People::new;
        People p3 = bifun1.apply(21, &quot;豪张猪&quot;);


    &#125;
&#125;

@AllConstructor
class People &#123;
    int age;
    String name;

    
</code></pre>
<h1 id="5-数组引用"><a href="#5-数组引用" class="headerlink" title="5.数组引用"></a>5.数组引用</h1><p>数组引用算是构造器引用的一种，可以引用一个数组的构造</p>
<pre><code>    Function&lt;Integer,People[]&gt; fun1 = p -&gt; new People[p];
    People[] arr1 = fun1.apply(10);//创建一个长度为10的People数组
    
    Function&lt;Integer,People[]&gt; fun2 = People[]::new;
    fun2.apply(20);

&#125;
&#125;


class People &#123;
int age;
String name;
</code></pre>
<h1 id="区别与总结"><a href="#区别与总结" class="headerlink" title="区别与总结"></a>区别与总结</h1><h2 id="1-类型推断"><a href="#1-类型推断" class="headerlink" title="1.类型推断"></a>1.类型推断</h2><h3 id="编译看左"><a href="#编译看左" class="headerlink" title="编译看左"></a>编译看左</h3><p>有一个People的静态方法 public static void describe(Integer count) {。。}<br>则必须通过<code> Consumer &lt;Integer&gt; con = People::describe;</code><br>而不能 Consumer con = People::describe;<br>因为后者不能推断出con.accept()需要什么类型的参数</p>
<h3 id="泛型顺序对应形参顺序"><a href="#泛型顺序对应形参顺序" class="headerlink" title="泛型顺序对应形参顺序"></a>泛型顺序对应形参顺序</h3><p><strong>Function&lt;x,y&gt; fun = 是如何确定谁是形参谁是返回值的呢？</strong></p>
<ul>
<li>第一个是形参，第二个是返回值</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/9e28c69a2a504aab9f42270ab7060d65.png"></p>
<p>而此时因为一一对应，Function&lt;Integer,String&gt;一定是Integer为形参，String为返回值</p>
<ul>
<li>》》》当BiFunction&lt;T, U, R&gt; bifun= 时，R是返回值类型，T和U的顺序也已经固定<img src="https://img-blog.csdnimg.cn/25b2e7cf019843209f7785facc863f84.png"></li>
</ul>
<h2 id="2-能省则省"><a href="#2-能省则省" class="headerlink" title="2.能省则省"></a>2.能省则省</h2><p>凡是能唯一确定推断的都能省略</p>
<ul>
<li><code>(s) -&gt;&#123;return 一个语句&#125; </code>可写为<code> s -&gt; 一个语句</code></li>
</ul>
<h2 id="3-代码绑定"><a href="#3-代码绑定" class="headerlink" title="3.代码绑定"></a>3.代码绑定</h2><p>例如：</p>
<ul>
<li>Function&lt;Integer,String&gt; fun = p :: myHight<strong>就是把myHight()方法绑定给了fun.apply()</strong></li>
<li>Supplier<Integer> sup = () -&gt; {…..return i } ; <strong>则是把{…..return i }代码块绑定给sup.get()</strong></li>
</ul>
<h2 id="4-方法引用和lambda的联系"><a href="#4-方法引用和lambda的联系" class="headerlink" title="4.方法引用和lambda的联系"></a>4.方法引用和lambda的联系</h2><p>方法引用本质就是lambda表达式，只是在上一个例子中<code>Supplier&lt;Integer&gt; sup = () -&gt; &#123;.....return i &#125; ;</code>里面的<code>&#123;.....return i &#125; </code>如果是被封装到了某一个特定的方法，那么可以直接使用方法引用，而不需要把代码块的内容挨个写出来</p>
<h2 id="5-构造器引用和方法引用的联系"><a href="#5-构造器引用和方法引用的联系" class="headerlink" title="5.构造器引用和方法引用的联系"></a>5.构造器引用和方法引用的联系</h2><p>构造器引用本质是方法引用，<strong>方法体就是new 一个对象，并返回</strong>，因此形如：<img src="https://img-blog.csdnimg.cn/b26591439cf348949f684e757c2eb215.png"><br>但一定要有new</p>
<h2 id="6-数组引用和构造引用的联系"><a href="#6-数组引用和构造引用的联系" class="headerlink" title="6.数组引用和构造引用的联系"></a>6.数组引用和构造引用的联系</h2><p>之前的构造引用都是new一个对象，而数组引用是new一个数组，仅此而已，形如：<img src="https://img-blog.csdnimg.cn/7c49fdd38cdc4f15bf1fcc2fb2d6a460.png" alt="创建长度为20的People[] "></p>
<h1 id="forEach的lambda表达式"><a href="#forEach的lambda表达式" class="headerlink" title="forEach的lambda表达式"></a>forEach的lambda表达式</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/shaoyangdd/article/details/78992497?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164946767416780271931413%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164946767416780271931413&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-78992497.142%5Ev7%5Epc_search_result_cache,157%5Ev4%5Econtrol&utm_term=foreach%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1018.2226.3001.4187">参考</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/04/21/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/" data-id="cl8wv0v1s000p1gtaggxaaou1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/04/21/Filter%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Filter的常见用法
        
      </div>
    </a>
  
  
    <a href="/2022/04/21/Mybatis%E4%B8%ADxml%E4%B8%AD%E8%B0%83java%E6%96%B9%E6%B3%95OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Mybatis中xml中调java方法OGNL表达式</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/">数据结构算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/26/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%81%9A%E9%BB%91%E5%90%8D%E5%8D%95%E7%9A%84%E6%96%B9%E6%A1%88/">布隆过滤做黑名单的方案</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E6%9F%90%E8%9A%81%E9%87%91%E6%9C%8D%E7%A7%8B%E6%8B%9B9-15/">某蚁金服秋招9-15</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">三种情况的层序遍历</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E5%87%A0%E9%81%93%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98-dfs-%E5%89%AA%E6%9E%9D-%E5%9B%9E%E6%BA%AF/">几道岛屿问题:dfs+剪枝+回溯</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%E6%9B%BF%E6%8D%A2%E3%80%81%E5%B7%A6%E6%97%8B%E3%80%81%E7%BC%BA%E5%A4%B1/">字符串：替换、左旋、缺失</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 ZJH&#39;blog<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>