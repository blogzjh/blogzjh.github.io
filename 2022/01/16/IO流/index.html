<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>IO流 | ZJH&#39;blog</title>
  <meta name="keywords" content="">
  <meta name="description" content="IO流 | ZJH&#39;blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="制作流程导入依赖后Maven刷新druid-spring-boot-starter&#x2F;&#x2F;版本号 spring-webmvc lombok&#x2F;&#x2F;简化pojo开发 spring-boot-starter-jdbc spring-boot-starter-web mybatis-plus-boot-starter&#x2F;&#x2F;版本号 mysql-connector-java spring-boot-starter-t">
<meta property="og:type" content="article">
<meta property="og:title" content="SSMp整合案例">
<meta property="og:url" content="https://zjhblog.gitee.io/2022/01/25/SSMp%E6%95%B4%E5%90%88%E6%A1%88%E4%BE%8B/index.html">
<meta property="og:site_name" content="ZJH&#39;blog">
<meta property="og:description" content="制作流程导入依赖后Maven刷新druid-spring-boot-starter&#x2F;&#x2F;版本号 spring-webmvc lombok&#x2F;&#x2F;简化pojo开发 spring-boot-starter-jdbc spring-boot-starter-web mybatis-plus-boot-starter&#x2F;&#x2F;版本号 mysql-connector-java spring-boot-starter-t">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d6d3653e3b46445bad8b6b829e494cc3.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d37a7852260242a39583cb59efa18078.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/77cfc73228ec444bb5c294920d1295af.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/c658e8b2b1064433b30ea7b2d8bc783b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9e34ed24b8274ee6ac6aea6e254f6bf8.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/61b93045c1c346658829dfe78e08d9e5.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9910670d03eb43c9a0c7cb914f006132.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9ecae93d1e2e41d2b8dd515f77fbbb83.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5ddd2ffe71b34dbb80f5c5485e365f5f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4ac6dfe87a5045c0bf06659f40a66619.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a18756a3a14b41babbf7d0534e4d24ec.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a5146e26282f4f918610d65b4cabc036.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/db9c7f7b1b804bb4a94090d2875f0183.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/555e6d3e32804c588b5f9e3ce91df865.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/62cebe7bed9b4217bb94bbdd5f2571bc.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9829e5ac57a7405bbf966209a12441c0.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/f6bca076957c46af8ad338f217280407.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/10da1f38f8754c5ba043ba76d3ee01f5.png">
<meta property="article:published_time" content="2022-01-25T13:06:05.000Z">
<meta property="article:modified_time" content="2022-01-25T13:07:26.121Z">
<meta property="article:author" content="ZJH">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/d6d3653e3b46445bad8b6b829e494cc3.png">


<link rel="icon" href="/img/QQ图片20211224224200.jpg">

<link href="/zjh/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/zjh/css/hl_theme/atom-dark.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/zjh/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/zjh/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="/zjh">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/zjh/"
   class="avatar_target">
    <img class="avatar"
         src="/zjh/img/QQ图片20211224224200.jpg"/>
</a>
<div class="author">
    <span>ZJH</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/BetterZJH"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="csdn"
               href="https://blog.csdn.net/m0_56079407"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-csdn"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:847829122@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=847829122&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(14)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="工具">
                        
                        工具
                        <small>(3)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="数据结构算法">
                        
                        数据结构算法
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="机器学习">
                        
                        机器学习
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Java">
                        
                        Java
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Java后端">
                        
                        Java后端
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="14">
<input type="hidden" id="yelog_site_word_count" value="26.8k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a id="top" class="全部文章 工具 "
           href="/zjh/2021/12/25/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA常用快捷键">IDEA常用快捷键</span>
            <span class="post-date" title="2021-12-25 21:55:46">2021/12/25</span>
        </a>
        
        <a  class="全部文章 Java后端 "
           href="/zjh/2022/01/25/SSMp%E6%95%B4%E5%90%88%E6%A1%88%E4%BE%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SSMp整合案例">SSMp整合案例</span>
            <span class="post-date" title="2022-01-25 21:06:05">2022/01/25</span>
        </a>
        
        <a  class="全部文章 Java后端 "
           href="/zjh/2022/01/20/Springboot%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Springboot基本结构">Springboot基本结构</span>
            <span class="post-date" title="2022-01-20 20:10:08">2022/01/20</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/zjh/2022/01/16/%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="软件:文件加密解密器">软件:文件加密解密器</span>
            <span class="post-date" title="2022-01-16 21:28:42">2022/01/16</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/zjh/2022/01/16/IO%E6%B5%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IO流">IO流</span>
            <span class="post-date" title="2022-01-16 21:26:38">2022/01/16</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/zjh/2022/01/13/File%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="File常用操作">File常用操作</span>
            <span class="post-date" title="2022-01-13 11:36:05">2022/01/13</span>
        </a>
        
        <a  class="全部文章 机器学习 "
           href="/zjh/2022/01/11/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E8%8E%B7%E6%95%91%E9%A2%84%E6%B5%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="随机森林——泰坦尼克号获救预测">随机森林——泰坦尼克号获救预测</span>
            <span class="post-date" title="2022-01-11 03:06:10">2022/01/11</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/zjh/2022/01/03/Java%E9%9B%86%E5%90%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java集合">Java集合</span>
            <span class="post-date" title="2022-01-03 10:02:27">2022/01/03</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/zjh/2022/01/02/Java%E6%B3%9B%E5%9E%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java泛型">Java泛型</span>
            <span class="post-date" title="2022-01-02 19:51:37">2022/01/02</span>
        </a>
        
        <a  class="全部文章 机器学习 "
           href="/zjh/2022/01/01/%E5%86%B3%E7%AD%96%E6%A0%91-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E6%B5%81%E5%A4%B1%E9%A2%84%E6%B5%8B%E7%9A%84%E6%A1%88%E4%BE%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="决策树/随机森林——用户流失预测的案例">决策树/随机森林——用户流失预测的案例</span>
            <span class="post-date" title="2022-01-01 00:41:40">2022/01/01</span>
        </a>
        
        <a  class="全部文章 数据结构算法 "
           href="/zjh/2021/12/25/%E5%9B%9E%E5%BD%A2%E9%92%88%E6%95%B0%E5%AD%97%E7%9F%A9%E9%98%B5Java%E5%AE%9E%E7%8E%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="回形针数字矩阵Java实现">回形针数字矩阵Java实现</span>
            <span class="post-date" title="2021-12-25 02:07:12">2021/12/25</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/zjh/2021/12/25/Java%E5%9B%9B%E7%A7%8Dnext%E7%94%A8%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java四种next用法">Java四种next用法</span>
            <span class="post-date" title="2021-12-25 01:59:30">2021/12/25</span>
        </a>
        
        <a  class="全部文章 数据结构算法 "
           href="/zjh/2021/12/25/RLE%E7%AE%97%E6%B3%95%E7%9A%84Java%E5%AE%9E%E7%8E%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RLE算法的Java实现">RLE算法的Java实现</span>
            <span class="post-date" title="2021-12-25 01:35:20">2021/12/25</span>
        </a>
        
        <a  class="全部文章 工具 "
           href="/zjh/2021/12/24/MarkDown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MarkDown常用语法">MarkDown常用语法</span>
            <span class="post-date" title="2021-12-24 23:33:22">2021/12/24</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-IO流" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">IO流</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="Java">Java</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-01-16 21:53:22'>2022-01-16 21:26</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:3.4k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E6%B5%81%E7%89%B9%E7%82%B9"><span class="toc-text">IO流特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">IO流的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%A0%B7%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-text">为什么这样分类？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%8D%95%E4%BD%8D"><span class="toc-text">1，数据单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%8C%E6%B5%81%E5%90%91"><span class="toc-text">2，流向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%8C%E8%A7%92%E8%89%B2"><span class="toc-text">3，角色</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%EF%BC%9AReader%E5%92%8CWriter%EF%BC%88%E4%BB%A5FileReader%E5%92%8CFileWriter%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-text">字符流：Reader和Writer（以FileReader和FileWriter为例）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-FileWriter"><span class="toc-text">(1)FileWriter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-FileReader"><span class="toc-text">(2)FileReader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83"><span class="toc-text">开发规范</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%EF%BC%9AInputStream%E5%92%8COutputStream"><span class="toc-text">字节流：InputStream和OutputStream</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B5%81%EF%BC%9ABufferedInputStream%E5%92%8CBufferedOutputStream"><span class="toc-text">处理流：缓冲流：BufferedInputStream和BufferedOutputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E5%A4%84%E7%90%86%E6%96%87%E6%9C%AC%E2%80%94%E2%80%94-gt-%E5%AD%97%E8%8A%82%E6%B5%81%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%E8%A7%86%E9%A2%91"><span class="toc-text">字符流处理文本——&gt;字节流处理图片视频</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%EF%BC%9A%E9%80%82%E7%94%A8%E4%BA%8E%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%EF%BC%8C%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E6%96%B9%E6%B3%95%E7%9B%B8%E5%90%8C%EF%BC%88-5%EF%BC%89"><span class="toc-text">加密算法：适用于所有文件，加密解密方法相同（^5）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95-%E5%8A%A0%E5%85%A5%E4%BA%86%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">字数统计算法:加入了转换流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86GUI"><span class="toc-text">加密解密GUI</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="IO流特点"><a href="#IO流特点" class="headerlink" title="IO流特点"></a>IO流特点</h1><p>IO流属于物理连接，需要手动显示close()，否则内存泄漏<br>File对象必须是<strong>文件路径</strong>而不能是文件目录，<strong>否则在使用流时会报错java.io.FileNotFoundException: D:\io\io1\io2 (拒绝访问。)</strong></p>
<h1 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h1><ul>
<li>按操作<strong>数据单位</strong>不同分为：字节流(8 bit)，字符流(16 bit)</li>
<li>按数据流的<strong>流向</strong>不同分为：输入流，输出流</li>
<li>按流的<strong>角色</strong>的不同分为：节点流，处理流<h2 id="为什么这样分类？"><a href="#为什么这样分类？" class="headerlink" title="为什么这样分类？"></a>为什么这样分类？</h2><h3 id="1，数据单位"><a href="#1，数据单位" class="headerlink" title="1，数据单位"></a>1，数据单位</h3></li>
<li>字节流(8bit = 255位)：适合<strong>图像视频等</strong>(.jpg .mp3 .mp4 .avi <strong>.doc</strong> .ppt….)传输，因为电脑像素点的灰度值范围是[0,255]<br></li>
<li>字符流(16bit = 2字节)：适合传输<strong>文本</strong>(<strong>.java  .c  .cpp</strong>  .txt)，Java语言规范规定，Java的char类型是UTF-16的code unit，也就是一定是16位（2字节）</li>
</ul>
<h3 id="2，流向"><a href="#2，流向" class="headerlink" title="2，流向"></a>2，流向</h3><p>输出流： 程序(内存)——&gt;存储设备<br><br>输入流：键盘，磁盘等——&gt;程序(内存)</p>
<h3 id="3，角色"><a href="#3，角色" class="headerlink" title="3，角色"></a>3，角色</h3><p>节点流：直接读写数据，最简单的一类流<br><br>处理流：以节点流对象为形参，为节点流提供更好的性能的流<br><img src="https://img-blog.csdnimg.cn/5bac5466455a45cea57bbe2d9abcf5cd.png"></p>
<ul>
<li><strong>基类（抽象类）给定了节点流的规范</strong></li>
<li>子类的命名后缀规则一致，虽然有40多个类，但都很规范<br><img src="https://img-blog.csdnimg.cn/9bb30cfd68a1451cbae8f3f5703f4d44.png"></li>
</ul>
<h1 id="字符流：Reader和Writer（以FileReader和FileWriter为例）"><a href="#字符流：Reader和Writer（以FileReader和FileWriter为例）" class="headerlink" title="字符流：Reader和Writer（以FileReader和FileWriter为例）"></a>字符流：Reader和Writer（以FileReader和FileWriter为例）</h1><h2 id="1-FileWriter"><a href="#1-FileWriter" class="headerlink" title="(1)FileWriter"></a>(1)FileWriter</h2><ul>
<li><strong>主要方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">构造器 <br>FileWriter(File路径or对象，可选项append)</td>
<td align="center">append默认为false<br>true表示write方法<strong>追加写入</strong><br>false表示write方法<strong>覆盖写入</strong></td>
</tr>
<tr>
<td align="center">write(“写入的内容”)<br>write(String或char[],offset,len)</td>
<td align="center">可以传入String或char[ ]<br>offset表示从索引offset号开始传入<br>len表示传入的长度，<strong>注意角标越界问题</strong></td>
</tr>
<tr>
<td align="center">flush(空参)</td>
<td align="center">刷新，不刷新的话，虽然写入了，但是read不到，文件打开也看不到写入</td>
</tr>
<tr>
<td align="center">close()</td>
<td align="center">显示关闭流，防止内存溢出</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>示例</strong><br>准备工作：先创建好file</p>
<pre><code>File file = new File(&quot;text.txt&quot;);//在当前project下创建一个text.txt文件
if(!file.exists())&#123;
    file.createNewFile();//防止FileNotFoundException: text.txt (系统找不到指定的文件。)
&#125;

  /***************Writer操作*******************/
      FileWriter fileWriter = new FileWriter(file,true);//流的实例化
      //append为true则多个write是追加写入
      //append为false则write是覆盖写入

      fileWriter.write(&quot;hello world\n&quot;);
      fileWriter.flush();//刷新，不刷新的话，虽然写入了，但是read不到，文件打开也看不到写入
      fileWriter.write(&quot;it&#39;s a test\n&quot;);
      fileWriter.flush();//刷新
  //该程序运行几遍就write几遍，下面read就会重复几遍
      fileWriter.close();
</code></pre>
<h2 id="2-FileReader"><a href="#2-FileReader" class="headerlink" title="(2)FileReader"></a>(2)FileReader</h2></li>
<li><p><strong>主要方法</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">构造器<br>FileReader(File对象或路径)<br>FileReader(FileDescriptor fd)</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">read(空参)</td>
<td align="center">空参<strong>迭代</strong>返回该文件的<strong>一个</strong>字符的ASCII码值data，需配合强转char输出</td>
</tr>
<tr>
<td align="center">read(char[] cbuf)</td>
<td align="center"><strong>迭代</strong>返回本次流读取的长度len，<strong>并把读取的数去填入cbuf数组中</strong></td>
</tr>
<tr>
<td align="center">read(char[] cbuf,偏移量offset,最大读取长度length)</td>
<td align="center">length为0时线程阻塞，length为<strong>装填长度</strong><br>read方法返回值<br>若某段流没有可读字符，read返回-1</td>
</tr>
</tbody></table>
<pre><code>  当FileReader流能read到字符时，返回值len=实际读取长度&gt;0
  读取不到返回-1，所以可以利用len!=-1创建循环条件
  注意区别read返回值 和 对cbuf赋值的差别
</code></pre>
<p>read()是一个迭代器，无论是read(空参)还是read(cbuf)都会导致迭代器指针移动</p>
<ul>
<li><strong>解释：什么叫“目的缓冲区”和“装填长度”？为什么read方法最好不要带offset和len参数？</strong></li>
</ul>
<p>1.char[] cbuf数组就是目的缓冲区，把cbuf传入read()的形参，则会把目标文件中cbuf.length()个连续的字符读入cbuf，然后遍历cbuf数组，故称“缓冲”<strong>目标缓冲区(cbuf数组)设置过大则内存占用大，过小则运行速度慢。</strong><br>2.而read(cbuf,offset,len)中的len就是装填长度，装填长度不影响最后read输出结果，但可能造成角标越界<br>3.len为0线程阻塞，offset会影响读取结果，所以通常不带这两个参数</p>
<ul>
<li><strong>示例</strong><pre><code>      /*************Reder操作**************/
      FileReader fileReader = new FileReader(file);//流的实例化

      char[] cbuf = new char[6];//设置“目的缓冲区”
      int len ; //定义“装填长度”

      while((len=fileReader.read(cbuf,0,6)) != -1)&#123;//最好是不带后面两个形参
      //当FileReader流能read到字符时，返回值len=实际读取长度&gt;0
  //形参解析：目的缓冲区数组，offset索引偏移量(为0时保证从cbuf[0]开始装填)，
  // len最大装填长度：len+offset之和不能超过cbuf.length()否则报错指针越界
        //输出的方式1：注意len和length区别
          for(int i = 0 ; i&lt;len ; i++)&#123;
              //必须是i&lt;len“装填长度”，而不能是i&lt;cbuf.length“缓冲区长度”
              System.out.print(cbuf[i]);
              &#125;
              &#125;
       fileReader.close();
</code></pre>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/1b010d62b70541ac8232765d39d0476a.png" alt="输出结果"></p>
<h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><p>为了防止各种报错，开发时最好满足以下规范</p>
<ul>
<li>close()防止内存溢出</li>
<li>try-catch-finally而不是简单的throws IOException </li>
<li>close()放在finally中，以便出问题时及时关闭流</li>
<li>在finally中的close()还需要<strong>if判断是否存在，并嵌套try-catch</strong></li>
<li><strong>使用IDEA的alt+insert调try-catch时，会自动在外边生成FileWriter fw = null;和FileReader fr = null;</strong></li>
</ul>
<h1 id="字节流：InputStream和OutputStream"><a href="#字节流：InputStream和OutputStream" class="headerlink" title="字节流：InputStream和OutputStream"></a>字节流：InputStream和OutputStream</h1><ul>
<li>步骤规范：创建File对象——创建流对象——操作——关闭流</li>
</ul>
<p>我们把刚刚创建的“C:\Users\Administrator\IdeaProjects\ZJHindi\text.txt”复制到“D:\io\io1\io2”下</p>
<ol>
<li>关掉QQ(热键冲突)Alt+Ctrl+T调用try-catch-finally<br><img src="https://img-blog.csdnimg.cn/ee815e5e76ae49df930872a924a786cd.png"> </li>
<li>第二步<br><img src="https://img-blog.csdnimg.cn/96fd16a8e316441ea0b1a1899c9b09bc.png"></li>
<li>第三步，两个close()分别try -catch(注意去掉throws IOException)</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/5664f138fb254c15bee917af0abf49aa.png"><br>完整代码：</p>
<pre><code>package zjh;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CopyTest &#123;
    public static void main(String[] args)&#123;

        FileReader fr = null;//从源文件读取
        FileWriter fw = null;//写入目的文件
        try &#123;
            File scrfile = new File(&quot;C:\\Users\\Administrator\\IdeaProjects\\ZJHindi\\text.txt&quot;);
            File destfile = new File(&quot;D:\\io\\io1\\io2\\desttext.txt&quot;);


            fr = new FileReader(scrfile);
            fw = new FileWriter(destfile);

            char[] cbuf = new char[5];
            int len;

            while((len=fr.read(cbuf))!=-1)&#123;
                fw.write(cbuf);
            &#125;

            fw.flush();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;

            if(fw!=null)&#123;//先判断fw非空
            try &#123;
                fw.close();//防止关闭时出错
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
            &#125;

            if(fr!=null) &#123;//判断fr非空
                try &#123;
                    fr.close();//关闭
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
        &#125;
&#125;
</code></pre>
<h1 id="处理流：缓冲流：BufferedInputStream和BufferedOutputStream"><a href="#处理流：缓冲流：BufferedInputStream和BufferedOutputStream" class="headerlink" title="处理流：缓冲流：BufferedInputStream和BufferedOutputStream"></a>处理流：缓冲流：BufferedInputStream和BufferedOutputStream</h1><ul>
<li>把节点流作为形参new缓冲流，套接在已有的节点流之外</li>
<li><strong>传统的节点流是线程阻塞的</strong>，而缓冲流则通过<strong>在内存中开辟一块缓冲区</strong>用于各节点流缓冲，缓冲满之后执行，<strong>利用空间换时间</strong></li>
<li><strong>外层处理流close()的时候，内层字节流也会关闭</strong>，因此只需对外层流finally{close()}</li>
</ul>
<p>如下是一个封装好的图片复制方法：</p>
<pre><code>    public static void BufferedStreamCopy(String srcPath,String destPath) &#123;//缓冲流字节流的复制方法
        //形参直接放入源文件路径 和 目的文件路径,文件自动复制
        BufferedInputStream bis = null;//写的时候按正常步骤写
        BufferedOutputStream bos = null;//这两句是try-catch-finally自动生成的

        try &#123;
//File对象的创建，导入路径
            File srcfile = new File(srcPath);
            File destfile = new File(destPath);

//节点流的创建，用于复制图像视频等
            FileInputStream fis = new FileInputStream(srcfile);
            FileOutputStream fos = new FileOutputStream(destfile);

//处理流（缓冲流）的创建，用于加速
            bis = new BufferedInputStream(fis);
            bos = new BufferedOutputStream(fos);

            //原本对节点流的操作照搬给处理流
            byte[] bbuf = new byte[1024];
            int len;

            while((len=bis.read(bbuf)) != -1)&#123;
                //每从bis读一次，就往bos写一次
                bos.write(bbuf);
                &#125;
            //因为有处理流自动flush，所以不用显示的flush
            //缓冲区满了之后自动会flush，默认长度1024x8
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
//关闭流，只需要关闭外层
            if(bis!=null)&#123;
                try &#123;
                    bis.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            if(bos!=null) &#123;
                try &#123;
                    bos.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            &#125;
        &#125;
</code></pre>
<p>调用一下：</p>
<pre><code>public static void main(String[] args) &#123;

BufferedStreamCopy(&quot;D:\\io\\io1\\io2\\QQ截图20220115002227.png&quot;
,&quot;D:\\io\\io2\\io3\\新建文件夹\\复制后的图.png&quot;);//目的路径也必须是文件，并且格式(.png)最好相同

&#125;
</code></pre>
<h2 id="字符流处理文本——-gt-字节流处理图片视频"><a href="#字符流处理文本——-gt-字节流处理图片视频" class="headerlink" title="字符流处理文本——&gt;字节流处理图片视频"></a>字符流处理文本——&gt;字节流处理图片视频</h2><ul>
<li> 把FileReader——&gt;FileInputStream,把FileWriter——&gt;FileOutputStream</li>
<li> 把char[] cbuf——&gt;byte[] bbuf</li>
</ul>
<p>其实<strong>字节流</strong>也可以<strong>复制</strong>（仅仅是复制）文本文件，<strong>只是中途不能控制台输出，否则中文会被切分</strong></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="加密算法：适用于所有文件，加密解密方法相同（-5）"><a href="#加密算法：适用于所有文件，加密解密方法相同（-5）" class="headerlink" title="加密算法：适用于所有文件，加密解密方法相同（^5）"></a>加密算法：适用于所有文件，加密解密方法相同（^5）</h2><pre><code>public static void MethodEncrpt(String srcpath,String destpath)&#123;//定义方法：加密，解密
    BufferedInputStream bis = null;
    BufferedOutputStream bos = null;
    try &#123;
        bis = new BufferedInputStream(new FileInputStream(new File(srcpath)));
        bos = new BufferedOutputStream(new FileOutputStream(new File(destpath)));

        int data;
        while((data= bis.read()) != -1)&#123;
            bos.write(data^5);//异或加密，加密解密方式都相同(M^n^n=M)
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;

        if (bos != null) &#123;
            try &#123;
                bos.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        if (bis != null) &#123;
            try &#123;
                bis.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
  /********************加密解密方法使用示例********************/
public static void main(String[] args) &#123;
//加密
MethodEncrpt(&quot;C:\\Users\\Administrator\\Desktop\\数据结构文档\\00_课程介绍.pdf&quot;,&quot;D:\\io\\加密\\字节流文件\\加密数据结构课程介绍.pdf&quot;);

//解码
        MethodEncrpt(&quot;D:\\io\\加密\\字节流文件\\加密数据结构课程介绍.pdf&quot;,&quot;D:\\io\\解密\\字节流文件\\解密1.pdf&quot;);


MethodEncrpt(&quot;D:\\io\\io1\\io2\\desttext.txt&quot;,&quot;D:\\io\\io1\\io3\\加密1.txt&quot;);
MethodEncrpt(&quot;D:\\io\\io1\\io3\\加密1.txt&quot;,&quot;D:\\io\\io1\\io3\\解密1.txt&quot;);
    &#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/197ea36e2f734182a9eaf220b6ea10f5.png" alt="加密后"></p>
<h2 id="字数统计算法-加入了转换流"><a href="#字数统计算法-加入了转换流" class="headerlink" title="字数统计算法:加入了转换流"></a>字数统计算法:加入了转换流</h2><p>注意：实际开发中应该用try-catch-finally，此处为了方便直接throws IOException</p>
<pre><code>public static void MethodCount(String path) throws IOException &#123;

    File file = new File(path);
    FileInputStream fis = new FileInputStream(file);
    BufferedInputStream bis = new BufferedInputStream(fis);
    InputStreamReader isr = new InputStreamReader(bis);
    HashMap&lt;Character,Integer&gt; hsm1 = new HashMap&lt;&gt;();

    int len;
    char[] cbuf = new char[1024];
    while((len=isr.read(cbuf)) != -1)&#123;//读取到cbuf
        for(int i=0 ; i&lt;len ; i++)&#123;
            if(hsm1.containsKey(cbuf[i]))&#123;
                hsm1.replace(cbuf[i],hsm1.get(cbuf[i])+1);
            &#125;
            else&#123;
                hsm1.put(cbuf[i],1);
            &#125;
        &#125;
    &#125;




    //输出遍历hsm1数组
    Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entries = hsm1.entrySet();
    Iterator&lt;Map.Entry&lt;Character, Integer&gt;&gt; iterator = entries.iterator();
    while (iterator.hasNext())&#123;
        Map.Entry&lt;Character, Integer&gt; next = iterator.next();

        Character key = next.getKey();
        Integer value = next.getValue();

        switch (key) &#123;
            case &#39; &#39;:
                System.out.println(&quot;空格：&quot;+value+&quot;次&quot;);
                break;
            case &#39;\t&#39;:
                System.out.println(&quot;tab：&quot;+value+&quot;次&quot;);
                break;
            case &#39;\r&#39;:
                System.out.println(&quot;回车：&quot;+value+&quot;次&quot;);
                break;
            case &#39;\n&#39;:
                System.out.println(&quot;换行：&quot;+value+&quot;次&quot;);
                break;
            default:
                System.out.println(key+&quot;：&quot;+value+&quot;次&quot;);
                break;
        &#125;
    &#125;
    &#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/442698d2bdb245ebab578aa34137a46c.png"></p>
<h2 id="加密解密GUI"><a href="#加密解密GUI" class="headerlink" title="加密解密GUI"></a>加密解密GUI</h2><p><img src="https://img-blog.csdnimg.cn/aa539cc7a4724a9082f1a652f1868cc8.png"><img src="https://img-blog.csdnimg.cn/b8edf3c2b2e049de9f9aea9c511d3ed1.png"></p>
<pre><code>public class EncrptDir &#123;
public static void EncrptMethod(String dirpath) throws IOException &#123;//文件目录
    File srcfile = new File(dirpath);
    File destfile = new File(&quot;D:\\加密照片\\加密照片5&quot;);//加密照片存储地址
    if(!destfile.exists())&#123;
        destfile.mkdirs();
    &#125;
    File[] files = srcfile.listFiles();//罗列所有照片的File对象

    for(int i = 0 ; i&lt;files.length ; i++)&#123;//处理每个文件
        String s = files[i].getName().split(&quot;\\.&quot;)[1];//s表示文件名后缀
        //split方法是正则表达式，所以要用\\.
        String d = &quot;加密图片&quot;+i+&quot;.&quot; + s;
        File file_jm = new File(destfile,d);
        //创建节点流
        FileInputStream fis = new FileInputStream(files[i]);//输入原图
        BufferedInputStream bis = new BufferedInputStream(fis);

        FileOutputStream fos = new FileOutputStream(file_jm);//输出加密
        BufferedOutputStream bos = new BufferedOutputStream(fos);
    //读写操作
       int data;
        while((data=bis.read())!=-1)&#123;
            bos.write(data^5);//加密操作
        &#125;

    //关闭流
        bos.close();
        bis.close();
        System.out.println(&quot;正在加密第  &quot;+i+&quot;  张图&quot;);
    &#125;
    System.out.println(&quot;加密完成，文件位于D:\\加密照片\\加密照片5&quot;);
    &#125;

public static void DecrptMethod(String dirpath) throws IOException &#123;//文件目录

    File srcfile = new File(dirpath);
    File destfile = new File(&quot;D:\\解密照片\\解密照片5&quot;);//解密照片存储地址
    if(!destfile.exists())&#123;
        destfile.mkdirs();
    &#125;
    File[] files = srcfile.listFiles();//罗列所有照片的File对象

    for(int i = 0 ; i&lt;files.length ; i++)&#123;//处理每个文件
        String s = files[i].getName().split(&quot;\\.&quot;)[1];//s表示文件名后缀
        //split方法是正则表达式，所以要用\\.
        String d = &quot;加密图片&quot;+i+&quot;.&quot; + s;
        File file_jm = new File(destfile,d);
        //创建节点流
        FileInputStream fis = new FileInputStream(files[i]);//输入原图
        BufferedInputStream bis = new BufferedInputStream(fis);

        FileOutputStream fos = new FileOutputStream(file_jm);//输出解密
        BufferedOutputStream bos = new BufferedOutputStream(fos);
        //读写操作
        int data;
        while((data=bis.read())!=-1)&#123;
            bos.write(data^5);//解密操作
        &#125;

        //关闭流
        bos.close();
        bis.close();

        System.out.println(&quot;正在解密第  &quot;+i+&quot;  张图&quot;);
    &#125;
    System.out.println(&quot;解密完成，文件位于D:\\解密照片\\解密照片5&quot;);
    &#125;&#125;



package ZJHindi;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.io.*;

public class EncrptGUI &#123;
    public static void main(String[] args) &#123;
        JFrame jf = new JFrame(&quot;文件加密工具&quot;);
        jf.setLayout(new FlowLayout(FlowLayout.LEFT));
        jf.setBounds(460,300,350,200);

        /*********逻辑部分**********/

        JLabel label1 = new JLabel(&quot;需要加密or解密的文件源路径:&quot;);
        JTextField srcfilepath = new JTextField(&quot;&quot;,30);

        JButton jButton1 = new JButton(&quot;点击加密&quot;);
        jButton1.setSize(20,30);

        JLabel jLabe2 = new JLabel(&quot;输出位置D:\\加密照片\\加密照片5&quot;);

        jf.add(label1);
        jf.add(srcfilepath);
        jf.add(jButton1);
        jf.add(jLabe2);
        JButton jButton2 = new JButton(&quot;点击解密&quot;);
        jf.add(jButton2);
        JLabel jLabe3 = new JLabel(&quot;输出位置D:\\解密照片\\解密照片5&quot;);
        jf.add(jLabe3);
        /****************************/
        jf.setVisible(true);
        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        JLabel outter = new JLabel(&quot;执行信息：&quot;);
        jf.add(outter);
        JTextArea jta = new JTextArea();
        jf.add(jta);

/****************************加密*********************/
        jButton1.addActionListener(new AbstractAction() &#123;
            @Override
            public void actionPerformed(ActionEvent e) &#123;
                String path = srcfilepath.getText();//获取输入的路径
                try &#123;
                    EncrptDir.EncrptMethod(path);
                &#125; catch (IOException e1) &#123;
                    e1.printStackTrace();
                &#125;
jta.append(&quot;加密完成\n&quot;);

            &#125;
            &#125;);
/******************解密*****************/
        jButton2.addActionListener(new AbstractAction() &#123;
            @Override
            public void actionPerformed(ActionEvent e) &#123;
                String path = srcfilepath.getText();//获取输入的路径
                try &#123;
                    EncrptDir.DecrptMethod(path);
                &#125; catch (IOException e1) &#123;
                    e1.printStackTrace();
                &#125;
                jta.append(&quot;解密完成\n&quot;);
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 生命以负熵为食，归整以抵抗熵增； </span>
    </div>
</article>







    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2021 ZJH
</p>
<p class="footer-entry">"生命以负熵为食"

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/zjh/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/zjh/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
