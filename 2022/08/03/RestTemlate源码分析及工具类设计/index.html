<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>RestTemlate源码分析及工具类设计 | 张家豪的博客</title>
  <meta name="keywords" content="">
  <meta name="description" content="RestTemlate源码分析及工具类设计 | 张家豪的博客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="1.已知布隆过滤有误判概率 因为hash运算后存在“假阳性”，因此做黑名单时可能把正常用户给拦截了 做白名单时一定是准确无误的 理论上做成黑名单有误判缺陷，但做白名单毫无问题，因此黑白名单结合才能实现黑名单的功能  2.黑白名单组合解决：ip黑名单问题直接列下我的设计思路：  现在有一个布隆过滤器保存了一组ip黑名单 一个正常用户ip遇到hash碰撞，被拦截了 接口直接跳转“验证真人的接口” 验证">
<meta property="og:type" content="article">
<meta property="og:title" content="布隆过滤做黑名单的方案">
<meta property="og:url" content="https://blogzjh.github.io/2022/09/26/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%81%9A%E9%BB%91%E5%90%8D%E5%8D%95%E7%9A%84%E6%96%B9%E6%A1%88/index.html">
<meta property="og:site_name" content="张家豪的博客">
<meta property="og:description" content="1.已知布隆过滤有误判概率 因为hash运算后存在“假阳性”，因此做黑名单时可能把正常用户给拦截了 做白名单时一定是准确无误的 理论上做成黑名单有误判缺陷，但做白名单毫无问题，因此黑白名单结合才能实现黑名单的功能  2.黑白名单组合解决：ip黑名单问题直接列下我的设计思路：  现在有一个布隆过滤器保存了一组ip黑名单 一个正常用户ip遇到hash碰撞，被拦截了 接口直接跳转“验证真人的接口” 验证">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-25T18:22:57.000Z">
<meta property="article:modified_time" content="2022-09-25T18:22:44.126Z">
<meta property="article:author" content="张家豪">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/QQ图片20211224224200.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/rainbow.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/QQ图片20211224224200.jpg"/>
</a>
<div class="author">
    <span>张家豪</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/blogzjh"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="csdn"
               href="https://blog.csdn.net/m0_56079407"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-csdn"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:2225674545@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2225674545&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(52)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="数据结构算法">
                        
                        数据结构算法
                        <small>(7)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="工作笔记">
                        
                        工作笔记
                        <small>(12)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="机器学习">
                        
                        机器学习
                        <small>(7)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="源码">
                        
                        源码
                        <small>(9)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="中间件">
                        
                        中间件
                        <small>(8)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Java">
                        
                        Java
                        <small>(8)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="52">
<input type="hidden" id="yelog_site_word_count" value="103.4k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HashMap</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        <a  class="全部文章 工作笔记 "
           href="/2022/09/26/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%81%9A%E9%BB%91%E5%90%8D%E5%8D%95%E7%9A%84%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="布隆过滤做黑名单的方案">布隆过滤做黑名单的方案</span>
            <span class="post-date" title="2022-09-26 02:22:57">2022/09/26</span>
        </a>
        
        <a  class="全部文章 数据结构算法 "
           href="/2022/09/15/%E6%9F%90%E8%9A%81%E9%87%91%E6%9C%8D%E7%A7%8B%E6%8B%9B9-15/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="某蚁金服秋招9-15">某蚁金服秋招9-15</span>
            <span class="post-date" title="2022-09-15 21:22:38">2022/09/15</span>
        </a>
        
        <a  class="全部文章 数据结构算法 "
           href="/2022/09/15/%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="三种情况的层序遍历">三种情况的层序遍历</span>
            <span class="post-date" title="2022-09-15 21:21:24">2022/09/15</span>
        </a>
        
        <a  class="全部文章 数据结构算法 "
           href="/2022/09/15/%E5%87%A0%E9%81%93%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98-dfs-%E5%89%AA%E6%9E%9D-%E5%9B%9E%E6%BA%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="几道岛屿问题:dfs+剪枝+回溯">几道岛屿问题:dfs+剪枝+回溯</span>
            <span class="post-date" title="2022-09-15 21:20:58">2022/09/15</span>
        </a>
        
        <a  class="全部文章 数据结构算法 "
           href="/2022/09/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%E6%9B%BF%E6%8D%A2%E3%80%81%E5%B7%A6%E6%97%8B%E3%80%81%E7%BC%BA%E5%A4%B1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="字符串：替换、左旋、缺失">字符串：替换、左旋、缺失</span>
            <span class="post-date" title="2022-09-15 21:20:41">2022/09/15</span>
        </a>
        
        <a  class="全部文章 数据结构算法 "
           href="/2022/09/15/%E5%87%A0%E9%81%93%E4%BA%8C%E5%8F%89%E6%A0%91-dfs-%E5%9B%9E%E6%BA%AF/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="几道二叉树:dfs+回溯">几道二叉树:dfs+回溯</span>
            <span class="post-date" title="2022-09-15 21:19:53">2022/09/15</span>
        </a>
        
        <a  class="全部文章 数据结构算法 "
           href="/2022/09/15/%E5%87%A0%E9%81%93%E5%8A%A8%E5%BD%92%E6%80%BB%E7%BB%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="几道动归总结">几道动归总结</span>
            <span class="post-date" title="2022-09-15 21:18:43">2022/09/15</span>
        </a>
        
        <a  class="全部文章 源码 "
           href="/2022/09/15/BeanFactory%E5%92%8CApplicationContext/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="BeanFactory和ApplicationContext">BeanFactory和ApplicationContext</span>
            <span class="post-date" title="2022-09-15 21:17:39">2022/09/15</span>
        </a>
        
        <a  class="全部文章 中间件 "
           href="/2022/08/28/%E4%B8%89%E7%A7%8D%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%88%B7%E7%9B%98-%E6%8C%81%E4%B9%85%E5%8C%96-%E7%AD%96%E7%95%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="三种中间件的刷盘(持久化)策略">三种中间件的刷盘(持久化)策略</span>
            <span class="post-date" title="2022-08-28 13:34:20">2022/08/28</span>
        </a>
        
        <a  class="全部文章 中间件 "
           href="/2022/08/28/redis%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="redis基础">redis基础</span>
            <span class="post-date" title="2022-08-28 12:21:22">2022/08/28</span>
        </a>
        
        <a  class="全部文章 中间件 "
           href="/2022/08/27/RabbitMQ%E5%9F%BA%E7%A1%80/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ基础">RabbitMQ基础</span>
            <span class="post-date" title="2022-08-27 16:26:14">2022/08/27</span>
        </a>
        
        <a  class="全部文章 中间件 "
           href="/2022/08/27/RabbitMQ%E5%8F%AF%E9%9D%A0%E6%80%A7-Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ可靠性-Spring">RabbitMQ可靠性-Spring</span>
            <span class="post-date" title="2022-08-27 16:02:25">2022/08/27</span>
        </a>
        
        <a  class="全部文章 中间件 "
           href="/2022/08/27/RabbitMQ%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E3%80%81%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97-Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RabbitMQ死信队列、延迟队列-Spring">RabbitMQ死信队列、延迟队列-Spring</span>
            <span class="post-date" title="2022-08-27 01:05:35">2022/08/27</span>
        </a>
        
        <a  class="全部文章 中间件 "
           href="/2022/08/23/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL事务与锁">MySQL事务与锁</span>
            <span class="post-date" title="2022-08-23 12:49:38">2022/08/23</span>
        </a>
        
        <a  class="全部文章 工作笔记 "
           href="/2022/08/23/AOP%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AOP实现分布式锁">AOP实现分布式锁</span>
            <span class="post-date" title="2022-08-23 12:48:25">2022/08/23</span>
        </a>
        
        <a  class="全部文章 源码 "
           href="/2022/08/23/ReentrantLock%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ReentrantLock源码剖析">ReentrantLock源码剖析</span>
            <span class="post-date" title="2022-08-23 12:34:15">2022/08/23</span>
        </a>
        
        <a  class="全部文章 源码 "
           href="/2022/08/23/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96AQS%E4%B8%AD%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E4%B8%8E%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="反射获取AQS中同步队列与等待队列的长度">反射获取AQS中同步队列与等待队列的长度</span>
            <span class="post-date" title="2022-08-23 12:32:58">2022/08/23</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2022/08/14/Spring%E3%80%81Servlet%E7%9B%91%E5%90%AC%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring、Servlet监听器">Spring、Servlet监听器</span>
            <span class="post-date" title="2022-08-14 21:01:46">2022/08/14</span>
        </a>
        
        <a  class="全部文章 工作笔记 "
           href="/2022/08/13/AOP-%E5%8F%8D%E5%B0%84%EF%BC%9A%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AOP+反射：接口参数校验">AOP+反射：接口参数校验</span>
            <span class="post-date" title="2022-08-13 17:12:17">2022/08/13</span>
        </a>
        
        <a  class="全部文章 工作笔记 "
           href="/2022/08/12/%E5%AF%B9dto%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7%E4%B8%80%E9%94%AE%E5%8A%A0%E8%A7%A3%E5%AF%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="对dto指定属性一键加解密">对dto指定属性一键加解密</span>
            <span class="post-date" title="2022-08-12 22:51:17">2022/08/12</span>
        </a>
        
        <a  class="全部文章 源码 "
           href="/2022/08/03/%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9jsessionid%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="反射修改jsessionid实现session共享">反射修改jsessionid实现session共享</span>
            <span class="post-date" title="2022-08-03 21:53:21">2022/08/03</span>
        </a>
        
        <a  class="全部文章 源码 "
           href="/2022/08/03/RestTemlate%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%AE%BE%E8%AE%A1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="RestTemlate源码分析及工具类设计">RestTemlate源码分析及工具类设计</span>
            <span class="post-date" title="2022-08-03 21:51:57">2022/08/03</span>
        </a>
        
        <a  class="全部文章 工作笔记 "
           href="/2022/08/03/%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1%E8%A2%AB%E6%94%BB%E5%87%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="短信服务被攻击解决方案">短信服务被攻击解决方案</span>
            <span class="post-date" title="2022-08-03 21:51:16">2022/08/03</span>
        </a>
        
        <a  class="全部文章 工作笔记 "
           href="/2022/08/03/%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95Servlet%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8Spring%E7%9A%84Bean%E5%AF%B9%E8%B1%A1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="四种方法Servlet容器使用Spring的Bean对象">四种方法Servlet容器使用Spring的Bean对象</span>
            <span class="post-date" title="2022-08-03 21:47:54">2022/08/03</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2022/07/19/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="内存区域、类的加载">内存区域、类的加载</span>
            <span class="post-date" title="2022-07-19 22:29:21">2022/07/19</span>
        </a>
        
        <a  class="全部文章 工作笔记 "
           href="/2022/07/19/Restful%E9%A3%8E%E6%A0%BC%E7%9C%9F%E7%9A%84%E6%9C%89%E5%BF%85%E8%A6%81%E5%90%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Restful风格真的有必要吗？">Restful风格真的有必要吗？</span>
            <span class="post-date" title="2022-07-19 20:19:57">2022/07/19</span>
        </a>
        
        <a  class="全部文章 机器学习 "
           href="/2022/07/17/%E6%B0%94%E8%B1%A1cv-%E5%9C%B0%E5%9F%BA%E4%BA%91%E5%9B%BE%E4%BA%91%E7%B3%BB%E5%88%86%E5%89%B2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="气象cv-地基云图云系分割">气象cv-地基云图云系分割</span>
            <span class="post-date" title="2022-07-17 12:04:12">2022/07/17</span>
        </a>
        
        <a  class="全部文章 机器学习 "
           href="/2022/07/17/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E6%9E%A3%E7%B1%BB%E9%81%97%E4%BC%A0%E7%9A%84%E5%9B%9E%E5%BD%92%E9%A2%84%E6%B5%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="支持向量机枣类遗传的回归预测">支持向量机枣类遗传的回归预测</span>
            <span class="post-date" title="2022-07-17 11:47:04">2022/07/17</span>
        </a>
        
        <a  class="全部文章 机器学习 "
           href="/2022/07/17/%E6%B0%94%E8%B1%A1%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="气象大数据分析">气象大数据分析</span>
            <span class="post-date" title="2022-07-17 11:44:44">2022/07/17</span>
        </a>
        
        <a  class="全部文章 机器学习 "
           href="/2022/07/17/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8D%95%E5%9B%BE%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卷积神经网络单图超分辨率的深度学习方法">卷积神经网络单图超分辨率的深度学习方法</span>
            <span class="post-date" title="2022-07-17 11:33:07">2022/07/17</span>
        </a>
        
        <a  class="全部文章 机器学习 "
           href="/2022/07/17/%E7%96%AB%E6%83%85%E6%B8%AF%E5%8F%A3%E6%8C%82%E9%9D%A0%E6%95%B0ARIMA%E6%97%B6%E5%BA%8F%E5%88%86%E6%9E%90/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="疫情港口挂靠数ARIMA时序分析">疫情港口挂靠数ARIMA时序分析</span>
            <span class="post-date" title="2022-07-17 11:21:13">2022/07/17</span>
        </a>
        
        <a  class="全部文章 工作笔记 "
           href="/2022/07/15/OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%B9%E9%80%A0%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="OGNL表达式改造以使用索引">OGNL表达式改造以使用索引</span>
            <span class="post-date" title="2022-07-15 22:27:54">2022/07/15</span>
        </a>
        
        <a  class="全部文章 工作笔记 "
           href="/2022/07/15/mvcc+%E6%8C%89%E5%A4%A9%E7%BC%93%E5%AD%98%E7%BB%9F%E8%AE%A1%E4%B8%A4%E4%B8%AA%E6%94%B6%E7%9B%8A/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="mvcc+按天缓存统计两个收益">mvcc+按天缓存统计两个收益</span>
            <span class="post-date" title="2022-07-15 21:35:25">2022/07/15</span>
        </a>
        
        <a  class="全部文章 工作笔记 "
           href="/2022/07/15/%E5%8E%8B%E7%BC%A9%E6%89%93%E5%8C%85%E4%BD%86%E4%B8%8D%E5%BD%92%E6%A1%A3%EF%BC%8C%E5%88%A9%E7%94%A8response/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="压缩打包但不归档，利用response">压缩打包但不归档，利用response</span>
            <span class="post-date" title="2022-07-15 21:26:51">2022/07/15</span>
        </a>
        
        <a  class="全部文章 工作笔记 "
           href="/2022/07/15/%E4%B8%9A%E5%8A%A1%E4%B8%ADdelete_flag%E5%AD%97%E6%AE%B5%E5%AE%B9%E6%98%93%E8%B8%A9%E7%9A%84%E5%9D%91/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="业务中delete_flag字段容易踩的坑">业务中delete_flag字段容易踩的坑</span>
            <span class="post-date" title="2022-07-15 21:19:19">2022/07/15</span>
        </a>
        
        <a  class="全部文章 工作笔记 "
           href="/2022/07/15/%E9%9D%9E%E6%97%B6%E5%BA%8F%E6%8E%92%E5%BA%8F%E4%B8%8B%E7%9A%84%E7%80%91%E5%B8%83%E6%B5%81%E5%88%86%E9%A1%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="非时序排序下的瀑布流分页">非时序排序下的瀑布流分页</span>
            <span class="post-date" title="2022-07-15 21:15:15">2022/07/15</span>
        </a>
        
        <a  class="全部文章 数据结构算法 "
           href="/2022/06/25/%E8%A1%8C%E7%A8%8B%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="行程编码压缩图片">行程编码压缩图片</span>
            <span class="post-date" title="2022-06-25 01:35:20">2022/06/25</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2022/04/21/Filter%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Filter的常见用法">Filter的常见用法</span>
            <span class="post-date" title="2022-04-21 09:51:40">2022/04/21</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2022/04/21/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Lambda表达式和方法引用">Lambda表达式和方法引用</span>
            <span class="post-date" title="2022-04-21 09:50:42">2022/04/21</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2022/04/21/Mybatis%E4%B8%ADxml%E4%B8%AD%E8%B0%83java%E6%96%B9%E6%B3%95OGNL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mybatis中xml中调java方法OGNL表达式">Mybatis中xml中调java方法OGNL表达式</span>
            <span class="post-date" title="2022-04-21 09:47:36">2022/04/21</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2022/04/21/Java%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java注解和反射">Java注解和反射</span>
            <span class="post-date" title="2022-04-21 09:45:15">2022/04/21</span>
        </a>
        
        <a  class="全部文章 源码 "
           href="/2022/03/21/HashMap%E4%B8%ADentrySet-%E8%AF%A6%E8%A7%A3/"
           data-tag="HashMap"
           data-author="" >
            <span class="post-title" title="HashMap中entrySet()详解">HashMap中entrySet()详解</span>
            <span class="post-date" title="2022-03-21 00:15:10">2022/03/21</span>
        </a>
        
        <a  class="全部文章 源码 "
           href="/2022/03/21/HashMap/"
           data-tag="HashMap"
           data-author="" >
            <span class="post-title" title="HashMap">HashMap</span>
            <span class="post-date" title="2022-03-21 00:13:23">2022/03/21</span>
        </a>
        
        <a  class="全部文章 中间件 "
           href="/2022/03/07/Mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mysql事务和存储引擎">Mysql事务和存储引擎</span>
            <span class="post-date" title="2022-03-07 22:11:06">2022/03/07</span>
        </a>
        
        <a  class="全部文章 中间件 "
           href="/2022/03/07/Mysql-InnoDB-%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%8F%8A%E7%9A%84%E4%BD%BF%E7%94%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Mysql(InnoDB)索引原理及的使用">Mysql(InnoDB)索引原理及的使用</span>
            <span class="post-date" title="2022-03-07 22:10:05">2022/03/07</span>
        </a>
        
        <a  class="全部文章 源码 "
           href="/2022/02/21/LinkedList%E6%BA%90%E7%A0%81%E4%B8%AD%E4%B8%BA%E4%BD%95%E5%A4%A7%E9%87%8F%E5%87%BA%E7%8E%B0final/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LinkedList源码中为何大量出现final">LinkedList源码中为何大量出现final</span>
            <span class="post-date" title="2022-02-21 09:57:35">2022/02/21</span>
        </a>
        
        <a  class="全部文章 源码 "
           href="/2022/02/20/LinkedList%E4%B8%ADclear%E5%92%8Cunlink%E5%A4%9A%E6%AC%A1%E7%BD%AEnull/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LinkedList中clear和unlink方法为什么多次置null">LinkedList中clear和unlink方法为什么多次置null</span>
            <span class="post-date" title="2022-02-20 00:25:11">2022/02/20</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2022/02/20/gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="gc垃圾回收机制">gc垃圾回收机制</span>
            <span class="post-date" title="2022-02-20 00:17:43">2022/02/20</span>
        </a>
        
        <a  class="全部文章 机器学习 "
           href="/2022/01/11/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E8%8E%B7%E6%95%91%E9%A2%84%E6%B5%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="随机森林——泰坦尼克号获救预测">随机森林——泰坦尼克号获救预测</span>
            <span class="post-date" title="2022-01-11 03:06:10">2022/01/11</span>
        </a>
        
        <a  class="全部文章 机器学习 "
           href="/2022/01/01/%E5%86%B3%E7%AD%96%E6%A0%91-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E6%B5%81%E5%A4%B1%E9%A2%84%E6%B5%8B%E7%9A%84%E6%A1%88%E4%BE%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="决策树/随机森林——用户流失预测的案例">决策树/随机森林——用户流失预测的案例</span>
            <span class="post-date" title="2022-01-01 00:41:40">2022/01/01</span>
        </a>
        
        <a  class="全部文章 "
           href="/2021/12/25/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IDEA常用快捷键">IDEA常用快捷键</span>
            <span class="post-date" title="2021-12-25 21:55:46">2021/12/25</span>
        </a>
        
        <a  class="全部文章 Java "
           href="/2021/12/25/Java%E5%9B%9B%E7%A7%8Dnext%E7%94%A8%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java四种next用法">Java四种next用法</span>
            <span class="post-date" title="2021-12-25 01:59:30">2021/12/25</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-RestTemlate源码分析及工具类设计" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">RestTemlate源码分析及工具类设计</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="源码">源码</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-08-03 22:18:25'>2022-08-03 21:51</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:4.2k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E8%BF%94%E5%9B%9E%E5%80%BCResponseEntity%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">1.返回值ResponseEntity有什么用？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-postForObject-%E5%92%8CpostForEntity"><span class="toc-text">1.1 postForObject()和postForEntity()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2ResponseEntity%E7%9A%84%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0"><span class="toc-text">1.2ResponseEntity的重要参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">1.2.1状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-getBody-getHeaders"><span class="toc-text">1.2.2 getBody() getHeaders()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3ResponseEntity%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%EF%BC%9F"><span class="toc-text">1.3ResponseEntity是如何封装返回值的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-responseExtrator-extractData-response-%E6%8F%90%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">1.3.1 responseExtrator.extractData(response)提取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2extractDatad%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">1.3.2extractDatad抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3%E5%85%AC%E5%85%B1%E7%9A%84extractData-%E9%80%BB%E8%BE%91"><span class="toc-text">1.3.3公共的extractData()逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-4nonNull%E6%A3%80%E9%AA%8C%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-text">1.3.4nonNull检验是否为空</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E5%B0%8F%E7%BB%93"><span class="toc-text">1.4小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-exchange-%E5%92%8CxxxtForEntity"><span class="toc-text">2.exchange()和xxxtForEntity()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1get%E5%8D%A0%E4%BD%8D%E7%AC%A6%E5%92%8C%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84"><span class="toc-text">2.1get占位符和可变数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-RequestParam%E6%A1%88%E4%BE%8B"><span class="toc-text">2.1.1@RequestParam案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-PathVariable%E6%A1%88%E4%BE%8B"><span class="toc-text">2.1.2@PathVariable案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2post%E6%90%BA%E5%B8%A6%E8%AF%B7%E6%B1%82%E4%BD%93"><span class="toc-text">2.2post携带请求体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1%E5%BD%93%E6%9C%AC%E5%9C%B0%E6%9C%89dto%E4%BB%A3%E7%A0%81%E6%97%B6-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8"><span class="toc-text">2.2.1当本地有dto代码时-直接使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8HashMap"><span class="toc-text">2.2.2 不能使用HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E4%BD%BF%E7%94%A8SpringMVC%E4%B8%8B%E7%9A%84map"><span class="toc-text">2.2.3 使用SpringMVC下的map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E5%90%8C%E6%97%B6%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E4%BD%93and%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-text">2.2.4 同时设置请求体and请求头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5%E5%90%8C%E6%97%B6%E8%AF%B7%E6%B1%82%E4%BD%93-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="toc-text">2.2.5同时请求体 请求参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">3.工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">3.1完整代码：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E6%BC%94%E7%A4%BA"><span class="toc-text">3.2演示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%B0%8F%E6%8F%92%E6%9B%B2"><span class="toc-text">4.小插曲</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F"><span class="toc-text">4.1环境模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B"><span class="toc-text">4.1.2接口提供</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF"><span class="toc-text">4.2源码分析思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1%E6%96%B9%E6%B3%95%E6%9C%AC%E8%BA%AB%E5%8C%BA%E5%88%AB"><span class="toc-text">4.2.1方法本身区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2%E5%88%86%E5%88%AB%E7%9C%8B%E4%B8%A4%E4%B8%AA%E5%86%85%E9%83%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">4.2.2分别看两个内部的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-1-exchange-%E5%B8%A6%E5%8F%82%E7%9A%84%EF%BC%9AhttpEntityCallback"><span class="toc-text">4.2.2.1 exchange-带参的：httpEntityCallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-2getFroEntity-%E6%97%A0%E5%8F%82%EF%BC%9AacceptHeaderRequestCallback"><span class="toc-text">4.2.2.2getFroEntity-无参：acceptHeaderRequestCallback</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3%E5%88%B0%E6%AD%A4%E6%B2%A1%E6%9C%89%E5%88%86%E6%9E%90%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%88%99%E7%9C%8Brequest%E5%9B%9E%E8%B0%83%E7%9B%B8%E5%85%B3%E7%9A%84execute"><span class="toc-text">4.3到此没有分析出异常，则看request回调相关的execute</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1%E5%88%86%E6%9E%90%E7%90%86%E7%94%B1"><span class="toc-text">4.3.1分析理由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2doExecute"><span class="toc-text">4.3.2doExecute()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E5%AE%9A%E4%BD%8D%E5%88%B0doWithRequest%EF%BC%88%EF%BC%89"><span class="toc-text">4.4定位到doWithRequest（）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-debug-%E5%8F%91%E7%8E%B0%E6%94%AF%E6%8C%81%E7%9A%84%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.4.1 debug 发现支持的媒体类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2%E5%9B%9E%E5%8E%BB%E7%9C%8B%E5%8F%82%E6%95%B0%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE"><span class="toc-text">4.4.2回去看参数是否正确</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5%E4%BF%AE%E6%94%B9%E5%8F%82%E6%95%B0"><span class="toc-text">4.5修改参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6%E7%BB%93%E8%AE%BA"><span class="toc-text">4.6结论</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先说个大概的结构：</p>
<ul>
<li>RestTemlate的所有方法最终调用的是<code>doExecute()</code>，层层向外封装</li>
<li>其中<code>exchange()</code>适合用来封装成工具类，他的返回值是ResponseEntity</li>
<li><code>postForObject()</code>  和 <code> postForEntity</code>本质上一样，只是<code>后者</code>对运行结果进行了封装，返回的也是ResponseEntity，类似于lambda表达式中的Option类</li>
</ul>
<p>1.本文的源码分析部分采用“从外到内”的顺序进行分析<br>2.类似postForObject和getForObject这种的区别仅仅是GET请求和POST请求的区别，本文仅分析POST请求的<br>3.postFroLocation()方法是返回一个URI，不是本文的重点</p>
<h1 id="1-返回值ResponseEntity有什么用？"><a href="#1-返回值ResponseEntity有什么用？" class="headerlink" title="1.返回值ResponseEntity有什么用？"></a>1.返回值ResponseEntity有什么用？</h1><h2 id="1-1-postForObject-和postForEntity"><a href="#1-1-postForObject-和postForEntity" class="headerlink" title="1.1 postForObject()和postForEntity()"></a>1.1 postForObject()和postForEntity()</h2><p><strong>看源码的注释部分，几乎一致，也就是两个方法基本没有什么区别</strong></p>
<p>其中一个返回值是封装类ResponseEntity</p>
<p><img src="https://img-blog.csdnimg.cn/ff77b26b03a846c0a63c5ab067ca1c2a.png"><br><strong>重要！！：关于提取响应的方式</strong></p>
<p>postForObject：<code>HttpMessageConvertExtractor</code><br>postforEntity：<code>ResponseExtractor</code><br>这两个Extractor类都有一个公共接口<code>extractData</code>，他在execute方法执行的时候被调用，用于获取HTTP响应的数据，只是在实现上，一个只获取响应体，另一个还要额外获取headers和status<br><img src="https://img-blog.csdnimg.cn/1134d9e8c5ba48ca8c789762e64b3932.png" alt="公共接口"></p>
<p><img src="https://img-blog.csdnimg.cn/cbb84d0aeee54c4a8d206a7ca16c84d2.png"></p>
<h2 id="1-2ResponseEntity的重要参数"><a href="#1-2ResponseEntity的重要参数" class="headerlink" title="1.2ResponseEntity的重要参数"></a>1.2ResponseEntity的重要参数</h2><p><strong>既然这个封装类有状态码status，响应头headers，那么一定在某个地方，getForObject没有去指定而getForEntity指定了</strong>（这时候应该猜到是extractData()方法，将在后面讨论）</p>
<p><img src="https://img-blog.csdnimg.cn/d5474ff09bc943b5afb10948902e1965.png" alt="形参"></p>
<p><img src="https://img-blog.csdnimg.cn/f65367f397be4f47aa015251311c2ac0.png" alt="父类"></p>
<h3 id="1-2-1状态码"><a href="#1-2-1状态码" class="headerlink" title="1.2.1状态码"></a>1.2.1状态码</h3><p><img src="https://img-blog.csdnimg.cn/cd139059659d4120a31725ab5fd0f4af.png"></p>
<h3 id="1-2-2-getBody-getHeaders"><a href="#1-2-2-getBody-getHeaders" class="headerlink" title="1.2.2 getBody() getHeaders()"></a>1.2.2 getBody() getHeaders()</h3><p>直接获取上面两个参数，不再赘述</p>
<h2 id="1-3ResponseEntity是如何封装返回值的？"><a href="#1-3ResponseEntity是如何封装返回值的？" class="headerlink" title="1.3ResponseEntity是如何封装返回值的？"></a>1.3ResponseEntity是如何封装返回值的？</h2><h3 id="1-3-1-responseExtrator-extractData-response-提取数据"><a href="#1-3-1-responseExtrator-extractData-response-提取数据" class="headerlink" title="1.3.1 responseExtrator.extractData(response)提取数据"></a>1.3.1 responseExtrator.extractData(response)提取数据</h3><ul>
<li>已知，最终都是调用doExecute()</li>
<li>两个方法到这里的Extractor都是非空的，都是一定要执行，两个执行逻辑不同</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/4617c2b5c4f342e8b090be01ea87b37e.png"></p>
<h3 id="1-3-2extractDatad抽象方法"><a href="#1-3-2extractDatad抽象方法" class="headerlink" title="1.3.2extractDatad抽象方法"></a>1.3.2extractDatad抽象方法</h3><p>这里直接看getForEntity对应的<code>ResponseEntityResponseExtractor</code>，<strong>即封装了status和headers的执行过程</strong></p>
<p><img src="https://img-blog.csdnimg.cn/8b3bff8efafa410ca33c7e9971af2d95.png"><br><strong>因此，只有返回值是Entity的才有headers和status，否则像getForObject这种方法返回的只是一个响应体</strong></p>
<p><img src="https://img-blog.csdnimg.cn/e3d76f4b94734da3919f2f0ba4cceef4.png"></p>
<h3 id="1-3-3公共的extractData-逻辑"><a href="#1-3-3公共的extractData-逻辑" class="headerlink" title="1.3.3公共的extractData()逻辑"></a>1.3.3公共的extractData()逻辑</h3><p>即两个都会调用的，上面那么打红框的，通篇都是只针对了响应体进行操作，没有涉及任何的headers和status</p>
<p><img src="https://img-blog.csdnimg.cn/0bb36eb745b948838436c3474fe09222.png"></p>
<h3 id="1-3-4nonNull检验是否为空"><a href="#1-3-4nonNull检验是否为空" class="headerlink" title="1.3.4nonNull检验是否为空"></a>1.3.4nonNull检验是否为空</h3><p>如果是封装为Entity，那么还要再加一层判断方法<img src="https://img-blog.csdnimg.cn/365add9267e14f11bcf45c145c8f4c1f.png"></p>
<h2 id="1-4小结"><a href="#1-4小结" class="headerlink" title="1.4小结"></a>1.4小结</h2><ul>
<li><p>到此为止我们分析了为什么getForObject()返回的只有响应体，而getForEntity()返回的包括了响应体 响应头  响应状态</p>
</li>
<li><p>而getForEntity()和exchange()返回的都是ResponseEntity对象，因此第二点引出二者的区别</p>
</li>
<li><p>get和post请求只有一个区别，后续会演示如何使用API<img src="https://img-blog.csdnimg.cn/2692bd692fd5477994460bb07621cbd1.png"></p>
</li>
</ul>
<h1 id="2-exchange-和xxxtForEntity"><a href="#2-exchange-和xxxtForEntity" class="headerlink" title="2.exchange()和xxxtForEntity()"></a>2.exchange()和xxxtForEntity()</h1><ul>
<li>可以看出区别就是<code>requestEntity</code>请求参数</li>
<li>至于请求方法method不是主要矛盾</li>
<li>这三个方法，参数所对应的含义如下：<br>第一个：url<br>对于exchange，第二个参数是请求方式自定义<br>第三个：请求体参数，exchange和post有，get没有，<strong>用map或dto或requestEntity封装</strong><br>第四个：返回值类型<br>第五个：路径参数，对应的是@RequestParam和@PathVariable，<strong>使用方式是在url中用{}占位</strong>，类似logger的{}，也类似String.format()中的%s占位，因此Object…uriVariables是一个可变数组</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/805cd29b3f874c5db1447b8403cc378b.png"></p>
<p><img src="https://img-blog.csdnimg.cn/4b0a8113b4814064af683d591efa2f3e.png"></p>
<p>这里找了一个写的比较全的API演示：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012843361/article/details/79893638">参考链接</a></p>
<h2 id="2-1get占位符和可变数组"><a href="#2-1get占位符和可变数组" class="headerlink" title="2.1get占位符和可变数组"></a>2.1get占位符和可变数组</h2><h3 id="2-1-1-RequestParam案例"><a href="#2-1-1-RequestParam案例" class="headerlink" title="2.1.1@RequestParam案例"></a>2.1.1@RequestParam案例</h3><p>请求的接口有两个@RequestParam参数，通过姓名和性别获取图片的一个例子</p>
<pre><code>    ResponseEntity&lt;byte[]&gt; responseEntity =
            restTemplate.getForEntity(&quot;http://localhost:8080/pic/pic1?name=&#123;name&#125;&amp;sex=&#123;sex&#125;&quot;, byte[].class,
                    &quot;名字&quot;, &quot;性别&quot;);
    ServletOutputStream os = response.getOutputStream();
    os.write(responseEntity.getBody());
</code></pre>
<p>当然对于@RequestParam最好的做法是放在最后一个形参中，传一个map，在后面会提到</p>
<h3 id="2-1-2-PathVariable案例"><a href="#2-1-2-PathVariable案例" class="headerlink" title="2.1.2@PathVariable案例"></a>2.1.2@PathVariable案例</h3><p>大同小异</p>
<pre><code> restTemplate.getForEntity(&quot;http://localhost:8080/pic/pic1/&#123;name&#125;/&#123;sex&#125;&quot;, byte[].class,
                    &quot;名字&quot;, &quot;性别&quot;);
</code></pre>
<h2 id="2-2post携带请求体"><a href="#2-2post携带请求体" class="headerlink" title="2.2post携带请求体"></a>2.2post携带请求体</h2><h3 id="2-2-1当本地有dto代码时-直接使用"><a href="#2-2-1当本地有dto代码时-直接使用" class="headerlink" title="2.2.1当本地有dto代码时-直接使用"></a>2.2.1当本地有dto代码时-直接使用</h3><p>当本地有dto代码的时候，第二个形参直接用dto就好</p>
<pre><code>    //当本地有dto的代码时,可以直接用dto来作为第二个请求体形参
    People people = new People();
    people.setAge(22);
    people.setName(&quot;张三&quot;);
    people.setTall(181);
    //最后一个可变数组的形参不用指定
    ResponseEntity&lt;byte[]&gt; res =
            restTemplate.postForEntity(&quot;http://localhost:8080/pic/people/pic1&quot;, people, byte[].class);
    ServletOutputStream os = response.getOutputStream();
    os.write(res.getBody());
</code></pre>
<p>但不一定是任何时候都有这个dto代码，如果没有这个dto代码，去调用其他的服务器，还需要写一个dto吗？不需要</p>
<h3 id="2-2-2-不能使用HashMap"><a href="#2-2-2-不能使用HashMap" class="headerlink" title="2.2.2 不能使用HashMap"></a>2.2.2 不能使用HashMap</h3><p>使用HashMap虽然在语法上没有问题<strong>，但是会导致请求体对应不上去</strong>，被请求的接口收不到请求体参数</p>
<p>例如：</p>
<pre><code>      HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();
    hashMap.put(&quot;name&quot;,&quot;张三&quot;);
    hashMap.put(&quot;age&quot;,&quot;1&quot;);
    hashMap.put(&quot;tall&quot;,&quot;181&quot;);

    //最后一个可变数组的形参不用指定
    ResponseEntity&lt;byte[]&gt; res =
            restTemplate.postForEntity(&quot;http://localhost:8080/pic/people/pic1&quot;, hashMap, byte[].class);
    ServletOutputStream os = response.getOutputStream();
    os.write(res.getBody());
</code></pre>
<h3 id="2-2-3-使用SpringMVC下的map"><a href="#2-2-3-使用SpringMVC下的map" class="headerlink" title="2.2.3 使用SpringMVC下的map"></a>2.2.3 使用SpringMVC下的map</h3><p><code>MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;String, String&gt;();</code></p>
<p><strong>他是org.springframework.util包下的一个Map<br>他兼容了类型匹配，与SpringMVC的适配性很好</strong></p>
<pre><code>    MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;String, String&gt;();
    map.add(&quot;name&quot;,&quot;张三&quot;);
    map.add(&quot;age&quot;,&quot;11&quot;);
    map.add(&quot;tall&quot;,&quot;181&quot;);

    //最后一个可变数组的形参不用指定
    ResponseEntity&lt;byte[]&gt; res =
            restTemplate.postForEntity(&quot;http://localhost:8080/pic/people/pic1&quot;, map, byte[].class);
    ServletOutputStream os = response.getOutputStream();
    os.write(res.getBody());
</code></pre>
<h3 id="2-2-4-同时设置请求体and请求头"><a href="#2-2-4-同时设置请求体and请求头" class="headerlink" title="2.2.4 同时设置请求体and请求头"></a>2.2.4 同时设置请求体and请求头</h3><ul>
<li><p>请求体写在<code>MultiValueMap</code></p>
</li>
<li><p>请求头写在<code>HttpHeaders</code></p>
</li>
<li><p>最终用<code>HttpEntity</code>封装，需要注意泛型的指定就是MultiValueMap</p>
<pre><code>      MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;String, String&gt;();
      map.add(&quot;name&quot;,&quot;张三&quot;);
      map.add(&quot;age&quot;,&quot;11&quot;);
      map.add(&quot;tall&quot;,&quot;181&quot;);

      HttpHeaders httpHeaders = new HttpHeaders();
      //按需求自行添加
  //        httpHeaders.setContentType();
  //        httpHeaders.setExpires();

      //这个Entity包含了请求体 和 请求头
      //泛型的指定即：map的类型
      HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; entity = new HttpEntity&lt;&gt;(map,httpHeaders);

      //最后一个可变数组的形参不用指定
      ResponseEntity&lt;byte[]&gt; res =
              restTemplate.postForEntity(&quot;http://localhost:8080/pic/people/pic1&quot;, entity, byte[].class);
      ServletOutputStream os = response.getOutputStream();
      os.write(res.getBody());
</code></pre>
</li>
</ul>
<h3 id="2-2-5同时请求体-请求参数"><a href="#2-2-5同时请求体-请求参数" class="headerlink" title="2.2.5同时请求体 请求参数"></a>2.2.5同时请求体 请求参数</h3><p>有两种写法，一种是url拼接，利用最后一个参数是可变数组</p>
<pre><code>ResponseEntity&lt;byte[]&gt; res = restTemplate.exchange(&quot;http://localhost:8080/pic/withbody?param1=&#123;param1&#125;&quot;, HttpMethod.POST,
    httpEntity, byte[].class, &quot;请求参数1&quot;
);
</code></pre>
<p>第二种是最后一个参数用一个map</p>
<pre><code>HashMap&lt;String, String&gt; urls = new HashMap&lt;&gt;();
urls.put(&quot;param1&quot;,&quot;测试1&quot;);

ResponseEntity&lt;byte[]&gt; res = restTemplate.exchange(&quot;http://localhost:8080/pic/withbody&quot;, HttpMethod.POST,
    httpEntity, byte[].class, urls
);
</code></pre>
<h1 id="3-工具类"><a href="#3-工具类" class="headerlink" title="3.工具类"></a>3.工具类</h1><ul>
<li>根据公司业务写了一个工具类，可以根据需要，对<code>baseByteTractor</code>和<code>baseJsonTractor</code>进行封装</li>
<li>可根据业务，携带param、body、header请求接口，并可选择是否将其响应数据的header和statusCode写入响应体</li>
<li>工具类没有选择使用Spring Bean，而是使用安全的单例模式，移植性更强</li>
</ul>
<h2 id="3-1完整代码："><a href="#3-1完整代码：" class="headerlink" title="3.1完整代码："></a>3.1完整代码：</h2><pre><code>import java.io.BufferedOutputStream;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.lang.Nullable;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

/**
 * @Description RestTemplate工具类
 * 1.getByte() postByte()是用来下载流的，因此形参必须有HttpResponseBody
 * 2.getJson() postJson()是用来获取json的，形参可以不带response
 * 3.每个方法最后一个形参requireBodyOnly默认true，即只需要响应体，一般建议设为true，
 *     否则可能造成因header自动解析产生的问题
 * 4.post请求可以额外携带请求体
 * 5.可能产生EOFException异常，正常，可以全局捕获日志记录
 * 
 * @Author zjh
 * @Date 17:04 2022/7/28
 **/
public class RestTemplateUtils &#123;

  private static          Logger       logger = LoggerFactory.getLogger(&quot;RestLogger&quot;);
  private volatile static RestTemplate restTemplate;

  /**
   * RestTemplate单例 懒汉 双检锁
   **/
  public static RestTemplate getSingleRestTemplate() &#123;
    if (restTemplate == null) &#123;
      synchronized (RestTemplateUtils.class) &#123;
        if (restTemplate == null) &#123;
          restTemplate = new RestTemplate();
        &#125;
      &#125;
    &#125;
    return restTemplate;
  &#125;


  /**
   * 基础方法，下载文件二进制流到response输出流
   *
   * @param url 不包含请求参数 即 ?param=&#123;&#125;
   * @param method POST或GET
   * @param requestHeaders 请求头，可为空
   * @param requestParams 请求参数，可为空
   * @param requestBody 请求体，可为空
   * @param requireBodyOnly 是否是只需要响应体,默认true，true：只需要响应体  false：同时返回响应状态 响应头  响应体
   * @return void
   **/
  public static void baseByteTractor(String url, HttpMethod method,
      @Nullable Map&lt;String, String&gt; requestHeaders,
      @Nullable Map&lt;String, Object&gt; requestParams,
      @Nullable Map&lt;String, Object&gt; requestBody,
      HttpServletResponse response,
      @Nullable Boolean requireBodyOnly) &#123;
    if (requireBodyOnly == null) &#123;
      requireBodyOnly = true;
    &#125;
    MultiValueMap&lt;String, Object&gt; params  = new LinkedMultiValueMap&lt;String, Object&gt;();
    MultiValueMap&lt;String, Object&gt; body    = new LinkedMultiValueMap&lt;String, Object&gt;();
    HttpHeaders                   headers = new HttpHeaders();

    //1.设置请求参数
    if (requestParams != null &amp;&amp; !requestParams.isEmpty()) &#123;
      Iterator&lt;Entry&lt;String, Object&gt;&gt; paramsIterator = requestParams.entrySet().iterator();
      Entry&lt;String, Object&gt;           nextParam      = null;
      while (paramsIterator.hasNext()) &#123;
        nextParam = paramsIterator.next();
        params.add(nextParam.getKey(), nextParam.getValue());
      &#125;
    &#125;
    //2.设置请求头
    if (requestHeaders != null &amp;&amp; !requestHeaders.isEmpty()) &#123;
      Iterator&lt;Entry&lt;String, String&gt;&gt; headersIterator = requestHeaders.entrySet().iterator();
      Entry&lt;String, String&gt;           nextHeader      = null;
      while (headersIterator.hasNext()) &#123;
        nextHeader = headersIterator.next();
        headers.add(nextHeader.getKey(), nextHeader.getValue());
      &#125;
    &#125;
    //3.设置请求体
    if (requestBody != null &amp;&amp; !requestBody.isEmpty()) &#123;
      Iterator&lt;Entry&lt;String, Object&gt;&gt; bodyIterator = requestBody.entrySet().iterator();
      Entry&lt;String, Object&gt;           bodyNext     = null;
      while (bodyIterator.hasNext()) &#123;
        bodyNext = bodyIterator.next();
        body.add(bodyNext.getKey(), bodyNext.getValue());
      &#125;
    &#125;
    //4.请求体 请求头封装到HttpEntity
    HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(body, headers);
    //5.执行
    RestTemplate         restTemplate = getSingleRestTemplate();
    BufferedOutputStream bos          = null;
    try &#123;
      ResponseEntity&lt;byte[]&gt; exchange = restTemplate.exchange(url, method, entity, byte[].class, params);
      if (!requireBodyOnly &amp;&amp; response != null) &#123;
        //响应状态码
        response.setStatus(exchange.getStatusCodeValue());
        //响应头,可能存在一个key对应多个value,本方法中会将同名header合并
        HttpHeaders                           resHeaders         = exchange.getHeaders();
        Iterator&lt;Entry&lt;String, List&lt;String&gt;&gt;&gt; resHeadersIterator = resHeaders.entrySet().iterator();
        while (resHeadersIterator.hasNext()) &#123;
          Entry&lt;String, List&lt;String&gt;&gt; headersNext = resHeadersIterator.next();
          response.setHeader(headersNext.getKey(), headersNext.getValue().toString());
        &#125;
      &#125;
      //响应体
      ServletOutputStream os = response.getOutputStream();
      bos = new BufferedOutputStream(os);
      byte[] buf = exchange.getBody();
      bos.write(buf);
      bos.flush();
    &#125; catch (IOException e) &#123;
      logger.error(&quot;RestTemplateUtils获取接口二进制流异常&quot;);
    &#125; catch (RestClientException e) &#123;
      logger.error(&quot;远程调用接口异常&#123;&#125;&quot;, e);
    &#125; finally &#123;
      try &#123;
        bos.close();
      &#125; catch (IOException e) &#123;
        logger.error(&quot;RestTemplateUtils流关闭异常&quot;);
      &#125;
    &#125;
  &#125;

  /**
   * 基础方法，请求接口，返回JSON
   *
   * @param url 不包含请求参数 即 ?param=&#123;&#125;
   * @param method POST或GET
   * @param requestHeaders 请求头，可为空
   * @param requestParams 请求参数，可为空
   * @param requestBody 请求体，可为空
   * @param requireBodyOnly 是否是只需要响应体,默认true，true：只需要响应体  false：同时返回响应状态 响应头  响应体
   * @return String Json
   **/
  public static String baseJsonTracktor(String url, HttpMethod method,
      @Nullable Map&lt;String, String&gt; requestHeaders,
      @Nullable Map&lt;String, Object&gt; requestParams,
      @Nullable Map&lt;String, Object&gt; requestBody,
      @Nullable HttpServletResponse response,
      @Nullable Boolean requireBodyOnly) &#123;
    if (requireBodyOnly == null) &#123;
      requireBodyOnly = true;
    &#125;
    MultiValueMap&lt;String, Object&gt; params  = new LinkedMultiValueMap&lt;String, Object&gt;();
    MultiValueMap&lt;String, Object&gt; body    = new LinkedMultiValueMap&lt;String, Object&gt;();
    HttpHeaders                   headers = new HttpHeaders();

    //1.设置请求参数
    if (requestParams != null &amp;&amp; !requestParams.isEmpty()) &#123;
      Iterator&lt;Entry&lt;String, Object&gt;&gt; paramsIterator = requestParams.entrySet().iterator();
      Entry&lt;String, Object&gt;           nextParam      = null;
      while (paramsIterator.hasNext()) &#123;
        nextParam = paramsIterator.next();
        params.add(nextParam.getKey(), nextParam.getValue());
      &#125;
    &#125;
    //2.设置请求头
    if (requestHeaders != null &amp;&amp; !requestHeaders.isEmpty()) &#123;
      Iterator&lt;Entry&lt;String, String&gt;&gt; headersIterator = requestHeaders.entrySet().iterator();
      Entry&lt;String, String&gt;           nextHeader      = null;
      while (headersIterator.hasNext()) &#123;
        nextHeader = headersIterator.next();
        headers.add(nextHeader.getKey(), nextHeader.getValue());
      &#125;
    &#125;
    //3.设置请求体
    if (requestBody != null &amp;&amp; !requestBody.isEmpty()) &#123;
      Iterator&lt;Entry&lt;String, Object&gt;&gt; bodyIterator = requestBody.entrySet().iterator();
      Entry&lt;String, Object&gt;           bodyNext     = null;
      while (bodyIterator.hasNext()) &#123;
        bodyNext = bodyIterator.next();
        body.add(bodyNext.getKey(), bodyNext.getValue());
      &#125;
    &#125;
    //4.请求体 请求头封装到HttpEntity
    HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(body, headers);
    //5.执行
    RestTemplate restTemplate = getSingleRestTemplate();
    String       bodyJson     = &quot;&quot;;
    try &#123;
      ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(url, method, entity, String.class, params);
      if (!requireBodyOnly &amp;&amp; response != null) &#123;
        //响应状态码
        response.setStatus(exchange.getStatusCodeValue());
        //响应头,可能存在一个key对应多个value,本方法中会将同名header合并
        HttpHeaders                           resHeaders         = exchange.getHeaders();
        Iterator&lt;Entry&lt;String, List&lt;String&gt;&gt;&gt; resHeadersIterator = resHeaders.entrySet().iterator();
        while (resHeadersIterator.hasNext()) &#123;
          Entry&lt;String, List&lt;String&gt;&gt; headersNext = resHeadersIterator.next();
          response.setHeader(headersNext.getKey(), headersNext.getValue().toString());
        &#125;
      &#125;
      bodyJson = exchange.getBody();
    &#125; catch (RestClientException e) &#123;
      logger.error(&quot;远程调用接口异常&#123;&#125;&quot;, e);
    &#125;
    return bodyJson;
  &#125;

  /**
   * GET请求 下载流
   *
   * @param url 不包含请求参数 即 ?param=&#123;&#125;
   * @param requestParams 请求参数，可为空
   * @param requireBodyOnly 是否是只需要响应体,默认true，true：只需要响应体  false：同时返回响应状态 响应头  响应体
   * @return void
   **/
  public static void getByte(String url, HttpServletResponse response,
      @Nullable Map&lt;String, Object&gt; requestParams,
      @Nullable Boolean requireBodyOnly) &#123;
    if (requireBodyOnly == null) &#123;
      requireBodyOnly = true;
    &#125;
    baseByteTractor(url, HttpMethod.GET, null, requestParams, null, response, requireBodyOnly);
  &#125;


  /**
   * POST请求 下载流
   *
   * @param url 不包含请求参数 即 ?param=&#123;&#125;
   * @param requestParams 请求参数，可为空
   * @param requestBody 请求体，可为空
   * @param requireBodyOnly 是否是只需要响应体,默认true，true：只需要响应体  false：同时返回响应状态 响应头  响应体
   * @return void
   **/
  public static void postByte(String url, HttpServletResponse response,
      @Nullable Map&lt;String, Object&gt; requestParams,
      @Nullable Map&lt;String, Object&gt; requestBody,
      @Nullable Boolean requireBodyOnly) &#123;
    if (requireBodyOnly == null) &#123;
      requireBodyOnly = true;
    &#125;
    baseByteTractor(url, HttpMethod.POST, null, requestParams, requestBody, response, requireBodyOnly);
  &#125;


  /**
   * GET请求 获取JSON
   *
   * @param url 不包含请求参数 即 ?param=&#123;&#125;
   * @param requestParams 请求参数，可为空
   * @param requireBodyOnly 是否是只需要响应体,默认true，true：只需要响应体  false：同时返回响应状态 响应头  响应体
   * @return void
   **/
  public static String getJson(String url,
      @Nullable HttpServletResponse response,
      @Nullable Map&lt;String, Object&gt; requestParams,
      @Nullable Boolean requireBodyOnly) &#123;
    if (requireBodyOnly == null) &#123;
      requireBodyOnly = true;
    &#125;
    String resJson = baseJsonTracktor(url, HttpMethod.GET, null, requestParams, null, response, requireBodyOnly);
    return resJson;
  &#125;


  /**
   * POST请求 获取JSON
   *
   * @param url 不包含请求参数 即 ?param=&#123;&#125;
   * @param requestParams 请求参数，可为空
   * @param requestBody 请求体，可为空
   * @param requireBodyOnly 是否是只需要响应体,默认true，true：只需要响应体  false：同时返回响应状态 响应头  响应体
   * @return void
   **/
  public static String postJson(String url,
      @Nullable HttpServletResponse response,
      @Nullable Map&lt;String, Object&gt; requestParams,
      @Nullable Map&lt;String, Object&gt; requestBody,
      @Nullable Boolean requireBodyOnly) &#123;
    if (requireBodyOnly == null) &#123;
      requireBodyOnly = true;
    &#125;
    String resJson = baseJsonTracktor(url, HttpMethod.POST, null, requestParams, requestBody, response, requireBodyOnly);
    return resJson;
  &#125;


&#125;
</code></pre>
<h2 id="3-2演示"><a href="#3-2演示" class="headerlink" title="3.2演示"></a>3.2演示</h2><p><img src="https://img-blog.csdnimg.cn/466841ea1eb54688a58f13f5a91da1c6.png" alt="BYTE"><br><img src="https://img-blog.csdnimg.cn/2aaa7850f1574bdaaa2e86b11e302dc2.png" alt="JSON"></p>
<h1 id="4-小插曲"><a href="#4-小插曲" class="headerlink" title="4.小插曲"></a>4.小插曲</h1><p>在决定写下这篇文章之前，其实是在解决一个业务需求时碰到的问题，问题很简单，粗心导致的，但是反正都已经debug看了分析了源码了，所以干脆写下了上面的源码分析文章和工具类。。。</p>
<h2 id="4-1环境模拟"><a href="#4-1环境模拟" class="headerlink" title="4.1环境模拟"></a>4.1环境模拟</h2><h3 id="4-1-2接口提供"><a href="#4-1-2接口提供" class="headerlink" title="4.1.2接口提供"></a>4.1.2接口提供</h3><p>提供一个接口，设置一个请求头给response，把图片二进制流写入response</p>
<pre><code>@GetMapping(&quot;/pic1&quot;)
public void getPic(HttpServletRequest request,HttpServletResponse response) throws IOException &#123;
    response.setHeader(&quot;keyy&quot;,&quot;valuee&quot;);
    System.out.println(response.getHeader(&quot;keyy&quot;));
    File file = new File(&quot;C:\\Users\\zhangjiahao\\Desktop\\图片.jpg&quot;);
    FileInputStream fis = new FileInputStream(file);
    BufferedInputStream bis = new BufferedInputStream(fis);
    byte[] buf = new byte[2048];
    ServletOutputStream os = response.getOutputStream();
    BufferedOutputStream bos = new BufferedOutputStream(os);
    while(bis.read(buf) != -1)&#123;
        bos.write(buf);
    &#125;
    bos.flush();
    bos.close();
    bis.close();
   &#125;
</code></pre>
<h2 id="4-2源码分析思路"><a href="#4-2源码分析思路" class="headerlink" title="4.2源码分析思路"></a>4.2源码分析思路</h2><h3 id="4-2-1方法本身区别"><a href="#4-2-1方法本身区别" class="headerlink" title="4.2.1方法本身区别"></a>4.2.1方法本身区别</h3><p><strong>调用exchange()的时候，内部调用的方法是需要携带请求参数的，不过可以设为null</strong></p>
<p><img src="https://img-blog.csdnimg.cn/f4d74fc424e2449ab72a25e7dd853729.png" alt="getForEntity"><br><img src="https://img-blog.csdnimg.cn/cd8896e0622c45e48e6e2b73d9a86778.png" alt="exchange"><br>两个方法本身的区别就是：<code>requestEntity</code>，即请求参数</p>
<h3 id="4-2-2分别看两个内部的方法"><a href="#4-2-2分别看两个内部的方法" class="headerlink" title="4.2.2分别看两个内部的方法"></a>4.2.2分别看两个内部的方法</h3><h3 id="4-2-2-1-exchange-带参的：httpEntityCallback"><a href="#4-2-2-1-exchange-带参的：httpEntityCallback" class="headerlink" title="4.2.2.1 exchange-带参的：httpEntityCallback"></a>4.2.2.1 exchange-带参的：httpEntityCallback</h3><p><img src="https://img-blog.csdnimg.cn/5e4711f12bab4fc5971de022cbf8a823.png"></p>
<p>到目前为止没有看到对返回值response进行操作的内容<br><img src="https://img-blog.csdnimg.cn/ec598eb6550f4dc2a2cc44e9a2a37423.png"></p>
<h3 id="4-2-2-2getFroEntity-无参：acceptHeaderRequestCallback"><a href="#4-2-2-2getFroEntity-无参：acceptHeaderRequestCallback" class="headerlink" title="4.2.2.2getFroEntity-无参：acceptHeaderRequestCallback"></a>4.2.2.2getFroEntity-无参：acceptHeaderRequestCallback</h3><p><img src="https://img-blog.csdnimg.cn/c966fb07a8c34b6685ce62f58bc03d81.png"><br><img src="https://img-blog.csdnimg.cn/6fef8e3477fc4c51a64dba0f2ea602ad.png"></p>
<h2 id="4-3到此没有分析出异常，则看request回调相关的execute"><a href="#4-3到此没有分析出异常，则看request回调相关的execute" class="headerlink" title="4.3到此没有分析出异常，则看request回调相关的execute"></a>4.3到此没有分析出异常，则看request回调相关的execute</h2><h3 id="4-3-1分析理由"><a href="#4-3-1分析理由" class="headerlink" title="4.3.1分析理由"></a>4.3.1分析理由</h3><p>因为两个方法的区别就是在于回调<code>RequestCallback</code>，本身分析不出来问题，就去找其他<code>RequestCallback</code>相关的即<code>execute()</code>执行方法本身<img src="https://img-blog.csdnimg.cn/bc1f4bfe85644f90a190de7c7b214726.png"></p>
<h3 id="4-3-2doExecute"><a href="#4-3-2doExecute" class="headerlink" title="4.3.2doExecute()"></a>4.3.2doExecute()</h3><p>doWithRequest()对于这两个方法来说，其实都是会执行的</p>
<p><img src="https://img-blog.csdnimg.cn/1e0853997c16464c8753fd8b296bd15d.png"><br>debug的时候能正常进去</p>
<p><img src="https://img-blog.csdnimg.cn/f226121a4b514ef7afcc5be894fa83f9.png"></p>
<p>虽然这里没有指定requestEntity</p>
<p><img src="https://img-blog.csdnimg.cn/717c0b61574448ee96c3aa0bf051d3aa.png">但是内部造了一个requestCallBack，和requestEntity没有关系</p>
<p><img src="https://img-blog.csdnimg.cn/d072a85dd9694ea59111d2f50aa6a542.png"></p>
<h2 id="4-4定位到doWithRequest（）"><a href="#4-4定位到doWithRequest（）" class="headerlink" title="4.4定位到doWithRequest（）"></a>4.4定位到doWithRequest（）</h2><p><img src="https://img-blog.csdnimg.cn/ea860a58bf7d43f5bf0ae992610ed1c7.png"></p>
<p>这两个实现类其实是父子类关系，都会调用（内部用的super）<img src="https://img-blog.csdnimg.cn/e6927c9c1bc443c6b02d6352e3399664.png" alt="两个实现类"></p>
<h3 id="4-4-1-debug-发现支持的媒体类型"><a href="#4-4-1-debug-发现支持的媒体类型" class="headerlink" title="4.4.1 debug 发现支持的媒体类型"></a>4.4.1 debug 发现支持的媒体类型</h3><p>发现在使用getForEntity()的时候，走到这里是false，因此没有指定返回值的类型<br><img src="https://img-blog.csdnimg.cn/0d970c9b6b524a30b58c069d25b7831f.png"><br>而正常正确的应该是这样</p>
<p><img src="https://img-blog.csdnimg.cn/0883ff19327b418291e7fe957edbaeba.png"></p>
<h3 id="4-4-2回去看参数是否正确"><a href="#4-4-2回去看参数是否正确" class="headerlink" title="4.4.2回去看参数是否正确"></a>4.4.2回去看参数是否正确</h3><p>发现这里给responseType指定为了null，那么问题来了，为什么参数写错了但是没提示？</p>
<p><img src="https://img-blog.csdnimg.cn/4696156abb0744b7a0fd8accd3786a96.png"><br><strong>这是因为最后最后一个形参是<code>Object... uriVariables</code>，这种形参放在最后一位就支持这种很多逗号的写法</strong></p>
<h2 id="4-5修改参数"><a href="#4-5修改参数" class="headerlink" title="4.5修改参数"></a>4.5修改参数</h2><p><img src="https://img-blog.csdnimg.cn/9aae1ca4f8df43b1aee39106e1e3707b.png"></p>
<p>然后就跑通了</p>
<h2 id="4-6结论"><a href="#4-6结论" class="headerlink" title="4.6结论"></a>4.6结论</h2><p>其实这两个方法本质只有“是否携带请求参数”的区别，其他的所有东西都一样，执行的过程一样，返回值一样，返回值的使用方式一样。<br>唯一值得需要注意的是，<strong>以后遇到这种最后一个形参是<code>Object... uriVariables</code>的，就要对形参的个数比较敏感一点</strong></p>

      
       <hr><span style="font-style: italic;color: gray;"> 生命以负熵为食，归整以抵抗熵增； </span>
    </div>
</article>







    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2021 ZJH
</p>
<p class="footer-entry">"生命以负熵为食"

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
