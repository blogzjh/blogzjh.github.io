<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>RestTemlate源码分析及工具类设计 | ZJH&#39;blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="先说个大概的结构：  RestTemlate的所有方法最终调用的是doExecute()，层层向外封装 其中exchange()适合用来封装成工具类，他的返回值是ResponseEntity postForObject()  和  postForEntity本质上一样，只是后者对运行结果进行了封装，返回的也是ResponseEntity，类似于lambda表达式中的Option类  1.本文的源码">
<meta property="og:type" content="article">
<meta property="og:title" content="RestTemlate源码分析及工具类设计">
<meta property="og:url" content="https://blogzjh.github.io/2022/08/03/RestTemlate%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="ZJH&#39;blog">
<meta property="og:description" content="先说个大概的结构：  RestTemlate的所有方法最终调用的是doExecute()，层层向外封装 其中exchange()适合用来封装成工具类，他的返回值是ResponseEntity postForObject()  和  postForEntity本质上一样，只是后者对运行结果进行了封装，返回的也是ResponseEntity，类似于lambda表达式中的Option类  1.本文的源码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ff77b26b03a846c0a63c5ab067ca1c2a.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1134d9e8c5ba48ca8c789762e64b3932.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/cbb84d0aeee54c4a8d206a7ca16c84d2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d5474ff09bc943b5afb10948902e1965.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/f65367f397be4f47aa015251311c2ac0.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/cd139059659d4120a31725ab5fd0f4af.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4617c2b5c4f342e8b090be01ea87b37e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8b3bff8efafa410ca33c7e9971af2d95.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e3d76f4b94734da3919f2f0ba4cceef4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0bb36eb745b948838436c3474fe09222.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/365add9267e14f11bcf45c145c8f4c1f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2692bd692fd5477994460bb07621cbd1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/805cd29b3f874c5db1447b8403cc378b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4b0a8113b4814064af683d591efa2f3e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/466841ea1eb54688a58f13f5a91da1c6.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2aaa7850f1574bdaaa2e86b11e302dc2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/f4d74fc424e2449ab72a25e7dd853729.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/cd8896e0622c45e48e6e2b73d9a86778.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5e4711f12bab4fc5971de022cbf8a823.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ec598eb6550f4dc2a2cc44e9a2a37423.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/c966fb07a8c34b6685ce62f58bc03d81.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/6fef8e3477fc4c51a64dba0f2ea602ad.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/bc1f4bfe85644f90a190de7c7b214726.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1e0853997c16464c8753fd8b296bd15d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/f226121a4b514ef7afcc5be894fa83f9.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/717c0b61574448ee96c3aa0bf051d3aa.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d072a85dd9694ea59111d2f50aa6a542.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ea860a58bf7d43f5bf0ae992610ed1c7.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e6927c9c1bc443c6b02d6352e3399664.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0d970c9b6b524a30b58c069d25b7831f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0883ff19327b418291e7fe957edbaeba.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4696156abb0744b7a0fd8accd3786a96.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9aae1ca4f8df43b1aee39106e1e3707b.png">
<meta property="article:published_time" content="2022-08-03T13:51:57.000Z">
<meta property="article:modified_time" content="2022-08-03T14:18:25.319Z">
<meta property="article:author" content="ZJH&#39;blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/ff77b26b03a846c0a63c5ab067ca1c2a.png">
  
    <link rel="alternate" href="/atom.xml" title="ZJH&#39;blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ZJH&#39;blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blogzjh.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-RestTemlate源码分析及工具类设计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/03/RestTemlate%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2022-08-03T13:51:57.000Z" itemprop="datePublished">2022-08-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      RestTemlate源码分析及工具类设计
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先说个大概的结构：</p>
<ul>
<li>RestTemlate的所有方法最终调用的是<code>doExecute()</code>，层层向外封装</li>
<li>其中<code>exchange()</code>适合用来封装成工具类，他的返回值是ResponseEntity</li>
<li><code>postForObject()</code>  和 <code> postForEntity</code>本质上一样，只是<code>后者</code>对运行结果进行了封装，返回的也是ResponseEntity，类似于lambda表达式中的Option类</li>
</ul>
<p>1.本文的源码分析部分采用“从外到内”的顺序进行分析<br>2.类似postForObject和getForObject这种的区别仅仅是GET请求和POST请求的区别，本文仅分析POST请求的<br>3.postFroLocation()方法是返回一个URI，不是本文的重点</p>
<h1 id="1-返回值ResponseEntity有什么用？"><a href="#1-返回值ResponseEntity有什么用？" class="headerlink" title="1.返回值ResponseEntity有什么用？"></a>1.返回值ResponseEntity有什么用？</h1><h2 id="1-1-postForObject-和postForEntity"><a href="#1-1-postForObject-和postForEntity" class="headerlink" title="1.1 postForObject()和postForEntity()"></a>1.1 postForObject()和postForEntity()</h2><p><strong>看源码的注释部分，几乎一致，也就是两个方法基本没有什么区别</strong></p>
<p>其中一个返回值是封装类ResponseEntity</p>
<p><img src="https://img-blog.csdnimg.cn/ff77b26b03a846c0a63c5ab067ca1c2a.png"><br><strong>重要！！：关于提取响应的方式</strong></p>
<p>postForObject：<code>HttpMessageConvertExtractor</code><br>postforEntity：<code>ResponseExtractor</code><br>这两个Extractor类都有一个公共接口<code>extractData</code>，他在execute方法执行的时候被调用，用于获取HTTP响应的数据，只是在实现上，一个只获取响应体，另一个还要额外获取headers和status<br><img src="https://img-blog.csdnimg.cn/1134d9e8c5ba48ca8c789762e64b3932.png" alt="公共接口"></p>
<p><img src="https://img-blog.csdnimg.cn/cbb84d0aeee54c4a8d206a7ca16c84d2.png"></p>
<h2 id="1-2ResponseEntity的重要参数"><a href="#1-2ResponseEntity的重要参数" class="headerlink" title="1.2ResponseEntity的重要参数"></a>1.2ResponseEntity的重要参数</h2><p><strong>既然这个封装类有状态码status，响应头headers，那么一定在某个地方，getForObject没有去指定而getForEntity指定了</strong>（这时候应该猜到是extractData()方法，将在后面讨论）</p>
<p><img src="https://img-blog.csdnimg.cn/d5474ff09bc943b5afb10948902e1965.png" alt="形参"></p>
<p><img src="https://img-blog.csdnimg.cn/f65367f397be4f47aa015251311c2ac0.png" alt="父类"></p>
<h3 id="1-2-1状态码"><a href="#1-2-1状态码" class="headerlink" title="1.2.1状态码"></a>1.2.1状态码</h3><p><img src="https://img-blog.csdnimg.cn/cd139059659d4120a31725ab5fd0f4af.png"></p>
<h3 id="1-2-2-getBody-getHeaders"><a href="#1-2-2-getBody-getHeaders" class="headerlink" title="1.2.2 getBody() getHeaders()"></a>1.2.2 getBody() getHeaders()</h3><p>直接获取上面两个参数，不再赘述</p>
<h2 id="1-3ResponseEntity是如何封装返回值的？"><a href="#1-3ResponseEntity是如何封装返回值的？" class="headerlink" title="1.3ResponseEntity是如何封装返回值的？"></a>1.3ResponseEntity是如何封装返回值的？</h2><h3 id="1-3-1-responseExtrator-extractData-response-提取数据"><a href="#1-3-1-responseExtrator-extractData-response-提取数据" class="headerlink" title="1.3.1 responseExtrator.extractData(response)提取数据"></a>1.3.1 responseExtrator.extractData(response)提取数据</h3><ul>
<li>已知，最终都是调用doExecute()</li>
<li>两个方法到这里的Extractor都是非空的，都是一定要执行，两个执行逻辑不同</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/4617c2b5c4f342e8b090be01ea87b37e.png"></p>
<h3 id="1-3-2extractDatad抽象方法"><a href="#1-3-2extractDatad抽象方法" class="headerlink" title="1.3.2extractDatad抽象方法"></a>1.3.2extractDatad抽象方法</h3><p>这里直接看getForEntity对应的<code>ResponseEntityResponseExtractor</code>，<strong>即封装了status和headers的执行过程</strong></p>
<p><img src="https://img-blog.csdnimg.cn/8b3bff8efafa410ca33c7e9971af2d95.png"><br><strong>因此，只有返回值是Entity的才有headers和status，否则像getForObject这种方法返回的只是一个响应体</strong></p>
<p><img src="https://img-blog.csdnimg.cn/e3d76f4b94734da3919f2f0ba4cceef4.png"></p>
<h3 id="1-3-3公共的extractData-逻辑"><a href="#1-3-3公共的extractData-逻辑" class="headerlink" title="1.3.3公共的extractData()逻辑"></a>1.3.3公共的extractData()逻辑</h3><p>即两个都会调用的，上面那么打红框的，通篇都是只针对了响应体进行操作，没有涉及任何的headers和status</p>
<p><img src="https://img-blog.csdnimg.cn/0bb36eb745b948838436c3474fe09222.png"></p>
<h3 id="1-3-4nonNull检验是否为空"><a href="#1-3-4nonNull检验是否为空" class="headerlink" title="1.3.4nonNull检验是否为空"></a>1.3.4nonNull检验是否为空</h3><p>如果是封装为Entity，那么还要再加一层判断方法<img src="https://img-blog.csdnimg.cn/365add9267e14f11bcf45c145c8f4c1f.png"></p>
<h2 id="1-4小结"><a href="#1-4小结" class="headerlink" title="1.4小结"></a>1.4小结</h2><ul>
<li><p>到此为止我们分析了为什么getForObject()返回的只有响应体，而getForEntity()返回的包括了响应体 响应头  响应状态</p>
</li>
<li><p>而getForEntity()和exchange()返回的都是ResponseEntity对象，因此第二点引出二者的区别</p>
</li>
<li><p>get和post请求只有一个区别，后续会演示如何使用API<img src="https://img-blog.csdnimg.cn/2692bd692fd5477994460bb07621cbd1.png"></p>
</li>
</ul>
<h1 id="2-exchange-和xxxtForEntity"><a href="#2-exchange-和xxxtForEntity" class="headerlink" title="2.exchange()和xxxtForEntity()"></a>2.exchange()和xxxtForEntity()</h1><ul>
<li>可以看出区别就是<code>requestEntity</code>请求参数</li>
<li>至于请求方法method不是主要矛盾</li>
<li>这三个方法，参数所对应的含义如下：<br>第一个：url<br>对于exchange，第二个参数是请求方式自定义<br>第三个：请求体参数，exchange和post有，get没有，<strong>用map或dto或requestEntity封装</strong><br>第四个：返回值类型<br>第五个：路径参数，对应的是@RequestParam和@PathVariable，<strong>使用方式是在url中用{}占位</strong>，类似logger的{}，也类似String.format()中的%s占位，因此Object…uriVariables是一个可变数组</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/805cd29b3f874c5db1447b8403cc378b.png"></p>
<p><img src="https://img-blog.csdnimg.cn/4b0a8113b4814064af683d591efa2f3e.png"></p>
<p>这里找了一个写的比较全的API演示：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012843361/article/details/79893638">参考链接</a></p>
<h2 id="2-1get占位符和可变数组"><a href="#2-1get占位符和可变数组" class="headerlink" title="2.1get占位符和可变数组"></a>2.1get占位符和可变数组</h2><h3 id="2-1-1-RequestParam案例"><a href="#2-1-1-RequestParam案例" class="headerlink" title="2.1.1@RequestParam案例"></a>2.1.1@RequestParam案例</h3><p>请求的接口有两个@RequestParam参数，通过姓名和性别获取图片的一个例子</p>
<pre><code>    ResponseEntity&lt;byte[]&gt; responseEntity =
            restTemplate.getForEntity(&quot;http://localhost:8080/pic/pic1?name=&#123;name&#125;&amp;sex=&#123;sex&#125;&quot;, byte[].class,
                    &quot;名字&quot;, &quot;性别&quot;);
    ServletOutputStream os = response.getOutputStream();
    os.write(responseEntity.getBody());
</code></pre>
<p>当然对于@RequestParam最好的做法是放在最后一个形参中，传一个map，在后面会提到</p>
<h3 id="2-1-2-PathVariable案例"><a href="#2-1-2-PathVariable案例" class="headerlink" title="2.1.2@PathVariable案例"></a>2.1.2@PathVariable案例</h3><p>大同小异</p>
<pre><code> restTemplate.getForEntity(&quot;http://localhost:8080/pic/pic1/&#123;name&#125;/&#123;sex&#125;&quot;, byte[].class,
                    &quot;名字&quot;, &quot;性别&quot;);
</code></pre>
<h2 id="2-2post携带请求体"><a href="#2-2post携带请求体" class="headerlink" title="2.2post携带请求体"></a>2.2post携带请求体</h2><h3 id="2-2-1当本地有dto代码时-直接使用"><a href="#2-2-1当本地有dto代码时-直接使用" class="headerlink" title="2.2.1当本地有dto代码时-直接使用"></a>2.2.1当本地有dto代码时-直接使用</h3><p>当本地有dto代码的时候，第二个形参直接用dto就好</p>
<pre><code>    //当本地有dto的代码时,可以直接用dto来作为第二个请求体形参
    People people = new People();
    people.setAge(22);
    people.setName(&quot;张三&quot;);
    people.setTall(181);
    //最后一个可变数组的形参不用指定
    ResponseEntity&lt;byte[]&gt; res =
            restTemplate.postForEntity(&quot;http://localhost:8080/pic/people/pic1&quot;, people, byte[].class);
    ServletOutputStream os = response.getOutputStream();
    os.write(res.getBody());
</code></pre>
<p>但不一定是任何时候都有这个dto代码，如果没有这个dto代码，去调用其他的服务器，还需要写一个dto吗？不需要</p>
<h3 id="2-2-2-不能使用HashMap"><a href="#2-2-2-不能使用HashMap" class="headerlink" title="2.2.2 不能使用HashMap"></a>2.2.2 不能使用HashMap</h3><p>使用HashMap虽然在语法上没有问题<strong>，但是会导致请求体对应不上去</strong>，被请求的接口收不到请求体参数</p>
<p>例如：</p>
<pre><code>      HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();
    hashMap.put(&quot;name&quot;,&quot;张三&quot;);
    hashMap.put(&quot;age&quot;,&quot;1&quot;);
    hashMap.put(&quot;tall&quot;,&quot;181&quot;);

    //最后一个可变数组的形参不用指定
    ResponseEntity&lt;byte[]&gt; res =
            restTemplate.postForEntity(&quot;http://localhost:8080/pic/people/pic1&quot;, hashMap, byte[].class);
    ServletOutputStream os = response.getOutputStream();
    os.write(res.getBody());
</code></pre>
<h3 id="2-2-3-使用SpringMVC下的map"><a href="#2-2-3-使用SpringMVC下的map" class="headerlink" title="2.2.3 使用SpringMVC下的map"></a>2.2.3 使用SpringMVC下的map</h3><p><code>MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;String, String&gt;();</code></p>
<p><strong>他是org.springframework.util包下的一个Map<br>他兼容了类型匹配，与SpringMVC的适配性很好</strong></p>
<pre><code>    MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;String, String&gt;();
    map.add(&quot;name&quot;,&quot;张三&quot;);
    map.add(&quot;age&quot;,&quot;11&quot;);
    map.add(&quot;tall&quot;,&quot;181&quot;);

    //最后一个可变数组的形参不用指定
    ResponseEntity&lt;byte[]&gt; res =
            restTemplate.postForEntity(&quot;http://localhost:8080/pic/people/pic1&quot;, map, byte[].class);
    ServletOutputStream os = response.getOutputStream();
    os.write(res.getBody());
</code></pre>
<h3 id="2-2-4-同时设置请求体and请求头"><a href="#2-2-4-同时设置请求体and请求头" class="headerlink" title="2.2.4 同时设置请求体and请求头"></a>2.2.4 同时设置请求体and请求头</h3><ul>
<li><p>请求体写在<code>MultiValueMap</code></p>
</li>
<li><p>请求头写在<code>HttpHeaders</code></p>
</li>
<li><p>最终用<code>HttpEntity</code>封装，需要注意泛型的指定就是MultiValueMap</p>
<pre><code>      MultiValueMap&lt;String, String&gt; map = new LinkedMultiValueMap&lt;String, String&gt;();
      map.add(&quot;name&quot;,&quot;张三&quot;);
      map.add(&quot;age&quot;,&quot;11&quot;);
      map.add(&quot;tall&quot;,&quot;181&quot;);

      HttpHeaders httpHeaders = new HttpHeaders();
      //按需求自行添加
  //        httpHeaders.setContentType();
  //        httpHeaders.setExpires();

      //这个Entity包含了请求体 和 请求头
      //泛型的指定即：map的类型
      HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; entity = new HttpEntity&lt;&gt;(map,httpHeaders);

      //最后一个可变数组的形参不用指定
      ResponseEntity&lt;byte[]&gt; res =
              restTemplate.postForEntity(&quot;http://localhost:8080/pic/people/pic1&quot;, entity, byte[].class);
      ServletOutputStream os = response.getOutputStream();
      os.write(res.getBody());
</code></pre>
</li>
</ul>
<h3 id="2-2-5同时请求体-请求参数"><a href="#2-2-5同时请求体-请求参数" class="headerlink" title="2.2.5同时请求体 请求参数"></a>2.2.5同时请求体 请求参数</h3><p>有两种写法，一种是url拼接，利用最后一个参数是可变数组</p>
<pre><code>ResponseEntity&lt;byte[]&gt; res = restTemplate.exchange(&quot;http://localhost:8080/pic/withbody?param1=&#123;param1&#125;&quot;, HttpMethod.POST,
    httpEntity, byte[].class, &quot;请求参数1&quot;
);
</code></pre>
<p>第二种是最后一个参数用一个map</p>
<pre><code>HashMap&lt;String, String&gt; urls = new HashMap&lt;&gt;();
urls.put(&quot;param1&quot;,&quot;测试1&quot;);

ResponseEntity&lt;byte[]&gt; res = restTemplate.exchange(&quot;http://localhost:8080/pic/withbody&quot;, HttpMethod.POST,
    httpEntity, byte[].class, urls
);
</code></pre>
<h1 id="3-工具类"><a href="#3-工具类" class="headerlink" title="3.工具类"></a>3.工具类</h1><ul>
<li>根据公司业务写了一个工具类，可以根据需要，对<code>baseByteTractor</code>和<code>baseJsonTractor</code>进行封装</li>
<li>可根据业务，携带param、body、header请求接口，并可选择是否将其响应数据的header和statusCode写入响应体</li>
<li>工具类没有选择使用Spring Bean，而是使用安全的单例模式，移植性更强</li>
</ul>
<h2 id="3-1完整代码："><a href="#3-1完整代码：" class="headerlink" title="3.1完整代码："></a>3.1完整代码：</h2><pre><code>import java.io.BufferedOutputStream;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.lang.Nullable;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

/**
 * @Description RestTemplate工具类
 * 1.getByte() postByte()是用来下载流的，因此形参必须有HttpResponseBody
 * 2.getJson() postJson()是用来获取json的，形参可以不带response
 * 3.每个方法最后一个形参requireBodyOnly默认true，即只需要响应体，一般建议设为true，
 *     否则可能造成因header自动解析产生的问题
 * 4.post请求可以额外携带请求体
 * 5.可能产生EOFException异常，正常，可以全局捕获日志记录
 * 
 * @Author zjh
 * @Date 17:04 2022/7/28
 **/
public class RestTemplateUtils &#123;

  private static          Logger       logger = LoggerFactory.getLogger(&quot;RestLogger&quot;);
  private volatile static RestTemplate restTemplate;

  /**
   * RestTemplate单例 懒汉 双检锁
   **/
  public static RestTemplate getSingleRestTemplate() &#123;
    if (restTemplate == null) &#123;
      synchronized (RestTemplateUtils.class) &#123;
        if (restTemplate == null) &#123;
          restTemplate = new RestTemplate();
        &#125;
      &#125;
    &#125;
    return restTemplate;
  &#125;


  /**
   * 基础方法，下载文件二进制流到response输出流
   *
   * @param url 不包含请求参数 即 ?param=&#123;&#125;
   * @param method POST或GET
   * @param requestHeaders 请求头，可为空
   * @param requestParams 请求参数，可为空
   * @param requestBody 请求体，可为空
   * @param requireBodyOnly 是否是只需要响应体,默认true，true：只需要响应体  false：同时返回响应状态 响应头  响应体
   * @return void
   **/
  public static void baseByteTractor(String url, HttpMethod method,
      @Nullable Map&lt;String, String&gt; requestHeaders,
      @Nullable Map&lt;String, Object&gt; requestParams,
      @Nullable Map&lt;String, Object&gt; requestBody,
      HttpServletResponse response,
      @Nullable Boolean requireBodyOnly) &#123;
    if (requireBodyOnly == null) &#123;
      requireBodyOnly = true;
    &#125;
    MultiValueMap&lt;String, Object&gt; params  = new LinkedMultiValueMap&lt;String, Object&gt;();
    MultiValueMap&lt;String, Object&gt; body    = new LinkedMultiValueMap&lt;String, Object&gt;();
    HttpHeaders                   headers = new HttpHeaders();

    //1.设置请求参数
    if (requestParams != null &amp;&amp; !requestParams.isEmpty()) &#123;
      Iterator&lt;Entry&lt;String, Object&gt;&gt; paramsIterator = requestParams.entrySet().iterator();
      Entry&lt;String, Object&gt;           nextParam      = null;
      while (paramsIterator.hasNext()) &#123;
        nextParam = paramsIterator.next();
        params.add(nextParam.getKey(), nextParam.getValue());
      &#125;
    &#125;
    //2.设置请求头
    if (requestHeaders != null &amp;&amp; !requestHeaders.isEmpty()) &#123;
      Iterator&lt;Entry&lt;String, String&gt;&gt; headersIterator = requestHeaders.entrySet().iterator();
      Entry&lt;String, String&gt;           nextHeader      = null;
      while (headersIterator.hasNext()) &#123;
        nextHeader = headersIterator.next();
        headers.add(nextHeader.getKey(), nextHeader.getValue());
      &#125;
    &#125;
    //3.设置请求体
    if (requestBody != null &amp;&amp; !requestBody.isEmpty()) &#123;
      Iterator&lt;Entry&lt;String, Object&gt;&gt; bodyIterator = requestBody.entrySet().iterator();
      Entry&lt;String, Object&gt;           bodyNext     = null;
      while (bodyIterator.hasNext()) &#123;
        bodyNext = bodyIterator.next();
        body.add(bodyNext.getKey(), bodyNext.getValue());
      &#125;
    &#125;
    //4.请求体 请求头封装到HttpEntity
    HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(body, headers);
    //5.执行
    RestTemplate         restTemplate = getSingleRestTemplate();
    BufferedOutputStream bos          = null;
    try &#123;
      ResponseEntity&lt;byte[]&gt; exchange = restTemplate.exchange(url, method, entity, byte[].class, params);
      if (!requireBodyOnly &amp;&amp; response != null) &#123;
        //响应状态码
        response.setStatus(exchange.getStatusCodeValue());
        //响应头,可能存在一个key对应多个value,本方法中会将同名header合并
        HttpHeaders                           resHeaders         = exchange.getHeaders();
        Iterator&lt;Entry&lt;String, List&lt;String&gt;&gt;&gt; resHeadersIterator = resHeaders.entrySet().iterator();
        while (resHeadersIterator.hasNext()) &#123;
          Entry&lt;String, List&lt;String&gt;&gt; headersNext = resHeadersIterator.next();
          response.setHeader(headersNext.getKey(), headersNext.getValue().toString());
        &#125;
      &#125;
      //响应体
      ServletOutputStream os = response.getOutputStream();
      bos = new BufferedOutputStream(os);
      byte[] buf = exchange.getBody();
      bos.write(buf);
      bos.flush();
    &#125; catch (IOException e) &#123;
      logger.error(&quot;RestTemplateUtils获取接口二进制流异常&quot;);
    &#125; catch (RestClientException e) &#123;
      logger.error(&quot;远程调用接口异常&#123;&#125;&quot;, e);
    &#125; finally &#123;
      try &#123;
        bos.close();
      &#125; catch (IOException e) &#123;
        logger.error(&quot;RestTemplateUtils流关闭异常&quot;);
      &#125;
    &#125;
  &#125;

  /**
   * 基础方法，请求接口，返回JSON
   *
   * @param url 不包含请求参数 即 ?param=&#123;&#125;
   * @param method POST或GET
   * @param requestHeaders 请求头，可为空
   * @param requestParams 请求参数，可为空
   * @param requestBody 请求体，可为空
   * @param requireBodyOnly 是否是只需要响应体,默认true，true：只需要响应体  false：同时返回响应状态 响应头  响应体
   * @return String Json
   **/
  public static String baseJsonTracktor(String url, HttpMethod method,
      @Nullable Map&lt;String, String&gt; requestHeaders,
      @Nullable Map&lt;String, Object&gt; requestParams,
      @Nullable Map&lt;String, Object&gt; requestBody,
      @Nullable HttpServletResponse response,
      @Nullable Boolean requireBodyOnly) &#123;
    if (requireBodyOnly == null) &#123;
      requireBodyOnly = true;
    &#125;
    MultiValueMap&lt;String, Object&gt; params  = new LinkedMultiValueMap&lt;String, Object&gt;();
    MultiValueMap&lt;String, Object&gt; body    = new LinkedMultiValueMap&lt;String, Object&gt;();
    HttpHeaders                   headers = new HttpHeaders();

    //1.设置请求参数
    if (requestParams != null &amp;&amp; !requestParams.isEmpty()) &#123;
      Iterator&lt;Entry&lt;String, Object&gt;&gt; paramsIterator = requestParams.entrySet().iterator();
      Entry&lt;String, Object&gt;           nextParam      = null;
      while (paramsIterator.hasNext()) &#123;
        nextParam = paramsIterator.next();
        params.add(nextParam.getKey(), nextParam.getValue());
      &#125;
    &#125;
    //2.设置请求头
    if (requestHeaders != null &amp;&amp; !requestHeaders.isEmpty()) &#123;
      Iterator&lt;Entry&lt;String, String&gt;&gt; headersIterator = requestHeaders.entrySet().iterator();
      Entry&lt;String, String&gt;           nextHeader      = null;
      while (headersIterator.hasNext()) &#123;
        nextHeader = headersIterator.next();
        headers.add(nextHeader.getKey(), nextHeader.getValue());
      &#125;
    &#125;
    //3.设置请求体
    if (requestBody != null &amp;&amp; !requestBody.isEmpty()) &#123;
      Iterator&lt;Entry&lt;String, Object&gt;&gt; bodyIterator = requestBody.entrySet().iterator();
      Entry&lt;String, Object&gt;           bodyNext     = null;
      while (bodyIterator.hasNext()) &#123;
        bodyNext = bodyIterator.next();
        body.add(bodyNext.getKey(), bodyNext.getValue());
      &#125;
    &#125;
    //4.请求体 请求头封装到HttpEntity
    HttpEntity&lt;MultiValueMap&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(body, headers);
    //5.执行
    RestTemplate restTemplate = getSingleRestTemplate();
    String       bodyJson     = &quot;&quot;;
    try &#123;
      ResponseEntity&lt;String&gt; exchange = restTemplate.exchange(url, method, entity, String.class, params);
      if (!requireBodyOnly &amp;&amp; response != null) &#123;
        //响应状态码
        response.setStatus(exchange.getStatusCodeValue());
        //响应头,可能存在一个key对应多个value,本方法中会将同名header合并
        HttpHeaders                           resHeaders         = exchange.getHeaders();
        Iterator&lt;Entry&lt;String, List&lt;String&gt;&gt;&gt; resHeadersIterator = resHeaders.entrySet().iterator();
        while (resHeadersIterator.hasNext()) &#123;
          Entry&lt;String, List&lt;String&gt;&gt; headersNext = resHeadersIterator.next();
          response.setHeader(headersNext.getKey(), headersNext.getValue().toString());
        &#125;
      &#125;
      bodyJson = exchange.getBody();
    &#125; catch (RestClientException e) &#123;
      logger.error(&quot;远程调用接口异常&#123;&#125;&quot;, e);
    &#125;
    return bodyJson;
  &#125;

  /**
   * GET请求 下载流
   *
   * @param url 不包含请求参数 即 ?param=&#123;&#125;
   * @param requestParams 请求参数，可为空
   * @param requireBodyOnly 是否是只需要响应体,默认true，true：只需要响应体  false：同时返回响应状态 响应头  响应体
   * @return void
   **/
  public static void getByte(String url, HttpServletResponse response,
      @Nullable Map&lt;String, Object&gt; requestParams,
      @Nullable Boolean requireBodyOnly) &#123;
    if (requireBodyOnly == null) &#123;
      requireBodyOnly = true;
    &#125;
    baseByteTractor(url, HttpMethod.GET, null, requestParams, null, response, requireBodyOnly);
  &#125;


  /**
   * POST请求 下载流
   *
   * @param url 不包含请求参数 即 ?param=&#123;&#125;
   * @param requestParams 请求参数，可为空
   * @param requestBody 请求体，可为空
   * @param requireBodyOnly 是否是只需要响应体,默认true，true：只需要响应体  false：同时返回响应状态 响应头  响应体
   * @return void
   **/
  public static void postByte(String url, HttpServletResponse response,
      @Nullable Map&lt;String, Object&gt; requestParams,
      @Nullable Map&lt;String, Object&gt; requestBody,
      @Nullable Boolean requireBodyOnly) &#123;
    if (requireBodyOnly == null) &#123;
      requireBodyOnly = true;
    &#125;
    baseByteTractor(url, HttpMethod.POST, null, requestParams, requestBody, response, requireBodyOnly);
  &#125;


  /**
   * GET请求 获取JSON
   *
   * @param url 不包含请求参数 即 ?param=&#123;&#125;
   * @param requestParams 请求参数，可为空
   * @param requireBodyOnly 是否是只需要响应体,默认true，true：只需要响应体  false：同时返回响应状态 响应头  响应体
   * @return void
   **/
  public static String getJson(String url,
      @Nullable HttpServletResponse response,
      @Nullable Map&lt;String, Object&gt; requestParams,
      @Nullable Boolean requireBodyOnly) &#123;
    if (requireBodyOnly == null) &#123;
      requireBodyOnly = true;
    &#125;
    String resJson = baseJsonTracktor(url, HttpMethod.GET, null, requestParams, null, response, requireBodyOnly);
    return resJson;
  &#125;


  /**
   * POST请求 获取JSON
   *
   * @param url 不包含请求参数 即 ?param=&#123;&#125;
   * @param requestParams 请求参数，可为空
   * @param requestBody 请求体，可为空
   * @param requireBodyOnly 是否是只需要响应体,默认true，true：只需要响应体  false：同时返回响应状态 响应头  响应体
   * @return void
   **/
  public static String postJson(String url,
      @Nullable HttpServletResponse response,
      @Nullable Map&lt;String, Object&gt; requestParams,
      @Nullable Map&lt;String, Object&gt; requestBody,
      @Nullable Boolean requireBodyOnly) &#123;
    if (requireBodyOnly == null) &#123;
      requireBodyOnly = true;
    &#125;
    String resJson = baseJsonTracktor(url, HttpMethod.POST, null, requestParams, requestBody, response, requireBodyOnly);
    return resJson;
  &#125;


&#125;
</code></pre>
<h2 id="3-2演示"><a href="#3-2演示" class="headerlink" title="3.2演示"></a>3.2演示</h2><p><img src="https://img-blog.csdnimg.cn/466841ea1eb54688a58f13f5a91da1c6.png" alt="BYTE"><br><img src="https://img-blog.csdnimg.cn/2aaa7850f1574bdaaa2e86b11e302dc2.png" alt="JSON"></p>
<h1 id="4-小插曲"><a href="#4-小插曲" class="headerlink" title="4.小插曲"></a>4.小插曲</h1><p>在决定写下这篇文章之前，其实是在解决一个业务需求时碰到的问题，问题很简单，粗心导致的，但是反正都已经debug看了分析了源码了，所以干脆写下了上面的源码分析文章和工具类。。。</p>
<h2 id="4-1环境模拟"><a href="#4-1环境模拟" class="headerlink" title="4.1环境模拟"></a>4.1环境模拟</h2><h3 id="4-1-2接口提供"><a href="#4-1-2接口提供" class="headerlink" title="4.1.2接口提供"></a>4.1.2接口提供</h3><p>提供一个接口，设置一个请求头给response，把图片二进制流写入response</p>
<pre><code>@GetMapping(&quot;/pic1&quot;)
public void getPic(HttpServletRequest request,HttpServletResponse response) throws IOException &#123;
    response.setHeader(&quot;keyy&quot;,&quot;valuee&quot;);
    System.out.println(response.getHeader(&quot;keyy&quot;));
    File file = new File(&quot;C:\\Users\\zhangjiahao\\Desktop\\图片.jpg&quot;);
    FileInputStream fis = new FileInputStream(file);
    BufferedInputStream bis = new BufferedInputStream(fis);
    byte[] buf = new byte[2048];
    ServletOutputStream os = response.getOutputStream();
    BufferedOutputStream bos = new BufferedOutputStream(os);
    while(bis.read(buf) != -1)&#123;
        bos.write(buf);
    &#125;
    bos.flush();
    bos.close();
    bis.close();
   &#125;
</code></pre>
<h2 id="4-2源码分析思路"><a href="#4-2源码分析思路" class="headerlink" title="4.2源码分析思路"></a>4.2源码分析思路</h2><h3 id="4-2-1方法本身区别"><a href="#4-2-1方法本身区别" class="headerlink" title="4.2.1方法本身区别"></a>4.2.1方法本身区别</h3><p><strong>调用exchange()的时候，内部调用的方法是需要携带请求参数的，不过可以设为null</strong></p>
<p><img src="https://img-blog.csdnimg.cn/f4d74fc424e2449ab72a25e7dd853729.png" alt="getForEntity"><br><img src="https://img-blog.csdnimg.cn/cd8896e0622c45e48e6e2b73d9a86778.png" alt="exchange"><br>两个方法本身的区别就是：<code>requestEntity</code>，即请求参数</p>
<h3 id="4-2-2分别看两个内部的方法"><a href="#4-2-2分别看两个内部的方法" class="headerlink" title="4.2.2分别看两个内部的方法"></a>4.2.2分别看两个内部的方法</h3><h3 id="4-2-2-1-exchange-带参的：httpEntityCallback"><a href="#4-2-2-1-exchange-带参的：httpEntityCallback" class="headerlink" title="4.2.2.1 exchange-带参的：httpEntityCallback"></a>4.2.2.1 exchange-带参的：httpEntityCallback</h3><p><img src="https://img-blog.csdnimg.cn/5e4711f12bab4fc5971de022cbf8a823.png"></p>
<p>到目前为止没有看到对返回值response进行操作的内容<br><img src="https://img-blog.csdnimg.cn/ec598eb6550f4dc2a2cc44e9a2a37423.png"></p>
<h3 id="4-2-2-2getFroEntity-无参：acceptHeaderRequestCallback"><a href="#4-2-2-2getFroEntity-无参：acceptHeaderRequestCallback" class="headerlink" title="4.2.2.2getFroEntity-无参：acceptHeaderRequestCallback"></a>4.2.2.2getFroEntity-无参：acceptHeaderRequestCallback</h3><p><img src="https://img-blog.csdnimg.cn/c966fb07a8c34b6685ce62f58bc03d81.png"><br><img src="https://img-blog.csdnimg.cn/6fef8e3477fc4c51a64dba0f2ea602ad.png"></p>
<h2 id="4-3到此没有分析出异常，则看request回调相关的execute"><a href="#4-3到此没有分析出异常，则看request回调相关的execute" class="headerlink" title="4.3到此没有分析出异常，则看request回调相关的execute"></a>4.3到此没有分析出异常，则看request回调相关的execute</h2><h3 id="4-3-1分析理由"><a href="#4-3-1分析理由" class="headerlink" title="4.3.1分析理由"></a>4.3.1分析理由</h3><p>因为两个方法的区别就是在于回调<code>RequestCallback</code>，本身分析不出来问题，就去找其他<code>RequestCallback</code>相关的即<code>execute()</code>执行方法本身<img src="https://img-blog.csdnimg.cn/bc1f4bfe85644f90a190de7c7b214726.png"></p>
<h3 id="4-3-2doExecute"><a href="#4-3-2doExecute" class="headerlink" title="4.3.2doExecute()"></a>4.3.2doExecute()</h3><p>doWithRequest()对于这两个方法来说，其实都是会执行的</p>
<p><img src="https://img-blog.csdnimg.cn/1e0853997c16464c8753fd8b296bd15d.png"><br>debug的时候能正常进去</p>
<p><img src="https://img-blog.csdnimg.cn/f226121a4b514ef7afcc5be894fa83f9.png"></p>
<p>虽然这里没有指定requestEntity</p>
<p><img src="https://img-blog.csdnimg.cn/717c0b61574448ee96c3aa0bf051d3aa.png">但是内部造了一个requestCallBack，和requestEntity没有关系</p>
<p><img src="https://img-blog.csdnimg.cn/d072a85dd9694ea59111d2f50aa6a542.png"></p>
<h2 id="4-4定位到doWithRequest（）"><a href="#4-4定位到doWithRequest（）" class="headerlink" title="4.4定位到doWithRequest（）"></a>4.4定位到doWithRequest（）</h2><p><img src="https://img-blog.csdnimg.cn/ea860a58bf7d43f5bf0ae992610ed1c7.png"></p>
<p>这两个实现类其实是父子类关系，都会调用（内部用的super）<img src="https://img-blog.csdnimg.cn/e6927c9c1bc443c6b02d6352e3399664.png" alt="两个实现类"></p>
<h3 id="4-4-1-debug-发现支持的媒体类型"><a href="#4-4-1-debug-发现支持的媒体类型" class="headerlink" title="4.4.1 debug 发现支持的媒体类型"></a>4.4.1 debug 发现支持的媒体类型</h3><p>发现在使用getForEntity()的时候，走到这里是false，因此没有指定返回值的类型<br><img src="https://img-blog.csdnimg.cn/0d970c9b6b524a30b58c069d25b7831f.png"><br>而正常正确的应该是这样</p>
<p><img src="https://img-blog.csdnimg.cn/0883ff19327b418291e7fe957edbaeba.png"></p>
<h3 id="4-4-2回去看参数是否正确"><a href="#4-4-2回去看参数是否正确" class="headerlink" title="4.4.2回去看参数是否正确"></a>4.4.2回去看参数是否正确</h3><p>发现这里给responseType指定为了null，那么问题来了，为什么参数写错了但是没提示？</p>
<p><img src="https://img-blog.csdnimg.cn/4696156abb0744b7a0fd8accd3786a96.png"><br><strong>这是因为最后最后一个形参是<code>Object... uriVariables</code>，这种形参放在最后一位就支持这种很多逗号的写法</strong></p>
<h2 id="4-5修改参数"><a href="#4-5修改参数" class="headerlink" title="4.5修改参数"></a>4.5修改参数</h2><p><img src="https://img-blog.csdnimg.cn/9aae1ca4f8df43b1aee39106e1e3707b.png"></p>
<p>然后就跑通了</p>
<h2 id="4-6结论"><a href="#4-6结论" class="headerlink" title="4.6结论"></a>4.6结论</h2><p>其实这两个方法本质只有“是否携带请求参数”的区别，其他的所有东西都一样，执行的过程一样，返回值一样，返回值的使用方式一样。<br>唯一值得需要注意的是，<strong>以后遇到这种最后一个形参是<code>Object... uriVariables</code>的，就要对形参的个数比较敏感一点</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/08/03/RestTemlate%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%AE%BE%E8%AE%A1/" data-id="cl8wv0v20001b1gta2898boyi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/08/03/%E5%8F%8D%E5%B0%84%E4%BF%AE%E6%94%B9jsessionid%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          反射修改jsessionid实现session共享
        
      </div>
    </a>
  
  
    <a href="/2022/08/03/%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1%E8%A2%AB%E6%94%BB%E5%87%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">短信服务被攻击解决方案</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/">数据结构算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/26/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%81%9A%E9%BB%91%E5%90%8D%E5%8D%95%E7%9A%84%E6%96%B9%E6%A1%88/">布隆过滤做黑名单的方案</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E6%9F%90%E8%9A%81%E9%87%91%E6%9C%8D%E7%A7%8B%E6%8B%9B9-15/">某蚁金服秋招9-15</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">三种情况的层序遍历</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E5%87%A0%E9%81%93%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98-dfs-%E5%89%AA%E6%9E%9D-%E5%9B%9E%E6%BA%AF/">几道岛屿问题:dfs+剪枝+回溯</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%E6%9B%BF%E6%8D%A2%E3%80%81%E5%B7%A6%E6%97%8B%E3%80%81%E7%BC%BA%E5%A4%B1/">字符串：替换、左旋、缺失</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 ZJH&#39;blog<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>