<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>ReentrantLock源码剖析 | 张家豪的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.源码分析总结这里把结论提前放这里：  AQS是一个抽象类，包含了Node（用于维护同步队列）、ConditionObject（也用Node维护了等待队列，给ReentrantLock提供更高的自由度，可由reentrantLock.newCondition()创建） CAS（乐观锁的一种实现，本身与自旋锁无关）是通过比较属性的offset偏移量来实现原子性操作，一般配合while()或者for">
<meta property="og:type" content="article">
<meta property="og:title" content="ReentrantLock源码剖析">
<meta property="og:url" content="https://blogzjh.github.io/2022/08/23/ReentrantLock%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/index.html">
<meta property="og:site_name" content="张家豪的博客">
<meta property="og:description" content="1.源码分析总结这里把结论提前放这里：  AQS是一个抽象类，包含了Node（用于维护同步队列）、ConditionObject（也用Node维护了等待队列，给ReentrantLock提供更高的自由度，可由reentrantLock.newCondition()创建） CAS（乐观锁的一种实现，本身与自旋锁无关）是通过比较属性的offset偏移量来实现原子性操作，一般配合while()或者for">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0cd0d31e4b724f7e904b697d3b60b078.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e9763c7896d04f1ea70a3942dd8fd362.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ea516a10a19841f38dfbb596b016b811.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/3fe9366cb11b4edd9cf9959f9b920b76.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/c2e3dcc3d8e54a3cbae3b4a095bf2ef2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/3c939cf2b4f64e17acefbd3e32265ada.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/14818daac6ab453db15015500855457e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/bb371c8836d3439ca8a50ef0a8cb49d1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e689244922b74bc78c1ea1f3b7078c86.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/ec889af94870461fa875bdf58e623e68.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d69c0f216eec422dbd082c8e1129e98f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d51949a4212f41cd849f9167892a7cb7.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/c60fee28abec4502a7bc429f25714225.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/f5180873882741ad807cebbd357dfc9e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0825b54af554421fa85c78d915261cdc.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4fdc7bd52bdd41299be58193331ad315.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/769e9e42e82c4304b436c8b67f04c3a5.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/324ebc43c92341f6a847b93fac89c18e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/38aab27ea2c04426a9a069387f177f80.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/f79e1caf91134c56b13c2ec01bcc3a7d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/35af5a50c9ab4980b9488627d109a45e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/14818daac6ab453db15015500855457e.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/8336b084e785433daaa749fcffa107b1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/d131da198363458e9d4513e4344cd522.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/087978696280470f977253c723f770a7.png">
<meta property="article:published_time" content="2022-08-23T04:34:15.000Z">
<meta property="article:modified_time" content="2022-08-23T04:46:49.502Z">
<meta property="article:author" content="张家豪">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/0cd0d31e4b724f7e904b697d3b60b078.png">
  
    <link rel="alternate" href="/atom.xml" title="张家豪的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">张家豪的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blogzjh.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ReentrantLock源码剖析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/23/ReentrantLock%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="article-date">
  <time datetime="2022-08-23T04:34:15.000Z" itemprop="datePublished">2022-08-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ReentrantLock源码剖析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-源码分析总结"><a href="#1-源码分析总结" class="headerlink" title="1.源码分析总结"></a>1.源码分析总结</h1><p>这里把结论提前放这里：</p>
<ul>
<li>AQS是一个抽象类，包含了Node（用于维护<strong>同步队列</strong>）、ConditionObject（也用Node维护了<strong>等待队列</strong>，给ReentrantLock提供更高的自由度，可由<code>reentrantLock.newCondition()</code>创建）</li>
<li>CAS（乐观锁的一种实现，本身与自旋锁无关）是通过比较属性的<code>offset</code>偏移量来实现原子性操作，一般<strong>配合while()或者for(;;)实现自旋锁</strong>，如果只是想尝试一次获取锁，那么就不需要循环，只需要保证原子性即可</li>
<li>自旋锁只是不停尝试，真正执行语句的原子性需要CAS保证，<strong>自旋锁也一般配合阻塞实现</strong></li>
<li>公平锁和非公平锁<strong>都用Node维护了2个双端队列</strong>，不过只有公平锁在争锁的时候会先<strong>判断是不是队列的头节点</strong>，一旦进入队列仍然是有序的</li>
<li><code> reentrantLock.lock()</code>和<code>condition.await()</code>底层都同时做了两件事：将节点放入队列、在<code>for(;;)</code>自旋锁中调用<code>LockSupport.park()</code>来阻塞线程，<strong>暂停自旋,防止消耗cpu资源</strong>，有且仅有同步队列的第二个节点在自旋</li>
<li> <code> reentrantLock.unlock()</code>和<code>condition.signal()</code>底层都同时做了两件事：从自己维护的队列中取出头节点（即便是非公平锁也是取头节点）、底层调用<code>LockSupport.park()</code>来唤醒对应的线程</li>
<li>由此可见，<strong>ReentrantLock的非公平锁并不是真正意义上的非公平，他只是在第一次获取锁的时候非公平，一旦进入同步队列，还是得乖乖排队</strong></li>
<li>源码中大量使用了if( &amp;&amp; ) 的短路功能，来简化代码</li>
<li>关于<code>LockSupport.park()</code>，底层就是阻塞线程，lock失败、awiat都用到了他。同理unpark在unlock和signal中被使用，用于唤醒指定线程（唤醒等待队列的头节点）</li>
<li>关于<strong>同步队列与等待队列</strong>，其实<code>lock和unlock操作的是同步队列</code>（即使源码注释只提到了等待队列），而awati和signal分别是“<code>将同步队列节点移到等待队列</code>”，“<code>将等待列队节点移到同步队列</code>”————在第6点中细讲</li>
</ul>
<h1 id="2-ReentrantLock大体思路"><a href="#2-ReentrantLock大体思路" class="headerlink" title="2.ReentrantLock大体思路"></a>2.ReentrantLock大体思路</h1><ul>
<li>已知 lock()在没有抢到锁的时候会导致线程阻塞，那么可以猜测相关的线程挂起逻辑是<code>while(true) for(;;) </code>自旋 +<code> park()</code>阻塞，等待别人<code>unpark()</code>唤醒后继续自旋</li>
<li>Java中调用CAS(<strong>乐观锁，底层是原子操作</strong>)是在Usafe类下的native方法，而这个<code>state</code>的值在CAS锁机制下使用的参数是<code>stateOffset</code>偏移量，效果相同，例如<code>unsafe.objectFieldOffset</code>获取偏移量，然后<code>usafe.compareAndSwapInt</code>执行原子指令</li>
<li>利用形如<code>while( !unsafe.compareAndSwapInt(this, stateOffset, 0 ,1 ))</code>来实现自旋锁，直到加到锁，其中原子性是由CAS（一种乐观锁实现）来保证的</li>
</ul>
<h2 id="2-1CAS实现一个简单的自旋锁"><a href="#2-1CAS实现一个简单的自旋锁" class="headerlink" title="2.1CAS实现一个简单的自旋锁"></a>2.1CAS实现一个简单的自旋锁</h2><ul>
<li>用while + cas 可以实现一个<strong>自旋锁</strong>（自旋的思想就是不停重试）</li>
<li>但是一直while很消耗cpu资源</li>
<li>因此，<strong>我们不能让所有等待线程都while，在源码中使用park进行阻塞自旋</strong><h3 id="2-1-1-Unsafe类的使用demo"><a href="#2-1-1-Unsafe类的使用demo" class="headerlink" title="2.1.1 Unsafe类的使用demo"></a>2.1.1 Unsafe类的使用demo</h3></li>
</ul>
<pre><code>public class AQSTest &#123;

  public static void main(String[] args) &#123;

    AQSTest aqsTest = new AQSTest();
    aqsTest.test();

  &#125;


  public void test()&#123;
    System.out.println(state);//0
    Unsafe unsafe = getUnsafe();
    boolean b     = unsafe.compareAndSwapInt(this, stateOffset, 0, 1);
    System.out.println(state);//1
  &#125;

  
  private volatile int state = 0;//状态0则没加锁，volatile防止指令重排
  private static final Unsafe unsafe = getUnsafe();//import sun.misc.Unsafe;
  //偏移量，即在计算机中定位到state的位置，以便于原子操作
  private static Long stateOffset;

  //用静态代码块捕获异常，如果直接定义private static Long stateOffset =
  // unsafe.objectFieldOffset(AQSTest.class.getDeclaredField(&quot;state&quot;));
  //那么则会在空参构造上抛出异常
  static &#123;
    try &#123;
      stateOffset = unsafe.objectFieldOffset(AQSTest.class.getDeclaredField(&quot;state&quot;));
    &#125; catch (NoSuchFieldException e) &#123;
      e.printStackTrace();
    &#125;
  &#125;

  //获取unsafe对象
  private static Unsafe getUnsafe()&#123;
    try &#123;
      Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
      field.setAccessible(true);
      return (Unsafe) field.get(null);
    &#125; catch (NoSuchFieldException e) &#123;
      e.printStackTrace();
    &#125; catch (IllegalAccessException e) &#123;
      e.printStackTrace();
    &#125;
    return null;
  &#125;

&#125;
</code></pre>
<h3 id="2-1-2lock和unlock"><a href="#2-1-2lock和unlock" class="headerlink" title="2.1.2lock和unlock"></a>2.1.2lock和unlock</h3><p>加锁解锁方法:</p>
<pre><code>  public void lock()&#123;
    Unsafe unsafe = getUnsafe();
    while ( !unsafe.compareAndSwapInt(this,stateOffset,0,1) )&#123;
      System.out.println(Thread.currentThread().getName() + &quot;尝试获取锁&quot;);
      try &#123;
        TimeUnit.SECONDS.sleep(1);
      &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
      &#125;
    &#125;
    System.out.println(Thread.currentThread().getName() + &quot;获取锁成功&quot;);
  &#125;

  public void unlock()&#123;
    Unsafe unsafe = getUnsafe();
    boolean flag     = unsafe.compareAndSwapInt(this, stateOffset, 1, 0);
    if(flag)&#123;
      System.out.println(&quot;解锁成功&quot;);
    &#125;
  &#125;
</code></pre>
<h3 id="2-1-3两个线程测试"><a href="#2-1-3两个线程测试" class="headerlink" title="2.1.3两个线程测试"></a>2.1.3两个线程测试</h3><p>main中开启两个线程：</p>
<pre><code>AQSTest t = new AQSTest();


new Thread(()-&gt;&#123;
  System.out.println(&quot;线程1开始,上锁&quot;);
  t.lock();
  try &#123;
    TimeUnit.SECONDS.sleep(3);
  &#125; catch (InterruptedException e) &#123;
    e.printStackTrace();
  &#125;
  //3秒后释放锁
  t.unlock();
&#125;,&quot;线程1&quot;).start();


new Thread(()-&gt;&#123;
  System.out.println(&quot;线程2开始&quot;);
  t.lock();
  t.unlock();
&#125;,&quot;线程2&quot;).start();
</code></pre>
<p>输出：</p>
<p><img src="https://img-blog.csdnimg.cn/0cd0d31e4b724f7e904b697d3b60b078.png"></p>
<h1 id="3-AQS下的两个类"><a href="#3-AQS下的两个类" class="headerlink" title="3.AQS下的两个类"></a>3.AQS下的两个类</h1><p><img src="https://img-blog.csdnimg.cn/e9763c7896d04f1ea70a3942dd8fd362.png"></p>
<h2 id="3-1Node节点（双端队列）"><a href="#3-1Node节点（双端队列）" class="headerlink" title="3.1Node节点（双端队列）"></a>3.1Node节点（双端队列）</h2><ul>
<li>这几个状态值在lock、await  unlock、signal中都是不同的，起到一个状态对应的作用，也用于判断是否可以唤醒线程</li>
<li>每个ReentrantLock中维护着一个Node对象（相应的维护了一个双端队列）</li>
<li>每个Condition中也维护着一个Node对象（同上，一个condition可以对应await在很多地方），因此可以实现指定唤醒</li>
<li>Node中的属性Thread非常重要，由于底层的unpark方法唤醒的是指定线程，<strong>在源码中的逻辑是：unpark()唤醒同步队列中的头节点head.thread线程</strong><br><img src="https://img-blog.csdnimg.cn/ea516a10a19841f38dfbb596b016b811.png"></li>
</ul>
<h2 id="3-2ConditionObject"><a href="#3-2ConditionObject" class="headerlink" title="3.2ConditionObject"></a>3.2ConditionObject</h2><p>主要是使用这两个方法，其内部也用到了上述双端队列，并且在大题执行逻辑上</p>
<ul>
<li>signal()与lock()相似，底层都是调用<code> LockSupport.unpark(node.thread);</code></li>
<li>await()与unlock()<strong>被阻塞</strong>相似，底层都是<code>LockSupport.park(this);</code></li>
<li>正是由于使用<code>Condition</code>类，在阻塞、唤醒的操作上比传统多线程提高了很多灵活性</li>
<li>在传统的多线程中，使用<code>notify()</code>、<code>notifyAll()</code>、<code>wait()</code>来<strong>唤醒其他线程</strong> 和 <strong>阻塞自己并进入等待队列，等待唤醒后进入同步队列</strong>，在JUC编程中使用<code>await()</code>替换了Object类中的wait,<code>signal()</code>替换Object中的notify</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/3fe9366cb11b4edd9cf9959f9b920b76.png"></p>
<h2 id="3-2-1signal-指定唤醒等待队列头节点"><a href="#3-2-1signal-指定唤醒等待队列头节点" class="headerlink" title="3.2.1signal()指定唤醒等待队列头节点"></a>3.2.1signal()指定唤醒等待队列头节点</h2><p><img src="https://img-blog.csdnimg.cn/c2e3dcc3d8e54a3cbae3b4a095bf2ef2.png">其中doSIgnal()底层调用的就是<code>LockSupport.unpark(node.thread);</code></p>
<h2 id="3-2-2await-阻塞进入等待队列"><a href="#3-2-2await-阻塞进入等待队列" class="headerlink" title="3.2.2await()阻塞进入等待队列"></a>3.2.2await()阻塞进入等待队列</h2><p><strong>着重需要注意的是：调用condition.await()很容易写成condition.wait()从而报错</strong><br>这个方法与unlock调用的都是<code>tryRelease()</code>，底层也都是unpark()<br>因为Condition类的存在，await()变得异常灵活，我们可以在不同的线程用同一个condition调用await()，其等待队列维护在这个condition对象中，可以被signal()给唤醒</p>
<p><img src="https://img-blog.csdnimg.cn/3c939cf2b4f64e17acefbd3e32265ada.png"></p>
<p>关于同步队列、等待队列的内容在第6号标题</p>
<p><img src="https://img-blog.csdnimg.cn/14818daac6ab453db15015500855457e.png"><br><img src="https://img-blog.csdnimg.cn/bb371c8836d3439ca8a50ef0a8cb49d1.png"></p>
<h1 id="4-lock源码分析"><a href="#4-lock源码分析" class="headerlink" title="4.lock源码分析"></a>4.lock源码分析</h1><ul>
<li>lock有两个实现  公平和非公平</li>
<li>两者的区别在于第一步tryAcquire，而第二步acquireQueued二者都是相同的（<strong>这也同时证明了非公平锁并不是真正意义上的公平</strong>）</li>
<li><em>二者都维护了等待队列，但在获取锁时只有公平锁使用的队列顺序</em>*</li>
<li>非公平锁<strong>第一次加锁不考虑队列</strong>，会尝试两次锁（失败后进入等待队列）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/e689244922b74bc78c1ea1f3b7078c86.png" alt="加锁失败后会打断自己"></p>
<h2 id="4-1-amp-amp-的左边条件tryAcquire"><a href="#4-1-amp-amp-的左边条件tryAcquire" class="headerlink" title="4.1&amp;&amp;的左边条件tryAcquire"></a>4.1&amp;&amp;的左边条件tryAcquire</h2><ul>
<li><p>在这个&amp;&amp;的前半块，在<code>tryAcquire </code>中，<strong>公平锁要先判断是不是队列队头，而非公平锁是直接cas抢锁</strong>（当然因为没有循环，只会获取一次，如果没抢到就算了）<br><img src="https://img-blog.csdnimg.cn/ec889af94870461fa875bdf58e623e68.png"></p>
</li>
<li><p>关于排队<code>hasQueuedPredecessors</code>，详细内容如下（考虑了并发问题）<img src="https://img-blog.csdnimg.cn/d69c0f216eec422dbd082c8e1129e98f.png"></p>
<h2 id="4-2-amp-amp-的右边条件acquireQueued"><a href="#4-2-amp-amp-的右边条件acquireQueued" class="headerlink" title="4.2&amp;&amp;的右边条件acquireQueued"></a>4.2&amp;&amp;的右边条件acquireQueued</h2></li>
</ul>
<p>在这里面公平锁与非公平锁都一样，都是使用了：<br><strong>自旋锁 + park阻塞 + unpark唤醒 + 同步队列FIFO</strong> 的策略</p>
<h3 id="4-2-1-addWaiter维护同步队列"><a href="#4-2-1-addWaiter维护同步队列" class="headerlink" title="4.2.1 addWaiter维护同步队列"></a>4.2.1 addWaiter维护同步队列</h3><p>（这里源码中的等待队列其实<strong>本质是同步队列</strong>，相关内容在第6号标题中）</p>
<p>那么非公平锁是否有维护这个队列呢？在&amp;&amp;的后半块：我们在<code>addWaiter()</code>的方法打个断点，分别测试公平锁和非公平锁，发现都会进来，就证明<strong>其实二者都维护了同步队列</strong>（只有公平锁加锁时用<code>hasQueuedPredecessors</code>判断是否是队列头）<br><img src="https://img-blog.csdnimg.cn/d51949a4212f41cd849f9167892a7cb7.png">debug后发现，对于<code>addWaiter同步队列</code>，二者的流程一致。不得不说这个addWaiter设计十分精妙，<strong>enq(Node node)方法的自旋锁完全考虑了队列为空、创建队列时被插入、新增节点时可能遇到的所有并发问题</strong><br><img src="https://img-blog.csdnimg.cn/c60fee28abec4502a7bc429f25714225.png"><img src="https://img-blog.csdnimg.cn/f5180873882741ad807cebbd357dfc9e.png" alt="自旋保证节点成功添加到队列中"></p>
<h3 id="4-2-2acquireQueued获取同步队列"><a href="#4-2-2acquireQueued获取同步队列" class="headerlink" title="4.2.2acquireQueued获取同步队列"></a>4.2.2acquireQueued获取同步队列</h3><p>刚刚分析到了加锁失败后，这里形参是刚刚生成的节点，这里最重要的是这个打框的地方，<code>shouldParkAfterFailedAcquire(pre,node)</code>是一个should开头的疑问句，作用是<strong>判断当前节点是不是下一个执行节点</strong>，如果是的话则执行<code>parkAndCheckInterrupt()</code>阻塞<br><strong>而在for(;;)中是自旋的，这里阻塞了可以减少循环消耗cpu资源，也能被上一个节点成功唤醒</strong><br><img src="https://img-blog.csdnimg.cn/0825b54af554421fa85c78d915261cdc.png">因为被<code>parkAndCheckInterrupt()</code>阻塞了，停止了循环，当上一个节点唤醒当前节点后解除阻塞，继续循环，尝试加锁（非公平锁仍有可能抢不过————<strong>存在虽然被唤醒但竞争失败的情况</strong>）</p>
<h3 id="4-2-3-parkAndCheckInterrupt方法"><a href="#4-2-3-parkAndCheckInterrupt方法" class="headerlink" title="4.2.3 parkAndCheckInterrupt方法"></a>4.2.3 parkAndCheckInterrupt方法</h3><p>关于LockSupport.park方法，这里参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/a7980718/article/details/83661613">参考链接</a>，park是一个native方法，<strong>可以实现精准唤醒（配合队列可以指定唤醒某一个节点）</strong>，其中公平锁非公平锁都用了相同逻辑的同步队列</p>
<p><img src="https://img-blog.csdnimg.cn/4fdc7bd52bdd41299be58193331ad315.png"></p>
<h1 id="5-unlock源码分析"><a href="#5-unlock源码分析" class="headerlink" title="5.unlock源码分析"></a>5.unlock源码分析</h1><h2 id="5-1源码浅析"><a href="#5-1源码浅析" class="headerlink" title="5.1源码浅析"></a>5.1源码浅析</h2><p>unlock调的都是同一个<code>release()</code>方法<br><img src="https://img-blog.csdnimg.cn/769e9e42e82c4304b436c8b67f04c3a5.png">这里调用unpark去唤醒下一个节点，下一个节点那边接触阻塞</p>
<p><img src="https://img-blog.csdnimg.cn/324ebc43c92341f6a847b93fac89c18e.png"></p>
<h2 id="5-2使用示例"><a href="#5-2使用示例" class="headerlink" title="5.2使用示例"></a>5.2使用示例</h2><p>这个案例主要是探究await()阻塞、</p>
<p><img src="https://img-blog.csdnimg.cn/38aab27ea2c04426a9a069387f177f80.png"></p>
<h1 id="6-同步队列、等待队列"><a href="#6-同步队列、等待队列" class="headerlink" title="6.同步队列、等待队列"></a>6.同步队列、等待队列</h1><ul>
<li>首先：同步队列的优先级高于等待队列，<strong>同步队列决定接下来执行哪个线程</strong>。</li>
<li>例如：<strong>有多个condition等待队列存在的情况下</strong>，需要先通过signal扔进同步队列才能确定线程的最终执行顺序</li>
</ul>
<h2 id="6-1同步队列"><a href="#6-1同步队列" class="headerlink" title="6.1同步队列"></a>6.1同步队列</h2><ul>
<li>使用reentrantLock.lock()时，当前线程进入的是<code>同步队列</code>，如果阻塞也是阻塞在同步队列</li>
<li>使用reentrantLock.unlock()会将当前节点（线程）从<code>同步队列</code>剔除，释放锁，并通知下一个节点（<code>LockSupport.unpark()</code>）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/f79e1caf91134c56b13c2ec01bcc3a7d.png"></p>
<h2 id="6-2等待队列"><a href="#6-2等待队列" class="headerlink" title="6.2等待队列"></a>6.2等待队列</h2><ul>
<li>使用condtion.await()时，将当前<strong>同步队列的头节点</strong>（当前获取锁的线程）扔到对应的<strong>condition中的队列尾</strong>，同时释放锁（与unlock逻辑相同）</li>
<li>使用condition.signal()时，将<strong>condition等待队列的头节点</strong>扔到<strong>同步队列的队尾</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/35af5a50c9ab4980b9488627d109a45e.png"></p>
<h2 id="6-3执行流程"><a href="#6-3执行流程" class="headerlink" title="6.3执行流程"></a>6.3执行流程</h2><p>线程的执行顺序由同步队列决定，等待队列仅仅起到一个保存节点的作用</p>
<p><img src="https://img-blog.csdnimg.cn/14818daac6ab453db15015500855457e.png" alt="案例"></p>
<h2 id="6-4demo"><a href="#6-4demo" class="headerlink" title="6.4demo"></a>6.4demo</h2><pre><code>public class AwaitTest &#123;

  public static void main(String[] args) &#123;

    final ReentrantLock lock = new ReentrantLock();
    final  Condition     condition = lock.newCondition();

    new Thread(()-&gt;&#123;
      lock.lock();
      System.out.println(&quot;线程000000开始&quot;);
      System.out.println(&quot;线程000000await()阻塞，进入等待队列&quot;);
      try &#123;
       condition.await();//线程0进入等待队列
      &#125; catch (InterruptedException e) &#123;
      &#125;
      System.out.println(&quot;线程0被唤醒&quot;);
      lock.unlock();//线程0释放锁，锁交给同步队列的下一个节点
    &#125;).start();


    new Thread(()-&gt;&#123;
      lock.lock();
      System.out.println(&quot;线程111111开始&quot;);
      System.out.println(&quot;线程111111await()阻塞，进入等待队列，此时等待队列有线程0和1&quot;);
      try &#123;
        //线程1从同步队列移除，进入condition等待队列，此时的condition等待队列有两个元素
        condition.await();
      &#125; catch (InterruptedException e) &#123;
      &#125;
      System.out.println(&quot;线程1被唤醒&quot;);
      lock.unlock();//线程1释放锁，锁交给同步队列的下一个节点
    &#125;).start();

    new Thread(()-&gt;&#123;
      try &#123;
      lock.lock();
      System.out.println(&quot;此时同步队列队首为线程2（线程2获取锁），线程222222开始&quot;);
        System.out.println(&quot;唤醒0线程————线程0从等待队列进入同步队列，当线程2 unlock后执行&quot;);
        condition.signal();//唤醒0线程

        System.out.println(&quot;唤醒1线程————线程1从等待队列进入同步队列，当线程0 unlock后执行&quot;);
        condition.signal();//唤醒1线程

        System.out.println(&quot;此时同步队列队首的线程2调用unlock释放锁，执行其他同步队列节点&quot;);
        lock.unlock();
      &#125; catch (Exception e) &#123;
        e.printStackTrace();
      &#125;
    &#125;).start();
    
  &#125;

&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/8336b084e785433daaa749fcffa107b1.png"></p>
<h2 id="6-4两个队列的本质"><a href="#6-4两个队列的本质" class="headerlink" title="6.4两个队列的本质"></a>6.4两个队列的本质</h2><ul>
<li><p>本质其实就是这个Node节点的结构问题。Node节点是在AQS抽象类中的，且被AQS内部类创建，<strong>因此一个ReentrantLock可以有多个Node节点（1个同步队列，多个newCondition创建的等待队列）</strong></p>
</li>
<li><p>除此之外，我们用lock  unlock操作的节点隶属于最外层AQS<img src="https://img-blog.csdnimg.cn/d131da198363458e9d4513e4344cd522.png"></p>
</li>
<li><p>而await  signal操作的节点是AQS的内部类ConditionObject中的<img src="https://img-blog.csdnimg.cn/087978696280470f977253c723f770a7.png"></p>
</li>
<li><p>因此形成了这种情况：</p>
</li>
<li><p><em>lock  unlock操作的是同步队列<br>await  signal操作的是等待队列</em>*</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/08/23/ReentrantLock%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" data-id="cl8wvrz920014kktagu2j5mbe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/08/23/AOP%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          AOP实现分布式锁
        
      </div>
    </a>
  
  
    <a href="/2022/08/23/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96AQS%E4%B8%AD%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E4%B8%8E%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">反射获取AQS中同步队列与等待队列的长度</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/">数据结构算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/26/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%81%9A%E9%BB%91%E5%90%8D%E5%8D%95%E7%9A%84%E6%96%B9%E6%A1%88/">布隆过滤做黑名单的方案</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E6%9F%90%E8%9A%81%E9%87%91%E6%9C%8D%E7%A7%8B%E6%8B%9B9-15/">某蚁金服秋招9-15</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">三种情况的层序遍历</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E5%87%A0%E9%81%93%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98-dfs-%E5%89%AA%E6%9E%9D-%E5%9B%9E%E6%BA%AF/">几道岛屿问题:dfs+剪枝+回溯</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%E6%9B%BF%E6%8D%A2%E3%80%81%E5%B7%A6%E6%97%8B%E3%80%81%E7%BC%BA%E5%A4%B1/">字符串：替换、左旋、缺失</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 张家豪<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>