<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Spring、Servlet监听器 | 张家豪的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.Servlet监听器 ServletContext、HttpSession、ServletRequest的监听都是通过javax.servlet 包下定义的，他们都是servlet的特性，换句话说，他们不依赖于Spring，而依赖于web容器（tomcat容器），他们的加载优先于Spring容器 Servlet监听器有用处，但是没有Spring监听器用的多，用的方便；并且通常可以用HttpSe">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring、Servlet监听器">
<meta property="og:url" content="https://blogzjh.github.io/2022/08/14/Spring%E3%80%81Servlet%E7%9B%91%E5%90%AC%E5%99%A8/index.html">
<meta property="og:site_name" content="张家豪的博客">
<meta property="og:description" content="1.Servlet监听器 ServletContext、HttpSession、ServletRequest的监听都是通过javax.servlet 包下定义的，他们都是servlet的特性，换句话说，他们不依赖于Spring，而依赖于web容器（tomcat容器），他们的加载优先于Spring容器 Servlet监听器有用处，但是没有Spring监听器用的多，用的方便；并且通常可以用HttpSe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/12e25b4e04b048b8be588db230769b26.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b1c3fa9dfe8f42e1b7ea48967e353f25.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1ba92b971a804d79823eeef5f62e9733.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/19d04361b5834e95bbe60f7f96c00c4d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/97a00ec1378f4e7f835f8d0448de819d.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b7c8f3983c3d4b4789c11a10eca876cc.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/077b51c0573f4111a6102f7a618838b0.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e1e200007df2422d9279852fde1274ac.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/15a94ae683a14c4b83a6104f1fba77a6.png">
<meta property="article:published_time" content="2022-08-14T13:01:46.000Z">
<meta property="article:modified_time" content="2022-08-14T13:04:28.052Z">
<meta property="article:author" content="张家豪">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/12e25b4e04b048b8be588db230769b26.png">
  
    <link rel="alternate" href="/atom.xml" title="张家豪的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">张家豪的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blogzjh.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Spring、Servlet监听器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/14/Spring%E3%80%81Servlet%E7%9B%91%E5%90%AC%E5%99%A8/" class="article-date">
  <time datetime="2022-08-14T13:01:46.000Z" itemprop="datePublished">2022-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Spring、Servlet监听器
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-Servlet监听器"><a href="#1-Servlet监听器" class="headerlink" title="1.Servlet监听器"></a>1.Servlet监听器</h1><ul>
<li><code>ServletContext、HttpSession、ServletRequest</code>的监听都是通过<code>javax.servlet </code>包下定义的，他们都是servlet的特性，换句话说，他们不依赖于Spring，而依赖于web容器（tomcat容器），他们的加载优先于Spring容器</li>
<li>Servlet监听器有用处，但是没有Spring监听器用的多，用的方便；并且通常可以用<code>HttpServletRequest和HttpServletResponse实现相同的需求</code></li>
<li>Servlet监听器提供了很多接口，在这些接口的实现类中<strong>需要重写接口方法</strong>，<strong>并且要制定对应的监听事件，监听事件也会直接影响监听目标</strong><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1018726">参考链接1</a><br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1551830">参考链接2</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dirft_din/article/details/107041979">参考链接3统计在线人数</a></li>
<li><em>其实统计人数用<code>httpServletRequest().getServletContext().setAttribute();</code>来直接获取Servlet上下文实现</em>*</li>
</ul>
<h2 id="1-1Servlet上下文监听"><a href="#1-1Servlet上下文监听" class="headerlink" title="1.1Servlet上下文监听"></a>1.1Servlet上下文监听</h2><ul>
<li>补充：<strong>在Spring项目中，启动Spring会先启动Servlet(tomcat）</strong>，Spring的init()紧跟其后<br>而关闭Spring项目会之后会立马destroyed()Servlet容器，因此这个<code>ServletContext监听器可以完全被ApplicationListener监听器代替</code>,<code>ApplicationListener是Spring3.0沿用至今最流行的全局监听器</code></li>
</ul>
<p>可以监听ServletContext对象的创建和删除以及属性的添加、删除和修改等操作。该监听器需要使用到如下两个接口类：</p>
<p>● <code>ServletContextAttributeListener</code>：监听对ServletContext属性的操作，如增加、删除、修改操作。</p>
<p>● <code>ServletContextListener</code>：监听ServletContext。</p>
<p>当创建ServletContext时，激发<code>contextInitialized(ServletContextEvent sce)</code>方法；</p>
<p>当销毁ServletContext时，激发<code>contextDestroyed(ServletContext- Event sce)</code>方法。</p>
<h2 id="1-2Http会话监听"><a href="#1-2Http会话监听" class="headerlink" title="1.2Http会话监听"></a>1.2Http会话监听</h2><ul>
<li>在Spring项目中对Session域进行监控仍然用的是<code>HttpSessionListener</code>，其来自于Servlet2.3</li>
<li>用来监听 Web 应用种的 Session 对象，通常用于统计在线情况。</li>
</ul>
<p>可以监听Http会话活动情况、Http会话中属性设置情况，也可以监听Http会话的active、pasivate情况等。</p>
<p>该监听器需要使用到如下多个接口类：</p>
<p>● <code>HttpSessionListener</code>：监听HttpSession的操作。</p>
<p>当创建一个Session时，激发<code>sessionCreated (SessionEvent se)</code>方法；</p>
<p>当销毁一个Session时，激发<code>sessionDestroyed (HttpSessionEvent se)</code>    方法。</p>
<p>● <code>HttpSessionActivationListener</code>：用于监听Http会话active、passivate情况。</p>
<p>● <code>HttpSessionAttributeListener</code>：监听HttpSession中属性的操作。</p>
<p>当在Session<strong>增加</strong>一个属性时，激发attributeAdded(HttpSessionBindingEvent se) 方法；</p>
<p>当在Session<strong>删除</strong>一个属性时，激发attributeRemoved(HttpSessionBindingEvent se)方法；</p>
<p>在Session属性被<strong>修改</strong>时，激发attributeReplaced(HttpSessionBindingEvent se) 方法。</p>
<h2 id="1-3客户端Request请求监听"><a href="#1-3客户端Request请求监听" class="headerlink" title="1.3客户端Request请求监听"></a>1.3客户端Request请求监听</h2><ul>
<li>用来监听 Request 对象的属性操作。</li>
<li>ServletRequestListener监听器来自于Servlet2.4</li>
</ul>
<p>● <code>ServletRequestListener</code>接口类。</p>
<p>● <code>ServletRequestAttrubuteListener</code>接口类。</p>
<p>其实现类实现了ServletContextAttributeListener和ServletContextListener两个接口类中的<strong>5个方法</strong>：</p>
<p>● contextInitialized(ServletContextEvent s)方法用来<strong>初始化</strong>ServletContext对象。</p>
<p>● contextDestroyed(ServletContextEvent s)方法在上下文中<strong>删除</strong>某个属性时调用。</p>
<p>● attributeAdded(ServletContextAttributeEvent sa)方法在上下文中<strong>添加</strong>一个新的属性时调用。</p>
<p>● attributeReplaced(ServletContextAttributeEvent sa)方法在<strong>更新</strong>属性时调用。</p>
<p>● attributeRemoved(ServletContextAttributeEvent sa)方法在上下文中<strong>删除</strong>某个属性时会被调用。</p>
<h1 id="2-Servlet监听事件"><a href="#2-Servlet监听事件" class="headerlink" title="2.Servlet监听事件"></a>2.Servlet监听事件</h1><p>在实现了Servlet监听器接口的方法中，需要重写其接口抽象方法，而其抽象方法的形参，<strong>则对应了一个监听器对象</strong></p>
<h2 id="2-1不带Attribute监听事件的创建和销毁"><a href="#2-1不带Attribute监听事件的创建和销毁" class="headerlink" title="2.1不带Attribute监听事件的创建和销毁"></a>2.1不带Attribute监听事件的创建和销毁</h2><pre><code>@WebListener
public class MyServletListener implements ServletContextListener &#123;

  @Override
  public void contextInitialized(ServletContextEvent sce) &#123;
    ServletContextListener.super.contextInitialized(sce);
  &#125;

  @Override
  public void contextDestroyed(ServletContextEvent sce) &#123;
    ServletContextListener.super.contextDestroyed(sce);
  &#125;&#125;

————————————————————————————————————————————————————————————————————————
@WebListener
public class MyServletListener implements HttpSessionListener &#123;

  @Override
  public void sessionCreated(HttpSessionEvent se) &#123;
    HttpSessionListener.super.sessionCreated(se);
  &#125;

  @Override
  public void sessionDestroyed(HttpSessionEvent se) &#123;
    HttpSessionListener.super.sessionDestroyed(se);
  &#125;&#125;

—————————————————————————————————————————————————————————————————————————
    @WebListener
public class MyServletListener implements ServletRequestListener &#123;

  @Override
  public void requestDestroyed(ServletRequestEvent sre) &#123;
    ServletRequestListener.super.requestDestroyed(sre);
  &#125;

  @Override
  public void requestInitialized(ServletRequestEvent sre) &#123;
    ServletRequestListener.super.requestInitialized(sre);
  &#125;&#125;
</code></pre>
<h2 id="2-2带Attribute监听事件的增、删、改"><a href="#2-2带Attribute监听事件的增、删、改" class="headerlink" title="2.2带Attribute监听事件的增、删、改"></a>2.2带Attribute监听事件的增、删、改</h2><pre><code>@WebListener
public class MyServletListener implements ServletContextAttributeListener &#123;

  @Override
  public void attributeAdded(ServletContextAttributeEvent scae) &#123;
    ServletContextAttributeListener.super.attributeAdded(scae);
  &#125;

  @Override
  public void attributeRemoved(ServletContextAttributeEvent scae) &#123;
    ServletContextAttributeListener.super.attributeRemoved(scae);
  &#125;

  @Override
  public void attributeReplaced(ServletContextAttributeEvent scae) &#123;
    ServletContextAttributeListener.super.attributeReplaced(scae);
  &#125;&#125;
</code></pre>
<p>其他两个关于Attribute监听的都是有三个抽象方法：added  removed repalced</p>
<h1 id="3-为什么大量出现ed过去式？"><a href="#3-为什么大量出现ed过去式？" class="headerlink" title="3.为什么大量出现ed过去式？"></a>3.为什么大量出现ed过去式？</h1><p>众所周知英语中ed结尾的动词都是<code>过去完成式</code><br>我们发现 <code>sessionCreated  contextDestroyed Replaced等等</code>这些抽象方法都是ed结尾的过去式，那么可以 从中推断出：监听中的方法是在事件发生之后进行的。<br>因此我们可以解决一个疑惑：“我想在监听器方法中使用容器中的其他对象方法，会不会报错？”<br>答案是不会：“因为对context监听的ed方法一定触发在整个容器加载结束之后”</p>
<h1 id="4-Spring监听器"><a href="#4-Spring监听器" class="headerlink" title="4. Spring监听器"></a>4. Spring监听器</h1><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039097608">两种方式：参考资料</a></p>
<h2 id="4-1ApplicationListener接口实现监听"><a href="#4-1ApplicationListener接口实现监听" class="headerlink" title="4.1ApplicationListener接口实现监听"></a>4.1ApplicationListener接口实现监听</h2><p>一般来说，在Spring项目中监听器只选择ApplicationListener，而对于监听事件spring提供了多种选择</p>
<pre><code>ApplicationStartedEvent：spring boot启动监听类
ApplicationEnvironmentPreparedEvent：环境事先准备
ApplicationPreparedEvent：上下文context准备时触发
ApplicationReadyEvent：上下文已经准备完毕的时候触发
ApplicationFailedEvent：该事件为spring boot启动失败时的操作
</code></pre>
<ul>
<li>他们<code>都是ApplicationEvent的抽象子类</code>，触发的时机不同</li>
<li>例如用<code>ApplicationListener监听</code>，那么<code>以上5种子类事件都可以被监听到</code></li>
<li>你可以<code>自定义一个事件</code>，继承于上面的<code>子事件</code>，来实现一些<code>数据的绑定</code>，不过一般不会用到</li>
</ul>
<h2 id="4-2-EventListener注解实现监听"><a href="#4-2-EventListener注解实现监听" class="headerlink" title="4.2@EventListener注解实现监听"></a>4.2@EventListener注解实现监听</h2><pre><code>@Component//需要注入IOC，无需实现任何接口
public class MySprigListenerAnno &#123;
@EventListener//配置一个监听器，省去了写ApplicationListener，但必须明确指出形参中的监听事件
  public void myEvent(ApplicationEvent event)&#123;
  System.out.println(&quot;用注解的方式实现Spring监听器，当前：&quot;+event.getClass().getName());
&#125;

&#125;
</code></pre>
<h2 id="4-3重要的泛型"><a href="#4-3重要的泛型" class="headerlink" title="4.3重要的泛型"></a>4.3重要的泛型</h2><p>查看源码可知<code>泛型决定了监听事件是谁</code>，如果不指定，那么就是<code>默认监听根父类ApplicationEvent</code></p>
<p><img src="https://img-blog.csdnimg.cn/12e25b4e04b048b8be588db230769b26.png" alt="源码"></p>
<h1 id="5-Servlet和Spring的初始化顺序"><a href="#5-Servlet和Spring的初始化顺序" class="headerlink" title="5.Servlet和Spring的初始化顺序"></a>5.Servlet和Spring的初始化顺序</h1><p>我们用一个案例直接看</p>
<h2 id="5-1Serlvet：监听context"><a href="#5-1Serlvet：监听context" class="headerlink" title="5.1Serlvet：监听context"></a>5.1Serlvet：监听context</h2><pre><code>@WebListener
public class MyServletListener implements ServletContextListener &#123;

  @Override
  public void contextInitialized(ServletContextEvent sce) &#123;
    /**
     * ServletContextEvent的父类EventListener是没有contextInitialized(sce)方法的。
     * 所以对于此处来说，调不调super.contextInitialized都无所谓
     */
    ServletContextListener.super.contextInitialized(sce);
    System.out.println(&quot;当前是Servlet初始化&quot;);
  &#125;

  @Override
  public void contextDestroyed(ServletContextEvent sce) &#123;
    ServletContextListener.super.contextDestroyed(sce);
    System.out.println(&quot;当前是Servlet销毁&quot;);
  &#125;&#125;
</code></pre>
<h2 id="5-2Spring：监听context"><a href="#5-2Spring：监听context" class="headerlink" title="5.2Spring：监听context"></a>5.2Spring：监听context</h2><p>这里监听ApplicationEvent，相当于监听其所有子类事件的，他的子类很多，但是Spring启动的时候只有几个事件会被监听<br><img src="https://img-blog.csdnimg.cn/b1c3fa9dfe8f42e1b7ea48967e353f25.png"></p>
<pre><code>@Component
@Order(1)
public class MySpringListener implements ApplicationListener&lt;ApplicationEvent&gt; &#123;

  @Override
  public void onApplicationEvent(ApplicationEvent event) &#123;
    System.out.println(&quot;当前是Spring的:&quot;+event.getClass().getName()+&quot;监听事件&quot;);
  &#125;&#125;
</code></pre>
<h2 id="5-3启动Spring"><a href="#5-3启动Spring" class="headerlink" title="5.3启动Spring"></a>5.3启动Spring</h2><p>执行顺序大概是:  tomcat初始化——Servlet启动——Servlet引擎——Servlet初始化完成——tomcat启动完成——Spring初始化</p>
<p><img src="https://img-blog.csdnimg.cn/1ba92b971a804d79823eeef5f62e9733.png"></p>
<h1 id="6-监听器的应用：Spring启动时就调用业务方法"><a href="#6-监听器的应用：Spring启动时就调用业务方法" class="headerlink" title="6.监听器的应用：Spring启动时就调用业务方法"></a>6.监听器的应用：Spring启动时就调用业务方法</h1><ul>
<li>通过监听<code>ApplicationReadyEvent</code>或<code>ApplicationStartedEvent</code>事件，就可以调用；</li>
<li><strong>注意started是过去式，即此时Spring的IOC容器已经启动完成，可以在此时调用IOC容器中的bean</strong></li>
<li>而Ready更是在Started之后，更可以直接@Autowired使用IOC容器中的bean</li>
</ul>
<pre><code>    @Service
    public class TheFuckList &#123;
    
      @Autowired
      RedisTemplate redisTemplate;
    
      public List&lt;String&gt; getFuckList()&#123;
    //    List fuckList = redisTemplate.boundListOps(&quot;list1&quot;).range(0, 10);
        List fuckList = redisTemplate.opsForList().range(&quot;list1&quot;,0,10);
        Iterator iterator = fuckList.iterator();
        while(iterator.hasNext())&#123;
          System.out.println(iterator.next());
        &#125;
        return fuckList;
      &#125;
    &#125;
</code></pre>
<hr>
<pre><code>@Component
@Order(0)
public class MySpringListener2 implements ApplicationListener&lt;ApplicationStartedEvent&gt; &#123;

  @Autowired
  TheFuckList theFuckList;

  @Autowired
  FuckListBean fuckListBean;

  @Override
  public void onApplicationEvent(ApplicationStartedEvent event) &#123;
    fuckListBean.fuckList = theFuckList.getFuckList();
    System.out.println(fuckListBean.fuckList.size());
  &#125;
&#125;
</code></pre>
<h1 id="7-多个Spring监听器执行顺序"><a href="#7-多个Spring监听器执行顺序" class="headerlink" title="7.多个Spring监听器执行顺序"></a>7.多个Spring监听器执行顺序</h1><p>以<code>监听事件</code>为基准，监听器之间的顺序以@Order决定</p>
<pre><code>@Component
@Order(-1)
public class MySpringListener implements ApplicationListener&lt;ApplicationEvent&gt; &#123;//ApplicationStartedEvent
  
  @Override
  public void onApplicationEvent(ApplicationEvent event) &#123;
    System.out.println(&quot;当前是Srp:&quot;+event.getClass().getName()+&quot;监听事件&quot;);
  &#125;


@Component
@Order(0)
public class MySpringListener2 implements ApplicationListener&lt;ApplicationEvent&gt; &#123;
  @Override
  public void onApplicationEvent(ApplicationEvent event) &#123;
    System.out.println(&quot;第二个监听器&quot;);
  &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/19d04361b5834e95bbe60f7f96c00c4d.png"></p>
<h1 id="8-过滤器、拦截器、监听器执行顺序"><a href="#8-过滤器、拦截器、监听器执行顺序" class="headerlink" title="8.过滤器、拦截器、监听器执行顺序"></a>8.过滤器、拦截器、监听器执行顺序</h1><ul>
<li>注意，<strong>过滤器、拦截器</strong>是针对某个包下的<strong>controller接口被调用时而进行处理的</strong>；</li>
<li><strong>监听器</strong>则可以深入到Servlet、Spring容器的创建之时执行。</li>
<li>Filter过滤器的本质是：<code>回调</code></li>
<li>Interceptor拦截器的本质是：<code>反射</code></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1981326">参考资料</a></p>
<p>那么如果是过滤器，拦截器，监听器同时生效呢？</p>
<p><img src="https://img-blog.csdnimg.cn/97a00ec1378f4e7f835f8d0448de819d.png"><br><img src="https://img-blog.csdnimg.cn/b7c8f3983c3d4b4789c11a10eca876cc.png"></p>
<h2 id="8-1Filter的过滤流程"><a href="#8-1Filter的过滤流程" class="headerlink" title="8.1Filter的过滤流程"></a>8.1Filter的过滤流程</h2><ul>
<li>在我们自定义的过滤器中都会实现一个 doFilter()方法，这个方法有一个FilterChain 参数，而实际上它是一个回调接口。ApplicationFilterChain是它的实现类， 这个实现类内部也有一个 doFilter() 方法就是回调方法。</li>
<li>回调的顺序由@Order来进行配置</li>
<li>过滤器Filter是在<strong>请求进入web容器后，但在进入servlet之前进行预处理</strong>，请求结束是在servlet处理完以后。</li>
</ul>
<h2 id="8-2Interceptor拦截器流程"><a href="#8-2Interceptor拦截器流程" class="headerlink" title="8.2Interceptor拦截器流程"></a>8.2Interceptor拦截器流程</h2><ul>
<li>对于Spring拦截器，一般直接实现<code>HandlerInterceptor接口</code>，并重写三个抽象方法。</li>
<li>拦截器 Interceptor 是在请求进入servlet后，在进入Controller之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1413447">参考资料1</a></p>
<p><img src="https://img-blog.csdnimg.cn/077b51c0573f4111a6102f7a618838b0.png"></p>
<h2 id="8-3Controller请求调用顺序"><a href="#8-3Controller请求调用顺序" class="headerlink" title="8.3Controller请求调用顺序"></a>8.3Controller请求调用顺序</h2><p>controller 中所有的请求都要经过<strong>核心组件<code>DispatcherServlet</code>路由</strong>，都会执行它的 <code>doDispatch() </code>方法，<strong>而拦截器postHandle()、preHandle()方法便是在其中调用的。</strong></p>
<h1 id="9-DispatcherServlet类：路由，中央调度器"><a href="#9-DispatcherServlet类：路由，中央调度器" class="headerlink" title="9.DispatcherServlet类：路由，中央调度器"></a>9.DispatcherServlet类：路由，中央调度器</h1><p><img src="https://img-blog.csdnimg.cn/e1e200007df2422d9279852fde1274ac.png" alt="源码"></p>
<ul>
<li><strong><code>HTTP请求处理程序/控制器的中央调度器</code></strong></li>
</ul>
<pre><code>![源码](https://img-blog.csdnimg.cn/e7bb33374b2444b09cef9327d79c312b.png)
</code></pre>
<h2 id="9-1doDispatch中央调度方法"><a href="#9-1doDispatch中央调度方法" class="headerlink" title="9.1doDispatch中央调度方法"></a>9.1doDispatch中央调度方法</h2><pre><code>    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
    
        try &#123;
     ...........
        try &#123;
       
            // 获取可以执行当前Handler的适配器
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // Process last-modified header, if supported by the handler.
            String method = request.getMethod();
            boolean isGet = &quot;GET&quot;.equals(method);
            if (isGet || &quot;HEAD&quot;.equals(method)) &#123;
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (logger.isDebugEnabled()) &#123;
                    logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);
                &#125;
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;
                    return;
                &#125;
            &#125;
            // 注意： 执行Interceptor中PreHandle()方法
            if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;
                return;
            &#125;

            // 注意：执行Handle【包括我们的业务逻辑，当抛出异常时会被Try、catch到】
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            if (asyncManager.isConcurrentHandlingStarted()) &#123;
                return;
            &#125;
            applyDefaultViewName(processedRequest, mv);

            // 注意：执行Interceptor中PostHandle 方法【抛出异常时无法执行】
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        &#125;
    &#125;
    ...........
&#125;
</code></pre>
<h2 id="9-2为何拦截器的pre和post执行顺序是栈顺序"><a href="#9-2为何拦截器的pre和post执行顺序是栈顺序" class="headerlink" title="9.2为何拦截器的pre和post执行顺序是栈顺序"></a>9.2为何拦截器的pre和post执行顺序是栈顺序</h2><p>看看两个方法<code>applyPreHandle(）</code>、<code>applyPostHandle(）</code>具体是如何被调用的，就明白为什么postHandle()、preHandle() 执行顺序是相反的了。</p>
<p><img src="https://img-blog.csdnimg.cn/15a94ae683a14c4b83a6104f1fba77a6.png"></p>
<p>正是因为<code>DispathcherServlet类中的doDispach()方法</code>进行调度的时候，<strong>实际上</strong>是调用了<code>applyPreHandler()和applyPostHandler()</code>，而这两个方法中的for循环遍历<code>interceptorList</code>数组时一个是<code>i++</code>一个是<code>i--</code>，所以表面上就成了入栈出栈的执行顺序</p>
<h1 id="10-过滤器监听器几个注解及配置"><a href="#10-过滤器监听器几个注解及配置" class="headerlink" title="10.过滤器监听器几个注解及配置"></a>10.过滤器监听器几个注解及配置</h1><h2 id="WebFilter"><a href="#WebFilter" class="headerlink" title="@WebFilter"></a>@WebFilter</h2><p>标注在 xxxxx<code>implements Filter</code>的类上，即把<code>Servlet过滤器</code>注入Servlet容器中，这是Servlet3.0的注解规范，被Spring5.0引入</p>
<h2 id="WebListener"><a href="#WebListener" class="headerlink" title="@WebListener"></a>@WebListener</h2><p>标注在 xxxxx<code> implements ServletContextListener</code>的类上，即把<code>Servlet监听器</code>注入Servlet容器中，这是Servlet3.0的注解规范，被Spring5.0引入</p>
<h2 id="EventListener"><a href="#EventListener" class="headerlink" title="@EventListener"></a>@EventListener</h2><pre><code>@Component//需要注入IOC，无需实现任何接口
public class MySprigListenerAnno &#123;
@EventListener//配置一个监听器，省去了写ApplicationListener，但必须明确指出形参中的监听事件
  public void myEvent(ApplicationEvent event)&#123;
  System.out.println(&quot;用注解的方式实现Spring监听器，当前：&quot;+event.getClass().getName());
&#125;
</code></pre>
<p>————————————如果不用注解就需要实现接口</p>
<pre><code>@Component
@Order(0)
public class MySpringListener2 implements ApplicationListener&lt;ApplicationEvent&gt; &#123;
  @Override
  public void onApplicationEvent(ApplicationEvent event) &#123;
    System.out.println(&quot;第二个监听器&quot;);
  &#125;
&#125;
</code></pre>
<h2 id="WebMvcConfigurer配置"><a href="#WebMvcConfigurer配置" class="headerlink" title="WebMvcConfigurer配置"></a>WebMvcConfigurer配置</h2><p>为Spring容器注册HandlerInterceptor的实现类</p>
<pre><code>@Configuration
public class MyWebMvcConfigurer implements WebMvcConfigurer &#123;

  @Override
  public void addInterceptors(InterceptorRegistry registry) &#123;
    registry.addInterceptor(new MyHandlerInterceptor()).addPathPatterns(&quot;/login/web&quot;)
        .excludePathPatterns(&quot;/login/no&quot;);
  &#125;
&#125;
</code></pre>
<p>————————<strong>拦截器本身内容跟注册配置缺一不可</strong></p>
<pre><code>public class MyHandlerInterceptor  implements HandlerInterceptor &#123;

  @Override
  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
    long start = System.currentTimeMillis();
    request.setAttribute(&quot;startTime&quot;, start);
    return true;//直接放行
//    return HandlerInterceptor.super.preHandle(request, response, handler);
  &#125;
  @Override
  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
    long start = (long) request.getAttribute(&quot;startTime&quot;);
    long end     = System.currentTimeMillis();
    request.setAttribute(&quot;handleTime&quot;,end-start);
//    HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
  &#125;

  @Override
  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
  log.info(
      String.format(&quot;本次请求%s的%s接口耗时%s毫秒&quot;,
          request.getRequestURL(),
          request.getMethod(),
          (long)request.getAttribute(&quot;handleTime&quot;)));
//    HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
  &#125;
&#125;
</code></pre>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>除了@EventListener可以不写实现类，其他都必须写</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/08/14/Spring%E3%80%81Servlet%E7%9B%91%E5%90%AC%E5%99%A8/" data-id="cl8wvrz9d001hkktaa2rnbrlc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/08/23/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96AQS%E4%B8%AD%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E4%B8%8E%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          反射获取AQS中同步队列与等待队列的长度
        
      </div>
    </a>
  
  
    <a href="/2022/08/13/AOP-%E5%8F%8D%E5%B0%84%EF%BC%9A%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">AOP+反射：接口参数校验</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/">数据结构算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/26/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%81%9A%E9%BB%91%E5%90%8D%E5%8D%95%E7%9A%84%E6%96%B9%E6%A1%88/">布隆过滤做黑名单的方案</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E6%9F%90%E8%9A%81%E9%87%91%E6%9C%8D%E7%A7%8B%E6%8B%9B9-15/">某蚁金服秋招9-15</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">三种情况的层序遍历</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E5%87%A0%E9%81%93%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98-dfs-%E5%89%AA%E6%9E%9D-%E5%9B%9E%E6%BA%AF/">几道岛屿问题:dfs+剪枝+回溯</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%E6%9B%BF%E6%8D%A2%E3%80%81%E5%B7%A6%E6%97%8B%E3%80%81%E7%BC%BA%E5%A4%B1/">字符串：替换、左旋、缺失</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 张家豪<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>