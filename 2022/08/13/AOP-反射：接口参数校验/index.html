<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>AOP+反射：接口参数校验 | 张家豪的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本案例包括4个核心类：AopUtils：抽取出来的公共方法@ValidateGroup@ValidateFieldValidateAspectJHandler 功能包括：长度、值范围、正则匹配、非空校验 以下是设计思路、最终代码、测试结果 后续扩展只需要修改@ValidateField 和 ValidateAspectJHandler；例如如果是按照我第一份实习时候的代码架构，可以在Aspect">
<meta property="og:type" content="article">
<meta property="og:title" content="AOP+反射：接口参数校验">
<meta property="og:url" content="https://blogzjh.github.io/2022/08/13/AOP-%E5%8F%8D%E5%B0%84%EF%BC%9A%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/index.html">
<meta property="og:site_name" content="张家豪的博客">
<meta property="og:description" content="本案例包括4个核心类：AopUtils：抽取出来的公共方法@ValidateGroup@ValidateFieldValidateAspectJHandler 功能包括：长度、值范围、正则匹配、非空校验 以下是设计思路、最终代码、测试结果 后续扩展只需要修改@ValidateField 和 ValidateAspectJHandler；例如如果是按照我第一份实习时候的代码架构，可以在Aspect">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/e5f4ac9d44474348ba35f74fc9263209.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/09ae76ac260b4970a236069c7e020fa6.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/1f5e188fef6142eca85c1074208832ee.png">
<meta property="article:published_time" content="2022-08-13T09:12:17.000Z">
<meta property="article:modified_time" content="2022-08-13T09:30:37.332Z">
<meta property="article:author" content="张家豪">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/e5f4ac9d44474348ba35f74fc9263209.png">
  
    <link rel="alternate" href="/atom.xml" title="张家豪的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">张家豪的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blogzjh.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-AOP-反射：接口参数校验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/13/AOP-%E5%8F%8D%E5%B0%84%EF%BC%9A%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/" class="article-date">
  <time datetime="2022-08-13T09:12:17.000Z" itemprop="datePublished">2022-08-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      AOP+反射：接口参数校验
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>本案例包括4个核心类：<br>AopUtils：抽取出来的公共方法<br>@ValidateGroup<br>@ValidateField<br>ValidateAspectJHandler</li>
<li>功能包括：长度、值范围、正则匹配、非空校验</li>
<li>以下是设计思路、最终代码、测试结果</li>
<li>后续扩展只需要修改@ValidateField 和 ValidateAspectJHandler；例如如果是按照我第一份实习时候的代码架构，可以在AspectJ中添加<a target="_blank" rel="noopener" href="https://zjhblog.gitee.io/zjh/2022/08/12/%E5%AF%B9dto%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7%E4%B8%80%E9%94%AE%E5%8A%A0%E8%A7%A3%E5%AF%86/">对dto指定属性一键加解密</a>的逻辑。</li>
</ul>
<h1 id="1-演示-最终使用方法"><a href="#1-演示-最终使用方法" class="headerlink" title="1.演示: 最终使用方法"></a>1.演示: 最终使用方法</h1><p>以注册功能为例</p>
<pre><code>@RestController
@RequestMapping(&quot;validater&quot;)
public class ValidateController &#123;

  @ValidateGroup(fields = &#123;
    //index默认=0，即对第一个参数param1校验，其他参数是校验规则、报错日志记录的内容
      @ValidateField(index = 0,notNull = true,maxLen = 10,code = &quot;param1-error&quot;,message = &quot;param1校验错误&quot;),
      @ValidateField(index = 1,notNull = true,fieldName = &quot;passWord&quot;,minLen = 6,code = &quot;passWord-erro&quot;,message = &quot;密码校验错误&quot;),
      @ValidateField(index = 1,notNull = true,fieldName = &quot;age&quot;,minVal = 0,code = &quot;age-error&quot;,message = &quot;年龄不能小于0&quot;),
      @ValidateField(index = 1,notNull = true,fieldName = &quot;tall&quot;,minVal = 0,maxVal = 250.9,code =&quot;tall-error&quot;,message = &quot;身高范围出错&quot;),
      @ValidateField(index = 1,notNull = true,fieldName = &quot;phone&quot;,regStr = &quot;^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\\d&#123;8&#125;$&quot;,code = &quot;phone-error&quot;,message = &quot;手机号错误&quot;)
  &#125;)
  @PostMapping(&quot;post&quot;)
  public String postValidater(@RequestParam String param1,  RegisterDto dto)&#123;

    System.out.println(&quot;成功通过校验&quot;);
    System.out.println(&quot;第一个参数是：&quot; + param1);

    System.out.println(&quot;第二个参数是&quot;+dto.toString());

    return &quot;succeed&quot;;
  &#125;    
&#125;
</code></pre>
<p>其中：请求Dto包含name、passWord、phone等字段；<br>利用AspectJ对接口方法直接进行代理校验</p>
<h1 id="2-流程分析"><a href="#2-流程分析" class="headerlink" title="2.流程分析"></a>2.流程分析</h1><ul>
<li>AspectJ代理注解<code>@ValidateGroup</code>标注的方法，而这个Group注解中的属性就是<code>@ValidateField []</code></li>
<li>获取到<code>@ValidateField</code>数组后，遍历。通过比对注解的参数 与 dto或者param中对应名字的参数来进行校验</li>
<li>如果校验成功就放行，校验失败就抛异常终止</li>
</ul>
<h1 id="3-公共方法抽取AopUtils"><a href="#3-公共方法抽取AopUtils" class="headerlink" title="3.公共方法抽取AopUtils"></a>3.公共方法抽取AopUtils</h1><p>经过流程分析可知：至少需要以下几个方法（并可以抽取为公共组件）</p>
<ul>
<li> <code>public Method getMethod(ProceedingJoinPoint pjp)</code>：获取被AOP拦截的方法Method对象</li>
<li> <code> public Annotation getAnnotationByMethod(Method method, Class annoClass)</code>：获取目标方法对象的指定注解对象</li>
<li><code>public Object getFieldFromDtoByFieldName(Object dto , String fieldName) </code>从dto中，获取指定属性名的属性值</li>
</ul>
<p>如下工具类也可以做成全静态方法</p>
<pre><code>public class AopUtils &#123;

private volatile static AopUtils aopUtils;


private AopUtils() &#123;
&#125;

public static AopUtils getInstance() &#123;
    if (aopUtils == null) &#123;
        synchronized (AopUtils.class) &#123;
            if (aopUtils == null) &#123;
                aopUtils = new AopUtils();
            &#125;
        &#125;
    &#125;
    return aopUtils;
&#125;

/**
 * 获取目标类的指定方法
 */
public Method getMethodByClassAndName(Class c, String methodName) &#123;
    Method[] methods = c.getDeclaredMethods();
    for (Method method : methods) &#123;
        if (method.getName().equals(methodName)) &#123;
            return method;
        &#125;
    &#125;
    return null;
&#125;

/**
 * 获取目标方法的指定注解
 * 相当于 method.getAnnotation(xxxx.class);
 */
public Annotation getAnnotationByMethod(Method method, Class annoClass) &#123;
    Annotation all[] = method.getAnnotations();
    for (Annotation annotation : all) &#123;
        if (annotation.annotationType() == annoClass) &#123;
            return annotation;
        &#125;
    &#125;
    return null;
&#125;

/**
 * 获取被拦截方法的对象
 * 配合使用，最终用于在Aspectj中获取被拦截方法上的注解
 * 例如：AopUtils.getMethod(pjp).getDeclaredAnnotation(被aop拦截的注解.class)
 */
public Method getMethod(ProceedingJoinPoint pjp) &#123;
    //获取参数的签名
    MethodSignature msig = (MethodSignature) pjp.getSignature();
    // MethodSignature.getMethod() 获取的是顶层接口或者父类的方法对象 如果在实现类的方法上，应该使用反射获取当前对象的方法对象
    Object target = pjp.getTarget();//获取连接点所在的目标对象（被代理的对象）而不是父类or接口
    //方法名 + 方法形参 ————》获取指定的方法对象(重载)
    String methodName = msig.getName();
    Class[] parameterTypes = msig.getParameterTypes();
    Method method = null;
    try &#123;
        method = target.getClass().getMethod(methodName, parameterTypes);
    &#125; catch (NoSuchMethodException e) &#123;
        //log.error(...);
    &#125;
    return method;
&#125;

/**
 * 从dto中，获取指定属性名的属性值；
 */
public Object getFieldFromDtoByFieldName(Object dto , String fieldName) throws NoSuchFieldException, IllegalAccessException &#123;
    Class&lt;?&gt; dtoClazz = dto.getClass();
    Field field = dtoClazz.getDeclaredField(fieldName);
    field.setAccessible(true);
    return field.get(dto);
&#125;

//  这个其实还有另一种写法
//  private Method getMethod(ProceedingJoinPoint joinPoint) &#123;
//    try &#123;
//      Class[] parameterTypes = ((MethodSignature) joinPoint.getSignature()).getMethod().getParameterTypes();
//      return joinPoint.getTarget().getClass().getMethod(joinPoint.getSignature().getName(), parameterTypes);
//    &#125; catch (NoSuchMethodException e) &#123;
//      e.printStackTrace();
//    &#125;
//    return null;
//  &#125;
&#125;
</code></pre>
<h1 id="4-注解及设计原理"><a href="#4-注解及设计原理" class="headerlink" title="4.注解及设计原理"></a>4.注解及设计原理</h1><h2 id="4-1ValidateGroup"><a href="#4-1ValidateGroup" class="headerlink" title="4.1ValidateGroup"></a>4.1ValidateGroup</h2><p>这个注解用于被AspectJ拦截，其属性是一个数组，用于参数校验</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)
public @interface ValidateGroup &#123;

  ValidateFiled[] fields();

&#125;
</code></pre>
<h2 id="4-2ValidateField"><a href="#4-2ValidateField" class="headerlink" title="4.2ValidateField"></a>4.2ValidateField</h2><ul>
<li>当且仅当只有一个参数的时候可以不用指定index</li>
<li>index默认为0，例如<code>public void register(@RequestParam String param1 , @RequestBody Dto dto)&#123;&#125;</code>中应该设置index = 1 ，这是由于<code>joinPoint.getArgs()</code>获取的形参是一个数组，需要用index指定位置</li>
<li>所有参数都有默认值（不进行校验）</li>
</ul>
<p>如下：</p>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)
public @interface ValidateField &#123;

  /**
   * 参数索引位置：接口中有多个参数时用index指定需要校验的参数
   * 默认：0号索引，当且仅当接口方法只有一个参数
   */
  int index() default 0;

  /**
   * 默认：如果参数是基本数据类型或String，就不用指定该参数
   * 如果参数是对象，要验证对象里面某个属性，就用该参数指定属性名
   */
  String fieldName() default &quot;&quot;;

  /**
   * 错误码，用于日志记录
   */
  String code() default &quot;&quot;;

  /**
   * 错误提示语，用于日志记录
   */
  String message() default &quot;&quot;;

  /**
   * 正则验证
   */
  String regStr() default &quot;&quot;;

  /**
   * 非空校验，为true表示不能为空，false表示能够为空
   */
  boolean notNull() default false;

  /**
   * 字符串最大长度
   */
  int maxLen() default 0x7fffffff;

  /**
   * 字符串最小长度
   */
  int minLen() default 0;

  /**
   * 最大值，用于验证数值类型数据
   */
  double maxVal() default 0x1.fffffffffffffP+1023;

  /**
   * 最小值，用于验证数值类型数据
   */
  double minVal() default 0x0.0000000000001P-1022;

&#125;
</code></pre>
<h1 id="5-ValidateAspectJHandler"><a href="#5-ValidateAspectJHandler" class="headerlink" title="5.ValidateAspectJHandler"></a>5.ValidateAspectJHandler</h1><h2 id="5-1大体结构"><a href="#5-1大体结构" class="headerlink" title="5.1大体结构"></a>5.1大体结构</h2><pre><code>@Component
@Aspect
public class ValidateAspectHandler &#123;

  private AopUtils aopUtils = AopUtils.getInstance();
  /**
   * 使用AOP对使用了ValidateGroup的方法进行代理校验
   */
  @Around(&quot;@annotation(ValidateGroup)&quot;)
  public Object validateAround(ProceedingJoinPoint joinPoint) throws Throwable &#123;
//1.获取当前方法对象method
//2.根据method对象获取对应的ValidateGroup对象
//3.调用封装方法，将validateGroup.fields() 与 joinPoint.getArgs()形参数组传入，进行校验
//4.如果为true，则执行下一步
    return joinPoint.proceed();
  &#125;


  /**
   * 封装方法：验证参数是否合法
   */
  private boolean validateField(ValidateFiled[] validateFields, Object[] args) &#123;
    for (ValidateFiled validateFiled : validateFields) &#123;
        //1.每次循环都是一个校验逻辑
        //2.index仍然是指定对第几号元素进行校验
        //3.fieldName如果不指定，那就是对基本数据类型即@RequestParam进行校验；如果指定，则对Dto即@RequestBody进行校验

&#125;
</code></pre>
<h2 id="5-2具体实现"><a href="#5-2具体实现" class="headerlink" title="5.2具体实现"></a>5.2具体实现</h2><pre><code>@Component
@Aspect
public class ValidateAspctJHandler &#123;

//    private static org.slf4j.Logger logger = LoggerFactory.getLogger(&quot;ValidateAspctJHandler&quot;);
    private AopUtils aopUtils = AopUtils.getInstance();

  /**
   * 使用AOP对使用了ValidateGroup的方法进行代理校验
   */
  //相当于用@Around + return joinPoint.proceed(); 
  //使用@Before的时候不能用ProceedingJoinPoint 只能用JoinPoint
    @Before(&quot;@annotation(ValidateGroup)&quot;)
    public void validateAround(JoinPoint joinPoint) throws Throwable &#123;
        //获取被代理的方法对象
        Method method = aopUtils.getMethod(joinPoint);
        //获取被代理的方法对象对应的@ValidateGroup对象
        ValidateGroup validateGroup = (ValidateGroup)aopUtils.getAnnotationByMethod(method, ValidateGroup.class);
        //获取被代理方法的参数数组(这是参数值，而不是 method.getParameterTypes()返回的是Class[]  )
        Object[] args = joinPoint.getArgs();
        /*
         * args和validateGroup中包含了全部需要校验的信息，因此可以封装为一个方法
         * 在这个方法中，如果校验失败则用throws抛异常的方式终止
         */
        validateAllFields(validateGroup.fields(), args);
    &#125;

    /**
     * 验证参数是否合法
     * ValidateField[]中每一条都是一个校验规则，每一条都对应一个属性
     * Object[] args中是所有的请求参数值，需要从args[validateFiled.index()中确定是对谁进行校验
     */
  private void validateAllFields(ValidateField[] validateFields, Object[] args) throws NoSuchFieldException, IllegalAccessException &#123;
      //遍历：对每个@ValidateField进行校验
    for (ValidateField validateFiled : validateFields) &#123;
      Object arg;
      //1.当fieldName为默认值&quot;&quot;的时候，此时是对@RequestParam即基本数据类型orString进行校验
      if (&quot;&quot;.equals(validateFiled.fieldName())) &#123;
          //arg是基本数据类型orString
        arg = args[validateFiled.index()];
        //2.如果fieldName设置了，那就是对dto中的某个属性进行校验
      &#125; else &#123;
          //获取第index号参数dto指定的属性值
        arg = aopUtils.getFieldFromDtoByFieldName(args[validateFiled.index()], validateFiled.fieldName());
      &#125;

      //3.以下是校验流程，需要同时考虑是对dto属性or基本数据类型orString
      //3.1判断参数是否为空
      if (validateFiled.notNull()) &#123;
        if (arg == null || arg.equals(&quot;&quot;)) &#123;
//            logger.error(validateFiled.code() + &quot;:&quot; + validateFiled.message());
          throw new RuntimeException(validateFiled.code()  + &quot;:&quot; + validateFiled.message());
        //如果该参数能够为空，并且当参数为空时，就不用判断后面的了 ，直接返回
        &#125; &#125;else &#123;
        if (arg == null || arg.equals(&quot;&quot;)) &#123;
          return;
        &#125;
      &#125;

      //3.2判断字符串最大长度  如果设置为一个负数则不校验  默认为最大int值
      if (validateFiled.maxLen() &gt;= 0) &#123;
        if (arg.toString().length() &gt; validateFiled.maxLen()) &#123;
//          logger.error(validateFiled.code() + &quot;:&quot; + validateFiled.message());
          throw new RuntimeException(validateFiled.code()  + &quot;:&quot; + validateFiled.message());
        &#125;
      &#125;
      //3.3判断字符串最小长度  如果设置为一个负数则不校验  默认为0
      if (validateFiled.minLen() &gt;= 0) &#123;
        if (arg.toString().length() &lt; validateFiled.minLen()) &#123;
//          logger.error(validateFiled.code() + &quot;:&quot; + validateFiled.message());
          throw new RuntimeException(validateFiled.code()  + &quot;:&quot; + validateFiled.message());
        &#125;
      &#125;
      //3.4判断数值最大值  当不是默认值0x1.fffffffffffffP+1023的时候进行判断
      if (validateFiled.maxVal() != 0x1.fffffffffffffP+1023) &#123;
        if (Double.parseDouble(arg.toString()) &gt; validateFiled.maxVal()) &#123;
//          logger.error(validateFiled.code() + &quot;:&quot; + validateFiled.message());
          throw new RuntimeException(validateFiled.code()  + &quot;:&quot; + validateFiled.message());
        &#125;
      &#125;
      //3.5判断数值最小值   当不是默认值0x0.0000000000001P-1022的时候进行判断
      if (validateFiled.minVal() != 0x0.0000000000001P-1022) &#123;
        if (Double.parseDouble(arg.toString()) &lt; validateFiled.minVal()) &#123;
//          logger.error(validateFiled.code() + &quot;:&quot; + validateFiled.message());
          throw new RuntimeException(validateFiled.code()  + &quot;:&quot; + validateFiled.message());
        &#125;
      &#125;

      //3.6判断正则 若未设置正则校验则跳过
      if (!&quot;&quot;.equals(validateFiled.regStr())) &#123;
        if (arg instanceof String || arg instanceof Integer || arg instanceof BigDecimal || arg instanceof Double) &#123;
          if (!(arg.toString()).matches(validateFiled.regStr())) &#123;
//            logger.error(validateFiled.code() + &quot;:&quot; + validateFiled.message());
            throw new RuntimeException(validateFiled.code()  + &quot;:&quot; + validateFiled.message());
          &#125;
        &#125;
      &#125;
    &#125;
    return;
  &#125;
&#125;
</code></pre>
<h2 id="5-3接口测试"><a href="#5-3接口测试" class="headerlink" title="5.3接口测试"></a>5.3接口测试</h2><pre><code>@RestController
@RequestMapping(&quot;validater&quot;)
public class ValidateController &#123;

  @ValidateGroup(fields = &#123;
      //如果是index=0也可以省略不写
      @ValidateField(index = 0,notNull = true,maxLen = 10,code = &quot;param1-error&quot;,message = &quot;param1校验错误&quot;),
      @ValidateField(index = 1,notNull = true,fieldName = &quot;passWord&quot;,minLen = 6,code = &quot;passWord-erro&quot;,message = &quot;密码校验错误&quot;),
      @ValidateField(index = 1,notNull = true,fieldName = &quot;age&quot;,minVal = 0,code = &quot;age-error&quot;,message = &quot;年龄不能小于0&quot;),
      @ValidateField(index = 1,notNull = true,fieldName = &quot;tall&quot;,minVal = 0,maxVal = 250.9,code =&quot;tall-error&quot;,message = &quot;身高范围出错&quot;),
      @ValidateField(index = 1,notNull = true,fieldName = &quot;phone&quot;,regStr = &quot;^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\\d&#123;8&#125;$&quot;,code = &quot;phone-error&quot;,message = &quot;手机号错误&quot;)
  &#125;)
  @PostMapping(&quot;post&quot;)
  public String postValidater(@RequestParam String param1,  RegisterDto dto)&#123;

    System.out.println(&quot;成功通过校验&quot;);
    System.out.println(&quot;第一个参数是：&quot; + param1);

    System.out.println(&quot;第二个参数是&quot;+dto.toString());

    return &quot;succeed&quot;;
  &#125;
&#125;
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/e5f4ac9d44474348ba35f74fc9263209.png"><br>如果参数错误，则会直接抛异常终止请求<br><img src="https://img-blog.csdnimg.cn/09ae76ac260b4970a236069c7e020fa6.png"></p>
<p>如果参数都正确就可以通过校验，如下：<br><img src="https://img-blog.csdnimg.cn/1f5e188fef6142eca85c1074208832ee.png"></p>
<h1 id="6-可扩展的点"><a href="#6-可扩展的点" class="headerlink" title="6.可扩展的点"></a>6.可扩展的点</h1><p>传入的参数是加密后的，那么可以再写一个拦截器对入参dto中的属性进行解密，这里可以参考<br><a target="_blank" rel="noopener" href="https://zjhblog.gitee.io/zjh/2022/08/12/%E5%AF%B9dto%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7%E4%B8%80%E9%94%AE%E5%8A%A0%E8%A7%A3%E5%AF%86/">对dto指定属性一键加解密</a></p>
<p>也可以调用这个工具类直接写在这个AspectJ里面</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blogzjh.github.io/2022/08/13/AOP-%E5%8F%8D%E5%B0%84%EF%BC%9A%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/" data-id="cl8wvrz8b0001kktah2cvamnu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/08/14/Spring%E3%80%81Servlet%E7%9B%91%E5%90%AC%E5%99%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Spring、Servlet监听器
        
      </div>
    </a>
  
  
    <a href="/2022/08/12/%E5%AF%B9dto%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7%E4%B8%80%E9%94%AE%E5%8A%A0%E8%A7%A3%E5%AF%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">对dto指定属性一键加解密</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0/">工作笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/">数据结构算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/26/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%81%9A%E9%BB%91%E5%90%8D%E5%8D%95%E7%9A%84%E6%96%B9%E6%A1%88/">布隆过滤做黑名单的方案</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E6%9F%90%E8%9A%81%E9%87%91%E6%9C%8D%E7%A7%8B%E6%8B%9B9-15/">某蚁金服秋招9-15</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">三种情况的层序遍历</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E5%87%A0%E9%81%93%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98-dfs-%E5%89%AA%E6%9E%9D-%E5%9B%9E%E6%BA%AF/">几道岛屿问题:dfs+剪枝+回溯</a>
          </li>
        
          <li>
            <a href="/2022/09/15/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A%E6%9B%BF%E6%8D%A2%E3%80%81%E5%B7%A6%E6%97%8B%E3%80%81%E7%BC%BA%E5%A4%B1/">字符串：替换、左旋、缺失</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 张家豪<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>